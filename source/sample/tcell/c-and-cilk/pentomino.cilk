#include <cilk-lib.cilkh>
#include <stdio.h>
#include <stdlib.h>

int maxp = 12;
int maxk = 70;

// thread local storage
struct task_pen {
  int a[20];         // manages which piece has been used
  int b[119];        // board（6x17 だが各列右端は壁）
};

int ps[73][5] = { // ps[i] represents the shape of the \TT{i}-th (piece, direcion)
  {1,1,1,1},{7,7,7,7},
  {4,1,1,1},{7,7,6,1},
  {6,1,1,1},{5,1,1,1},{1,1,1,5},{1,1,1,6},
  {7,1,6,7},{7,7,1,6},{7,6,1,7},{6,1,7,7},
  {7,7,1,1},{1,1,5,7},{1,1,7,7},{7,5,1,1},
  {2,5,1,1},{1,1,5,2},{1,6,7,1},{1,7,6,1},
  {7,1,1,5},{5,1,1,7},{7,6,1,1},{1,1,6,7},
  {7,1,1,6},{5,1,1,6},{6,1,1,5},{6,1,1,7},
  {1,7,1,6},{7,1,5,1},{1,5,1,7},{6,1,7,1},
  {7,1,1,7},{5,1,1,5},{1,7,7,1},{1,6,6,1},
  {6,1,1,6},
  {1,6,1,1},{1,1,5,1},{1,5,1,1},{1,1,6,1},
  {7,1,6,1},{1,6,1,6},{6,1,6,1},{1,6,1,7},
  {1,4,1,1},{1,1,7,1},{1,7,1,1},{1,1,4,1},
  {7,1,7,7},{7,6,1,6},{6,1,6,7},{7,7,1,7},
  {7,1,7,1},{1,5,1,6},{1,7,1,7},{6,1,5,1},
  /* extension */
  {1,1,1,1},{7,7,7,7},
  {1,1,1,1},{7,7,7,7},
  {1,1,1,1},{7,7,7,7},
  {1,1,1,1},{7,7,7,7},
  {1,1,1,1},{7,7,7,7},
  {1,1,1,1},{7,7,7,7},
  {1,1,1,1},{7,7,7,7},
  {1,1,1,1},{7,7,7,7}
};

/* 13 -> 21 */
int pos[21] = { 0, 2, 4, 12, 16, 20, 24, 32, 36, 37, 45, 53, 57,
		/* extension */
		59, 61, 63, 65, 67, 69, 71, 73};
// ps[i] for pos[p]<i<pos[p+1] corresponds the shape for the \TT{p}-th piece


// 探索メイン
// Try from the \TT{j0}-th piece to the \TT{maxp}-th piece in \TT{a[]}.
// The \IT{i}-th piece for \IT{i}}<\RM{\TT{j0} is already used.
// \TT{b[k]} is the first empty cell in the board.
cilk int search(int k, int j0, struct task_pen *tsk)
{
  int s = 0;
  int p;
#ifndef ALWAYS_COPY
  struct task_pen this_tsk;
  struct task_pen *st = &this_tsk;
#else
  struct task_pen *st;
#endif

  for (p=j0; p<maxp; p++) {
    int ap = tsk->a[p], i;
    for(i = pos[ap]; i < pos[ap+1]; i++)
      /* examine the "i"-th (piece, direction)
	 at the first empty location "k" */
      {
	int *pss = ps[i];
	int kk=k,l;
	/* room available? */
	for(l=0;l<4;l++) if((kk += pss[l]) >= maxk || tsk->b[kk] !=0) goto Ln;

#ifndef ALWAYS_COPY
	if(!SYNCHED) {
#endif
	  st = Cilk_alloca(sizeof(struct task_pen));
#ifndef ALWAYS_COPY
	}
#endif
        *st = *tsk;
        // set the piece \TT{p} into the board
	st->b[kk=k] = p+'A'; for(l=0;l<4;l++) st->b[kk += pss[l]] = p+'A';
	st->a[p] = st->a[j0]; st->a[j0] = ap;

	// 次の空きセルをみつける
	for(kk=k; kk<maxk; kk++) if( st->b[kk] == 0 ) break;
	// 全セルが埋まっていたら
	if(kk == maxk)
	  s += 1;
	// そうでなければ（周辺を見て置けそうなら？）次のステップ
	else if((kk+7 >= maxk || st->b[kk+7] != 0) && 
		(st->b[kk+1] != 0 || 
		 (kk+8 >= maxk || st->b[kk+8] != 0) && st->b[kk+2] != 0))
	  ;
	else
	  s += spawn search(kk, j0 + 1, st);

      Ln:
	continue;
      }
  }
  sync;
  return s;
}

cilk int main(int argc, char *argv[]){
  struct task_pen *x;
  int a, i, kk;
  Cilk_time tm_begin, tm_elapsed;
  Cilk_time wk_begin, wk_elapsed;
  Cilk_time cp_begin, cp_elapsed;

  x = malloc(sizeof(struct task_pen));

  if (argc < 2)
    printf("%s: number of pieces required\n", argv[0]);

  if (argc > 2)
    printf("%s: extra arguments being ignored\n", argv[0]);

  if (argc >= 2)
    maxp = atoi(argv[1]);

  if (maxp < 0 || maxp > 20) {
    printf("%s: no more than 20 pieses\n", argv[0]);
    return 1;
  }

  for(i=0;i<maxp;i++) x->a[i] = i;
  for(i=0;i<119;i++)  x->b[i] = 0;
  for(i=6;i<119;i+=7) x->b[i] = '\n'; /* right side wall */

  kk = 0;
  for(i=0;i<maxp*5;i++)
    for(kk++; kk<119; kk++) if( x->b[kk] == 0 ) break;
  maxk = kk;
  for(; kk<119; kk++) if( x->b[kk] == 0 ) x->b[kk] = '*';

  sync;
  cp_begin = Cilk_user_critical_path;
  wk_begin = Cilk_user_work;
  tm_begin = Cilk_get_wall_time();

  a = spawn search(0, 0, x);  
  sync;

  /* Timing. "Stop" timers */
  tm_elapsed = Cilk_get_wall_time() - tm_begin;
  wk_elapsed = Cilk_user_work - wk_begin;
  cp_elapsed = Cilk_user_critical_path - cp_begin;

  if (a > 0)
    printf("%d possible result!\n", a);
  else
    printf("no possible result!\n");

  printf("\n");
  printf("Running time  = %4f s\n", Cilk_wall_time_to_sec(tm_elapsed));
  printf("Work          = %4f s\n", Cilk_time_to_sec(wk_elapsed));
  printf("Critical path = %4f s\n\n", Cilk_time_to_sec(cp_elapsed));

  return 0;
}
