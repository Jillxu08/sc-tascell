#include <cilk-lib.cilkh>
#include <stdio.h>
#include <stdlib.h>

/* app */

// thread local strogae
struct task_nq {
  int a[20];     // 使用済み行の管理
  int lb[40];    // 盤面情報1
  int rb[40];    // 盤面情報2
};

// 逐次版
#if 0
int 
nqueens(int n, int k, int *a, int *lb, int *rb)
{
  if (n == k)
    return 1;
  else
    {
      int s = 0;
      int i;
      /* try each possible position for queen <k> */
      for (i = k; i < n; i++) {
	int ai = a[i];
	if (! (lb[n - 1 - ai + k] || rb[ai + k])){
	  lb[n - 1 - ai + k] = 1; rb[ai + k] = 1;
	  a[i] = a[k]; a[k] = ai;
	  s += nqueens(n, k + 1, a, lb, rb);
	  ai = a[k]; a[k] = a[i]; a[i] = ai;
	  lb[n - 1 - ai + k] = 0; rb[ai + k] = 0;
	}
      }
      return s;
    }
}
#endif

// k: a[j] (0<k)までの行にはもう置いた
/* cilk int nqueens(int n, int k, struct task_nq *tsk) */
/* { */
/*   // 最後までおけたら */
/*   int s = 0; */
/*   int i; */
/*   struct task_nq new_tsk; */
/*   struct task_nq *st = &new_tsk; */

/*   for(i = k; i < n; i++) { // 次の駒をどこにおくかで並列化 */
/*     int ai = tsk->a[i]; */
/*     // 駒が置けるかチェック */
/*     if (! (tsk->lb[n - 1 - ai + k] || tsk->rb[ai + k])){ */
/*       if (k == n -1) return 1; */
/*       if(!SYNCHED) { */
/* 	st = Cilk_alloca(sizeof(struct task_nq)); */
/*       } */
/*       *st = *tsk; */
/*       st->lb[n - 1 - ai + k] = 1; st->rb[ai + k] = 1; */
/*       st->a[i] = st->a[k]; st->a[k] = ai; */
/*       // 次のステップ */
/*       s += spawn nqueens(n, k + 1, st);  */
/*     } */
/*   } */
/*   sync; */
/*   return s; */
/* } */

cilk int nqueens(int n, int k, struct task_nq *tsk)
{
  // 最後までおけたら
  int s = 0;
  int i;
  struct task_nq *st;
  int reusable = 0;

  for(i = k; i < n; i++) { // 次の駒をどこにおくかで並列化
    int ai = tsk->a[i];
    // 駒が置けるかチェック
    if (! (tsk->lb[n - 1 - ai + k] || tsk->rb[ai + k])){
      if (k == n -1) return 1;
      if(!reusable) {
        st = Cilk_alloca(sizeof(struct task_nq));
        *st = *tsk; // 頑張れば a については一部だけコピーにできるが...
      }
      st->lb[n - 1 - ai + k] = 1; st->rb[ai + k] = 1;
      st->a[i] = st->a[k]; st->a[k] = ai;
      // 次のステップ
      s += spawn nqueens(n, k + 1, st);
      reusable = 0;
      if(SYNCHED && i + 1 < n) {
        reusable = 1;
        // backtrack
        ai = st->a[k]; st->a[k] = st->a[i]; st->a[i] = ai;
        st->lb[n - 1 - ai + k] = 0; st->rb[ai + k] = 0;
      }
    }
  }
  sync;
  return s;
}

cilk int cilk_main(int argc, char *argv[])
{
  int n;
  struct task_nq *x;
  int a, i;
  Cilk_time tm_begin, tm_elapsed;
  Cilk_time wk_begin, wk_elapsed;
  Cilk_time cp_begin, cp_elapsed;

  if (argc < 2) {
    printf("%s: number of queens required\n", argv[0]);
    return 1;
  }
  if (argc > 2)
    printf("%s: extra arguments being ignored\n", argv[0]);

  n = atoi(argv[1]);

  x = malloc(sizeof(struct task_nq));
  for(i=0;i<n;i++)
    x->a[i] = i;
  for(i=0;i<2*n-1;i++)
    x->lb[i] = x->rb[i] = 0;

  printf("running queens %d\n", n);

  /* Timing. "Start" timers */
  sync;
  cp_begin = Cilk_user_critical_path;
  wk_begin = Cilk_user_work;
  tm_begin = Cilk_get_wall_time();

  a = spawn nqueens(n, 0, x);  
  sync;

  /* Timing. "Stop" timers */
  tm_elapsed = Cilk_get_wall_time() - tm_begin;
  wk_elapsed = Cilk_user_work - wk_begin;
  cp_elapsed = Cilk_user_critical_path - cp_begin;

  if (a > 0)
    printf("%d possible result!\n", a);
  else
    printf("no possible result!\n");

  printf("\n");
  printf("Running time  = %4f s\n", Cilk_wall_time_to_sec(tm_elapsed));
  printf("Work          = %4f s\n", Cilk_time_to_sec(wk_elapsed));
  printf("Critical path = %4f s\n\n", Cilk_time_to_sec(cp_elapsed));

  return 0;
}
