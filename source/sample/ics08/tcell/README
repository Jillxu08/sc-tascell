[2007/12/26 修正]
主なファイルの説明
* worker.{c,sc}, :  大林くんの修論のソースそのもの
* worker2.{c,sc}, worker2.{h,sh}: 
   worker.cを複数種類のタスクに対応できるように改良し，ヘッダと本体に分けたもの．
* worker3.{c,sc}, worker2.{h,sh}: 
   worker2.cをppopp08投稿後にさらに修正したもの．worker3.scの冒頭を参照．
* Messages: worker{2,3} におけるメッセージフォーマットの簡易説明
* {fib,lu,pen,pen6x17,nq,cmp,grav}.tcell: T-CELLプログラム
* 上記に対応する *-{c,gcc,lw,clos,xcc,xccl,icc-c,icc-lw,icc-clos}.c:
   T-CELLプログラムをそれぞれの入れ子関数のバージョンのCに変換したもの

* EVAL-INPUT: 各T-CELLプログラムの計算を起動するためにユーザから送りこむtaskコマンドの例
* server.lsp: Lispで実装したT-Cellサーバ
* Makefile:

（実行例）
(1)サーバ側（要Allegro Common Lisp)
===
% alisp
> :cl server.lsp
> (make-and-start-server :local-host "gero00")
===

(2)計算ノード側
===
% ./fib-gcc 2 -s gero
===
※ サーバのポート番号は，make-and-start-serverのキーワード引数で変更可
※ 計算ノードのポート番号は -p オプションで変更可
※ ポート番号のデフォルトは，双方とも8888
※ 2はノード内worker数

(3)サーバに計算要求を流しこむ
alispが標準入力待ち状態になっているので，
===
task 0 p 0:0 0
30
<空行>
===
とすればよい（fibの場合）．

なお，1つの計算ノードをとりあえず動かしたい場合（サーバをユーザからの入力で代用）は，単に
===
% ./fib-gcc -n 2
task 0 0 0 0
20
<空行>
===
などとすればよい．

######################################################3
性能測定：
gero:/work/hiraisi/tcell  を起点とする
gero01

** fib **
逐次：fib-c
task 0 0 0 1
40
<空行>
Cilk: c-and-cilk/fib --nproc <nproc> <n>
Tascell: fib-lw <nworker>   n=ワーカ数
task 0 0 0 1
40
<空行>

** nqueen **
逐次: c-and-cilk/nqueen-seq <n>  n:問題サイズ
Cilk: c-and-cilk/nqueen --nproc <nproc> <n>
Tascell: nq-lw -n <nworker>
task 0 0 0 0
15                ; <問題サイズ>
-1
<空行>

** pen **
逐次 : c-and-cilk/pentomino-seq <n>   n:ピース数．12 で普通の
Cilk: c-and-cilk/pentomino --nproc <nproc> <n>
Tascell: pen6x17-lw -n <nworker>
task 0 0 0 1
12                ; <ピース数>
<空行>

** lu **
c-and-cilk/lu-seq は根本的にアルゴリズムが違うので注意
逐次: lu-c の後 Tascellと同様に
Cilk: c-and-cilk/lu002 --nproc <nproc> <n> 2 ; n:問題サイズ，最後の2を忘れないこと（並列にならない）
Tascell: lu-lw -n <nworker>
task 0 0 0 0
0                 ; 新規の問題
2000              ; <問題サイズ>
2                 ; 1: 逐次， 2: 並列
0                 ; デバッグレベル

** comp **
逐次: c-and-cilk/cmp-seq <n>   n:配列長
Cilk: c-and-cilk/cmp --nproc <nproc> <n>
Tascell: cmp-lw -n <nworker>
task 0 0 0 0
30000            ; <配列長>
-1
<空行>

** grav **
逐次: grav-c -n <nworker> として下記
Cilk: c-and-cilk/grav --nproc <nproc> <minx> <miny> <minz> <maxx> <maxx> <maxz> <x> <y> <z>
Tascell: garv-lw -n <nworker>
task 0 0 0 1
-100
-100
-100
100
100
100
25
25
25
<空行>
※ <x>, <y>, <z> は浮動小数点数で100で割った値になる

==== 分散版 ====
gero: ~hiraisi/work/sc/soource/sample/tcell にて
alisp 起動
> :cl server.lsp
> (gs)
で拠点サーバ起動

geroの別のターミナルで
~hiraisi/bin/pbrsh <node数> /work/hiraisi/tcell/なんとか-lw -n <ノードごとワーカ数> -s gero00

lisp側でaccept connection... のメッセージを確認後
<fibのばあい>
task 0 0 0:0 1   (3つめが0のかわりに 0:0，あとは上と共通)
40
とすると結果がかえってくる．
つづけて taskをながしこみたい場合は，そのまえに
rack 0:0
としたあと
task 0 0 0:0 1
40
<空行>
....

サーバを終了するには空行を入力
ワーカのプロセスが生き残っているので
~hiraisi/bin/pbrsh <node数> /worker/hiraisi/tcell/pgrep-kill なんとか-lw
で後始末．
