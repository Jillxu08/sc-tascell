;;multithread-func -> nested-func
;;pre-definiation
;;;;;;;;;;;;;;;;;;;;;;;;
;;入れ子関数をlightweightで出力するversion

(M0 (,@declaration-list))
-> (progn 
     (defvar *current-func* nil)
     (defvar *used-identifier* nil)
     (defvar *nthr-id* 'nthr)
     (defvar *var* nil)
     (defvar *nestfunc-tag* 'lightweight) ; fn or lightweight
     
     (setq n 0)
     (setq ln 0)
     
  ;(<ラベル 変数><入れ子関数名><ローカル変数><スレッドの判断(生成か継続か)>)
     (defstruct finfo
       label
       nfunc-name
       ln
       id)
     
     ; push identifier list
     (defun push-id (id)
       (unless (member (par-identifier id) *used-identifier* :test #'string=)
	 (push id *used-identifier*)))
     
     ;for nested-function, case: goto 
     (defun case-goto (list)
       (let ((y nil))
	 (setq n 0)
	 (dolist (x list y)
	   (incf n)
	   (setq y (append `((goto ,x)(case ,n)) y)))
	 (reverse y)))

     ;for nested-function, case: return
     (defun case-return (list)
       (let ((y nil))
	 (dolist (x list y)
	   (unless  (null x)
	     (setq y (append `((return (cast (ptr void)(ptr ,(get-id-from-string (string+ `("t" ,(write-to-string x))))))) (case ,x)) y))))
	 (reverse y)))

     ; make-symbol でいい？
     (defun get-id-from-string (idstring)
       (let ((idx))
	 (with-input-from-string (stream idstring)
	   (setq idx (read stream)))))	 
     
     (defun make-name (f-id)  
       (let ((n-id)(ne-id)(id))
	 (setq n-id (string+ `(,f-id _c)))
	 (setq id (get-id-from-string n-id))
	 (setq ne-id (id-to-scid n-id))
	 ; unless じゃない場合は？, memberの処理が二重
	 (unless (member ne-id *used-identifier* :test #'string=)
	   (push-id ne-id))
	 `(the (fn (ptr void) thst_ptr reason) ,id)))
     
     ;to get declaration front, but too ambiguous 
     (defun con-item (bil &aux lib)
       (setq lib (mapcar #'split-item bil))
       `(,(apply 'append (mapcar #'first lib))
	 ,(apply 'append (mapcar #'second lib))))
     
     (defun split-item (x)
       (let ((xf (first x))
	     (xs (second x)))	
	 (cond 
	   ((and (or (par-storage-class-specifier xf)
		     (eq 'deftype xf))
		 (par-identifier xs))
	    `((,x) nil))
	   (t
	    `(nil (,x))))))
     
     ;((a b)(x y)(m n)...)->((a x m)(b y n)) 
     (defun comblist (list)
       (let ((y1 nil)(y2 nil))
	 (dolist (x list y1)
	   (setq y1 (cons (car x) y1)))
	 (dolist (x list y2)
	   (setq y2 (cons (cdr x) y2)))
	 (list y1 y2)))

     ;<入れ子関数の文>をappendしたものをmake-nestfuncの引数とする
     (defun make-nestfunc (x)
       (progn 
	 (setq l-t (comblist (finfo-label *current-func*)))
	 (print l-t)(print `l-t)
	 (setq ln (finfo-ln *current-func*))
	 (print ln)
	 (setq label-l (get-id-from-string (string+ `("@L" ,(write-to-string ln)))))
	 (setq returninfos `((label ,label-l nil)
			     (= (fref cp -> c) c_p)
			     (= (fref cp -> stat) thr_runnable)
			     (return)))
	 (setq returninfo `((= (fref cp -> c) c_p)
			    (= (fref cp -> stat) thr_runnable)
			    (return)))
	 (let* ((func-id (third (finfo-nfunc-name *current-func*)))
		(flag (finfo-id *current-func*)))
	   `(def (,func-id cp rsn) (,*nestfunc-tag* (ptr void) thst_ptr reason)
	     (switch rsn 
	      (case rsn_cont)
	      (switch ln
	       ,@(case-goto (first l-t)))
	      (return)
	      (case rsn_retval)
	      (switch ln
	       ,@(case-return (second l-t)))
	      (return))
	     (return)
	     
	     ;;<入れ子関数の文>部分
	     ,@x	     
	     ,@(cond 
		((eq `thr_c flag)
		 `((return)))
		((eq `thr_s flag)
		 returninfos)
		(t
		 returninfo))
	     ))))
     (cons '
      (include "rule/multithread-b.sch")     
      (let ((*used-identifier* (get-all-identifier x)))
	(apply #'append (mapcar #'second (mapcar #'M1 x))))))

;;;;;; declaration ;;;;;;
;variable
(M1 (,scs[SCS] ,id[ID] ,texp ,@init))
-> (case texp
     ((cont)
      (list nil `((,scs ,id thst_ptr ,@(mapcar #'Mi init)))))
     (otherwise
      (list nil `((,scs ,id ,texp ,@(mapcar #'Mi init))))))

;initializer
   (Mi (aray ,@init))
   (Mi (struct ,@init))
   -> `(,(car x) ,@(mapcar #'Mi init))
   (Mi ,exp)
   -> (car (second (Me exp)))

;function
(M1 (,scs[SCS] (,func-id ,@arg-id[ID]) (fn ,func-texp ,@arg-texp) ,@body))
-> (let ((*current-func* (make-finfo :nfunc-name (make-name func-id) :ln 0))
	 (*var* nil))     
    ;元の関数から呼び出すルールの返り値を(<入れ子関数の文><元の関数の文>)
     (let* ((temp (M2 body))
	    (temp1 (make-nestfunc (first temp)))
	    (temp2 (second temp)))	           
       (setq preln `(def ln int 0))
       (setq prev (first (con-item temp2)))
       (setq post (second (con-item temp2)))
       (setq info (finfo-label *current-func*))
       (setq prev-var *var*)
       (print prev-var)(print `ooo)
       (list nil `((,scs (,func-id c_p ,@arg-id) (fn ,func-texp cont ,@arg-texp) ,preln ,@prev ,@prev-var ,temp1 ,@post)))))
	
;struct, union
(M1 (,dd[DEF-OR-DECL] (,soru[S-OR-U] ,id[ID]) ,@sdeclist))
-> (let ((chk-cont-def (mapcar #'car (mapcar #'second (mapcar #'M1 sdeclist)))))
    (list nil `((,dd (,soru ,id) ,@ chk-cont-def))))

; :bit( for struct-declaration )
(M1 (:bit ,bit))
-> (list `((:bit ,bit )) `((:bit ,bit )))      

;enum
(M1 (def (enum ,id[ID]) ,@enum-list))
-> (list nil `((def (enum ,id) ,@enum-list)))

;deftype (struct)
(M1 (deftype ,id[ID] struclt ,@sdecllist))
-> (let ((chk-cont-def (mapcar #'car (mapcar #'second (mapcar #'M1 sdeclist)))))
     (list nil `((deftype ,id struct ,@chk-cont-def))))

;deftype (enum)
(M1 (deftype ,id[ID] enum ,@enum-list))
-> (list nil `((deftype ,id enum ,@enum-list)))

;deftype
(M1 (deftype ,id[ID] ,texp))
-> (list nil `((deftype ,id ,texp)))

(M1 nil)
-> nil

;not sure
(M1 ,otherwise)
-> `(,otherwise ,otherwise))

;;;;;;;;;;;

(M2 (,@item-list))
-> (let* ((itemlist (mapcar #'Mb item-list))
	  (nest-list (apply #'append (mapcar #'first itemlist)))
	  (ori-list  (apply #'append (mapcar #'second itemlist))))
     (progn
       `(,nest-list ,ori-list)))
    
;;;;;;; body +α ;;;;;;
;function-attribute & register-decl
;(Mb (:attr ,atr ,@body))
;-> `(:attr ,atr ,@(M2 body))

;(Mb ((register ,@regarg) ,@body))
;-> `((register ,@regarg) ,@(M2 body))

;begin
(Mb (begin ,@body))
-> (let* ((begin-body (M2 body))
	  (temp2 (second begin-body)))
      (setq prev (first (con-item temp2)))
      (setq post (second (con-item temp2)))
     (list `((begin ,@(first begin-body))) `(,@prev (begin ,@post))))

;label
(Mb (label ,id ,stat))
-> (list `((label ,id ,@(Mb stat))) `((label ,id ,@(Mb stat))))

;case
(Mb (case ,exp))
-> (list `(case ,(car (first (Me exp)))) `(case ,(car (second (Me exp)))))

;default
(Mb (default))
-> (list `((default)) `((default)))

;if  
(Mb (if ,exp ,stat1 ,@stat2))
-> (if (null stat2)
       (let ((ifstat1 (Mb stat1)))
	 (list `((if ,(car (first (Me exp))) ,@(first ifstat1))) `((if ,(car (second (Me exp))) ,@(second ifstat1)))))
       (let ((ifstat1 (Mb stat1))
	     (ifstat2 (Mb (car stat2))))
       (list `((if ,(car (first (Me exp))) ,@(first ifstat1) ,@(first ifstat2))) `((if ,(car (first (Me exp))) ,@(second ifstat1) ,@(second ifstat2))))))

;switch
(Mb (switch ,exp ,@body))
-> (let* ((s-body (M2 body)))
     (list `((switch ,(car (first (Me exp))) ,@(first s-body)))`((switch ,(car (first (Me exp))) ,@(first s-body)))))

;do-while
(Mb (do-while ,exp ,@body))
-> (let* ((dobody (M2 body)))
     (list `((do-while ,(car (first (Me exp))) ,@(first dobody))) `((do-while ,(car (second (Me exp))) ,@(second dobody)))))

;goto, continue, break
(Mb (goto ,id))
(Mb (continue))
(Mb (break))
-> (list `((car x)) `((car x)))

;return
(Mb (return ,@exp))
-> (if (null exp)
       '(return)
       (let ((return-exp (car (first (Me (car exp))))))
	 (list `((= (mref (cast (ptr int)(c_p cp rsn_retval))) ,(third return-exp)))		
	       `((return ,return-exp)))))

;;; <- マルチスレッド用プリミティブ

(Mb (thread-create (,@defexp) ,@body))
->(let* ((ln (incf (finfo-ln *current-func*)))
	 (prev-tcreate nil)
	 (n 0) 
	 (thrc-exp (mapcar #'Mc defexp))
	 (label-l (get-id-from-string (string+ `("@L" ,(write-to-string ln)))))      
)
    (setq thrc-exp1 (mapcar #'first thrc-exp))
    (let ((y nil))
      (dolist (x thrc-exp1 y)
	(unless (null x)
	  (setq y (append x y))))
      (setq thrc-exp1 y))
    
    (setq thrc-exp2 (mapcar #'second thrc-exp))	
    (setf (finfo-label *current-func*) (cons (cons label-l nil) (finfo-label *current-func*)))
    (setq nthr-id *nthr-id*)
    (setq thr-id (make-name nthr-id))
    (setq prev-tcreate 
	  `((begin 
	     ,@thrc-exp1
	     (= ln ,ln)
	     (= (fref thst_top -> c) ,(finfo-nfunc-name *current-func*))
	     (= (fref thst_top -> stat) thr_new_runnable)
	     (inc thst_top))))
    (setq post-tcreate 
	  `((if (!= (fref (- thst_top 1) -> stat) thr_new_runnable)
		(scheduling)
		(dec thst_top))))
    (let* ((*current-func* (make-finfo :nfunc-name thr-id :ln 0 :id `thr_c))
	   (prevln `((def ln int 0)))
	   (thrc-body (M2 body))
	   (thrc-nest (append thrc-exp2 prevln (list (make-nestfunc (first thrc-body)))))
	   (thrc-ori (second thrc-body)))
      (list `(,@(append prev-tcreate `((begin ,@thrc-nest ,@thrc-ori)) post-tcreate) (label ,label-l nil))
	    `( ,@(append prev-tcreate `((begin ,@thrc-nest ,@thrc-ori)) post-tcreate)))))     


(Mc (,scs[SCS] ,id[ID] ,texp ,@init))
->(if (null init)	
      (list nil `(,scs ,id ,texp ,@init))
      (let* ((n (incf n))		
	     (var-v (get-id-from-string (string+ `("v" ,(write-to-string n))))))
	(unless (member var-v *used-identifier* :test #'string=)
	  (progn (push var-v *used-identifier*)
		 (setq *var* (cons `(def ,var-v ,texp) *var*))))
	(list `((=  (the ,texp ,var-v) ,@init)) `(,scs ,id ,texp ,var-v ))))

#|      
(Mb (thread-suspend ,exp ,@body))
->(let* ((ln (incf (finfo-ln *current-func*)))
	 (nested-func (finfo-nfunc-name *current-func*))
	 (thr_s_body (M2 body))
	 (var-c (second exp))
	 (label-l (get-id-from-string (string+ `("@L" ,(write-to-string ln))))))
    (progn
      (setf (finfo-label *current-func*) 
	    (cons (cons label-l nil)(finfo-label *current-func*)))
      (setf (finfo-id *current-func*) `thr_s)
      (list `(
	        (begin 
		 (def ,var-c thst_ptr cp)
		 (= (fref ,var-c -> c) ,nested-func)
		 (= (fref ,var-c -> stat) thr_suspended)
		 ,@(first thr_s_body)
		 (= ln ,ln)
		 (return)))      
	   `(
	     (begin 
	      (def ,var-c thst_ptr (inc thst_top))
	      (= (fref ,var-c -> c) ,nested-func)
	      (= (fref ,var-c -> stat) thr_new_suspended)
	      ,@(second thr_s_body)
	      (= ln ,ln)
	      (scheduling))))))
|#


(Mb (thread-suspend ,exp ,@body))
->(let* ((ln (incf (finfo-ln *current-func*)))
	 (nested-func (finfo-nfunc-name *current-func*))
	 (thr_s_body (M2 body))
	 (var-c (second exp))
	 (label-l (get-id-from-string (string+ `("@L" ,(write-to-string ln))))))
    (print var-c)(print `ccc)  
    (setf (finfo-label *current-func*) 
	    (cons (cons label-l nil)(finfo-label *current-func*)))      
      (setf (finfo-id *current-func*) `thr_s)
      (setq *var* (cons `(def ,var-c thst_ptr cp) *var*))
      (list `(
	      (begin 
	       (= (fref ,var-c -> c) ,nested-func)
	       (= (fref ,var-c -> stat) thr_suspended)
	       ,@(first thr_s_body)
	       (= ln ,ln)
	       (return)))      
	    `(
	      (begin 
	       (= ,var-c thst_ptr (inc thst_top))
	       (= (fref ,var-c -> c) ,nested-func)
	       (= (fref ,var-c -> stat) thr_new_suspended)
	       ,@(second thr_s_body)
	       (= ln ,ln)
	       (scheduling)))))

(Mb (thread-resume ,exp))
-> (list `((thr_resume ,exp)) `((thr_resume ,exp)))

;;; マルチスレッド用プリミティブ

;expression-statement or declaration
(Mb ,otherwise)
-> (let ((expression-stat (Me otherwise)))
     (if (eq '$not-expression expression-stat)
	 (let ((temp (M1 otherwise)))
	   `(,(first temp) ,(second temp)))
	 (progn
	 `( ,(first expression-stat) ,(second expression-stat)))))

(Mb nil)
-> nil

;;;;;;;;;;;
; exp
(Me (the ,texp ,exp[ID]))
(Me (the ,texp ,exp[integerp]))
(Me (the ,texp ,exp[characterp]))
(Me (the ,texp ,exp[numberp]))
(Me (the ,texp ,exp[stringp]))
-> (list `(,x) `(,x))

(Me (the ,texp (inc ,exp)))
(Me (the ,texp (dec ,exp)))
(Me (the ,texp (++ ,exp)))
(Me (the ,texp (-- ,exp)))
(Me (the ,texp (bit-not ,exp)))
-> (list `((the ,texp ,(third x))) `((the ,texp ,(third x))))

; aref ; fref ; ptr ; mref
(Me (the ,texp1 (aref ,texp2 ,exp)))
(Me (the ,texp (fref ,exp ,id)))
(Me (the (ptr ,texp) (ptr ,exp)))
(Me (the ,texp (mref ,exp)))
-> (list `(,x) `(,x))

; sizeof
(Me (the int (sizeof ,exp[EXP])))
(Me (the int (sizeof ,texp)))
-> (list `(,x) `(,x))

; cast
(Me (the ,texp (cast ,texp ,exp)))
-> (list `(,x) `(,x))

;if-exp, and, or
(Me (the ,texp (if-exp ,exp1 ,exp2 ,exp3)))
(Me (the int (and ,exp1 ,exp2)))
(Me (the int (or ,exp1 ,exp2)))
-> (list `(,x) `(,x))

(Me (the ,texp (= ,exp1 ,exp2)))
-> (let* ((exp (Me exp2))
	  ;nestfunc
	  (addexp (car (first exp)))
	  ;orifunc
	  (addeexp (car (second exp))))
     (if (and (listp (third exp2))
	      (eq 'call (caaddr exp2)))
	 
	 ;for function-call
	 (let* ((addexp1 (first addexp))
		(addexp2 (second addexp))
		(addexp3 (third addexp))
		(var-t (get-id-from-string (string+ `("t" ,(write-to-string (third addexp1))))))
		(tinfo `(=  (the ,texp ,var-t) ,addexp2))
		(ttmp-info `(= ,exp1 ,var-t))
		(oriinfo `(= ,exp1 , addexp2)))
	   (unless (member var-t *used-identifier* :test #'string=)
	     (progn (push var-t *used-identifier*)
		    (setq *var* (cons `(def ,var-t ,texp) *var*))))
	   (list `(,addexp1 ,tinfo ,addexp3 ,ttmp-info) `(,addexp1 ,oriinfo)))
	 (list `((the ,texp (= ,exp1 ,addexp))) `((the ,texp (= ,exp1 ,addeexp))))))

; function-call
(Me (the ,texp (call (the (fn ,fexp1 ,@fexp) ,f-id) ,@arg-list)))
->(let* ((nest-func (finfo-nfunc-name *current-func*))
	 (ln (incf (finfo-ln *current-func* )))	 
	 (label-l (get-id-from-string (string+ `("@L" ,(write-to-string ln)))))
	 (var-val-t ln))

    (let ((lninfo `(= ln ,ln))
	  (call-ret  `(the ,texp (call (the (fn ,fexp1 (fn (ptr void) thst_ptr reason) ,@fexp) ,f-id) ,nest-func ,@arg-list)))
	  (label-info `(label ,label-l)))
      (if (eq `void texp)
	  (progn
	    (setf (finfo-label *current-func*) (cons (cons label-l nil)(finfo-label *current-func*)))	
	    (list `( ,lninfo ,call-ret ,label-info) `(,lninfo ,call-ret )))
	  (progn
	    (setf (finfo-label *current-func*) (cons (cons label-l var-val-t)(finfo-label *current-func*)))
	    (list `(( ,lninfo ,call-ret ,label-info)) `(( ,lninfo ,call-ret)))))))
	   
; operators
(Me (the ,texp (,op ,@exp-list)))
-> (case op
     ((* / % + - bit-xor bit-and bit-or << >> *= /= %= += -= <<= >>=  bit-and= bit-xor= bit-or= < > <= >= == != exps )
      (list `((the ,texp (,op ,@exp-list))) `((the ,texp (,op ,@exp-list))))))

(Me nil)
-> nil

(Me ,otherwise)
-> '$not-expression


