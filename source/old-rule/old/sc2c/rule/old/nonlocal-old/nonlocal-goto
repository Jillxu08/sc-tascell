From: Hiraishi Tasuku <hiraisi@kuis.kyoto-u.ac.jp>
Subject: 入れ子関数から親関数への goto 脱出
Date: Tue, 09 Mar 2004 02:48:18 JST

> 平石です。
> 
> 李さんの卒研(田畑さんの論文)のマルチスレッドの実装の、変換後コード中、
> スケジューリング関数で、入れ子関数から親関数へgotoで脱出している
> 箇所があったので、今やっている
> 「lightweight宣言の入れ子関数 => 入れ子関数を使わないSCコード」
> の変形でも対応させようとしています。
> 
> そこで、実装方法を考えているのですが、今考えている方法は、
> 
> 1.関数を脱出するgotoを見つけたら、goto先関数のcall_idを書き換えて return
> 2.基本的には、今まで関数が呼び出された逆順に関数を辿っていき、
>   goto先の関数を見つけ、見つかればそのgoto先に跳んで実行再開、
>   という方法をとる。
>   (goto先の関数かどうかの判断は、call_idの値で行う)

ここの「関数」，変換前の関数と，変換後の関数がごっちゃになってません?
と思ったのですが，変換前の関数と思えばよさそうですね．

goto をするのは入れ子関数ですよね．
入れ子関数の本体の実行は，Cスタックは空の状況で行われますよね．
(入れ子関数が入れ子関数を呼び出す分だけ空ではないが)

1.をやるなら，通常の関数については呼び出し元に戻っていく必要はなくて
上の2．は入れ子関数から(直接・間接に)入れ子関数を呼び出したときだけ
やればよくないでしょうか?

通常の関数が入れ子関数を呼び出そうとして，Cスタックは空の状況
にしたら，呼出し後は，再開するためにスタックの底からCスタックを
再構築しますが，callid を変更しておけば，それ以上の再構築を
しないで，goto 先の処理に移るように思えます．

> (3.このとき、goto先を求めて逆順に辿っているということを知るために、
>   * 関数呼び出し時の第一引数 esp
>     (<== 関数の実行が中断されていることを知るために、下位1bitフラグを
>          立てているところのもの)
>   * 関数をreturnするときに指定する、estackのトップへのポインタ値
>     (通常関数の場合は、return前に設定する efp->tmp_esp,
>      入れ子関数の場合は返り値)
>   の双方に、フラグを立てておく(下位2bit目を使用)。)
> 
> というものですが、このような感じで良いでしょうか。

そうすると，3. はやらなくてよいように思います．
(3. は変換後の話ですね．)
ただし，入れ子関数から(直接・間接に)入れ子関数を呼び出したときは，
変換後の入れ子関数が0ではなく，goto先の fr を返すようにすればよさそうです．

いまは，変換後の入れ子関数が間接的に入れ子関数を呼び出したときは
明示的スタックトップを返していましたが，これはやめて，
各入れ子関数がmain関数のように，lw_call を呼び出すループを持てばよさそうです．
lw_call はリターン値をそのまま返し，0以外が返されたときは，
Cスタックの再構築をすべきか，それともさらにリターンすべきか，
それとも関数内でgotoすべきかを，goto先fr と efp の大小比較で決定すれば
よさそうです．

void lw_call(char *esp){
  char *tmp_esp;
  closure_t *clos = MREF(closure_t *, esp);
  char *new_esp = esp;
  while(tmp_esp = (clos->fn) (new_esp, clos->fr)){
    lw_call(tmp_esp);
    new_esp = esp + 1;
  }
}

ではなく，

char *lw_call(char *esp){
  closure_t *clos = MREF(closure_t *, esp);
  return (clos->fn) (esp, clos->fr);
}

とします．

入れ子関数から外に出る

goto L0;

とかは，一段外なら，

xfp->callid = なんとか;
return (char *)xfp;

とか，2段外なら，

xfp->xfp->callid = なんとか;
return (char *)(xfp->xfp);

とかにする．

入れ子関数では，通常の関数fooの呼出しを

  new_esp = esp;
  tmp_arg1 = 1;
  while ((tmp_res1 = foo(new_esp, tmp_arg1)) == SPECIAL(int) &&
	 (efp->tmp_esp = MREF(char *, esp)) != 0){
    char *goto_fr;
    MREF(char *, esp) = 0;
    efp->... = ...;
    goto_fr = lw_call (efp->tmp_esp);
    if(goto_fr){
       if(goto_fr < efp) return goto_fr;
       if(goto_fr == efp) goto Lgoto;
    }
    ... = efp->...;
    new_esp = esp + 1;
    tmp_arg1 = efp->tmp_arg1;  // 消すと遅くなる???
  }

のように，通常の関数での

    efp->callid = 0;
    return SPECIAL(int);
  L_call0:

などの代わりに，

    goto_fr = lw_call (efp->tmp_esp);
    if(goto_fr){
       if(goto_fr < efp) return goto_fr;
       if(goto_fr == efp) goto Lgoto;
    }

として，

  Lgoto:
    switch(efp->callid){
    case -1: goto L...
    case -2: goto L...
    }

を適当なところにおいておきます．

入れ子関数では，入れ子関数の呼出しでも，

    efp->callid = 0;
    return SPECIAL(int);
  L_call0:

などの代わりに，

    goto_fr = lw_call (efp->tmp_esp);
    if(goto_fr){
       if(goto_fr < efp) return goto_fr;
       if(goto_fr == efp) goto Lgoto;
    }

とすればよいのではないかと思います．

また，lw_call は小さいので展開してしまってよいかもしれません．

> (そもそもgccではどのような実装になってるのでしょうか？)

gcc は，アセンブリ言語レベルでのCスタックの比較的直接的な調整と，
アセンブリ言語レベルでの goto の組み合わせです．

XC-cube の，lightweight はまだ対応していません．

八杉


