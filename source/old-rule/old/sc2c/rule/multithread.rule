;; MT-SC(with type information) -> SC-0 (with nested-functions)
;;
;; Written by Xiaolu Li (Feb, 2004)
;; Refined by Tassuku Hiraishi (May, 2004)

;; 2004/06/14 c-expressionに対応

;; ＊cont の扱い
;; 田畑さんの論文のコード例では，
;; 高水準言語の cont は ( 継続＋スレッドの状態 ) の組
;; C レベルでの cont は 継続
;;              thst-ptr は( 継続＋スレッドの状態 ) の組
;; 紛らわしいので C の cont を cont-f に変え，
;; MT-SCで cont 用に (deftype cont thst-ptr)としてしまうことにした
;; cont -> thread としたほうが意味的にわかりやすい気もする．
(%require "MULTITHREAD-DEFS")

(M0 (,@declaration-list))
-> (progn
     (append `((%defconstant @nestfunc-tag ,*nestfunc-tag*)
	       (%include "rule/multithread.sh"))
	     (let ((*used-identifier* (get-all-identifier x)))
	       (mapcan (compose #'second #'M1) x))))

;;;;;; declaration ;;;;;;
; variable
(M1 (,scs[SCS] ,id[ID] ,texp ,@init))
-> (list nil (list x))
#|
(case texp
  ((cont)
   (list nil `((,scs ,id thst_ptr ,@(mapcar #'Mi init)))))
  (otherwise
   (list nil `((,scs ,id ,texp ,@(mapcar #'Mi init))))))

;initializer
   (Mi (array ,@init))
   (Mi (struct ,@init))
   -> `(,(car x) ,@(mapcar #'Mi init))
   (Mi ,exp)
   -> (car (second (Me exp)))
|#

;M1, Mb, Me の返り値は
;(<入れ子関数のitem> <元の関数のitem>)
; function
(M1 (,scs[SCS] (,func-id ,@arg-id[ID]) (fn ,func-texp ,@arg-texp) ,@body))
-> (let ((*current-func*
	  (make-finfo
	   :id func-id
	   :rettype func-texp
	   :nfunc-id (make-nestfunc-id func-id))))
     (push '(def ln int 0) (finfo-decl *current-func*))
     (let* ((m2-body (M2 body))
	    (def-nfunc (make-nestfunc (first m2-body)))
	    (sep-body (separate-decl (second m2-body)))
	    (new-decl (first sep-body))
	    (new-body (second sep-body))
	    (add-decl (finfo-decl *current-func*)))
       (list nil 
	     `((,scs (,func-id c_p ,@arg-id)
		(fn ,func-texp cont-f ,@arg-texp)
		,@new-decl ,@add-decl ,def-nfunc ,@new-body)
	       ;;msc-main関数なら、main関数の定義を追加
	       ,@(when (eq 'msc-main func-id) 
		       `((%include "rule/multithread-main.sc")))))))

; struct, union
(M1 (,dd[DEF-DECL] (,soru[S-OR-U] ,id[ID]) ,@sdeclist))
-> (list nil (list x))
#|
-> (let ((chk-cont-def (mapcar #'car (mapcar #'second (mapcar #'M1 sdeclist)))))
     (list nil `((,dd (,soru ,id) ,@chk-cont-def))))

; :bit( for struct-declaration )
(M1 (:bit ,bit))
-> (list `((:bit ,bit )) `((:bit ,bit )))      
|#

;enum
(M1 (def (enum ,id[ID]) ,@enum-list))
-> (list nil `((def (enum ,id) ,@enum-list)))

;deftype (struct)
(M1 (deftype ,id[ID] struclt ,@sdecllist))
-> (list nil (list x))
#|
-> (let ((chk-cont-def (mapcar #'car (mapcar #'second (mapcar #'M1 sdeclist)))))
     (list nil `((deftype ,id struct ,@chk-cont-def))))
|#

;deftype (enum)
(M1 (deftype ,id[ID] enum ,@enum-list))
-> (list nil `((deftype ,id enum ,@enum-list)))

;deftype
(M1 (deftype ,id[ID] ,texp))
-> (list nil `((deftype ,id ,texp)))

;otherwise
(M1 ,otherwise)
-> (list nil (list otherwise))

;;;;;;;;;;;

;function-attribute & register-decl
;(M2 (:attr ,atr ,@body))
;-> `(:attr ,atr ,@(M2 body))
;(M2 ((register ,@regarg) ,@body))
;-> `((register ,@regarg) ,@(M2 body))

(M2 (,@item-list))
-> (let* ((m2-ilist (mapcar #'Mb item-list))
	  (cen-m2-ilist (combine-each-nth m2-ilist))
	  (nest-list (apply #'append (first cen-m2-ilist)))
	  (ori-list  (apply #'append (second cen-m2-ilist))))
     (list nest-list ori-list))

;function-attribute & register-decl
;(Mb (:attr ,atr ,@body))
;-> `(:attr ,atr ,@(M2 body))

;(Mb ((register ,@regarg) ,@body))
;-> `((register ,@regarg) ,@(M2 body))

;begin
(Mb (begin ,@body))
-> (let* ((m2-body (M2 body)))
     (list `( (begin ,@(first m2-body)) )
	   `( (begin ,@(second m2-body)) )))

;label
(Mb (label ,id ,stat))
-> (let* ((mb-stat (Mb stat))
	  (stat-n (first mb-stat))
	  (stat-p (second mb-stat)))
     (list `( (label ,id ,(car stat-n)) ,@(cdr stat-n) )
	   `( (label ,id ,(car stat-p)) ,@(cdr stat-p) )))

;case
(Mb (case ,exp))
-> (let ((me-exp (Me exp)))
     (list `( (case ,(car (first me-exp))) )
	   `( (case ,(car (second me-exp))) )))

;default
(Mb (default))
-> (list '( (default) )
	 '( (default) ))

;;; if文中などに現れるexpは，
;;; tmp.ruleの変形により，関数呼び出しを含まないようになっている．

;if
(Mb (if ,exp ,stat1))
-> (Mb `(if ,exp ,stat1 () ))
(Mb (if ,exp ,stat1 ,stat2))
-> (let* ((me-exp (Me exp))
	  (mb-stat1 (Mb stat1))
	  (mb-stat2 (Mb stat2)))
     (list `( (if ,(car (first me-exp))
		  (begin ,@(first mb-stat1))
		(begin ,@(first mb-stat2))) )
	   `( (if ,(car (second me-exp))
		  (begin ,@(second mb-stat1))
		(begin ,@(second mb-stat2))) )))

;switch
(Mb (switch ,exp ,@body))
-> (let* ((m2-body (M2 body)))
     (list `( (switch ,exp ,@(first m2-body)) )
	   `( (switch ,exp ,@(first m2-body)) )))

;do-while
(Mb (do-while ,exp ,@body))
-> (let ((m2-body (M2 body)))
     (list `( (do-while ,exp ,@(first m2-body)) )
	   `( (do-while ,exp ,@(second m2-body)) )))

;goto, continue, break
(Mb (goto ,id))
(Mb (continue))
(Mb (break))
-> (list (list x) (list x))

;return
(Mb (return ,@exp))
-> (let ((caller-resume
	  '((= (fref cp -> c) c-p)
	    (= (fref cp -> stat) thr-runnable))))
     (if (null exp)
	 (list `(,@caller-resume (return))
	       '((return)))
       (let ((return-exp (car (first (Me (car exp))))))
	 (list `((= (mref (cast (ptr ,(finfo-rettype *current-func*))
				(c_p cp rsn_retval)))
		    ,return-exp)
		 ,@caller-resume
		 (return))
	       `((return ,return-exp))))))
     
;;; <--- マルチスレッド用プリミティブ

(Mb (thread-create (,@decl-list) ,@body))
->(let* ((thrc-decl (mapcar #'Mtcreate-decl decl-list))
	 (ln (1+ (length (finfo-label *current-func*))))
	 (label-l (generate-id (string+ "L" (write-to-string ln))
			       *used-identifier*))
	 (nfunc-id (make-nestfunc-id *nthr-id*)))
    (push (list label-l nil)
	  (finfo-label *current-func*))
     (let* ((prev-tcreate 
	     `(begin 
	       (= ln ,ln)
	       (= (fref thst_top -> c) ,(finfo-nfunc-id *current-func*))
	       (= (fref thst_top -> stat) thr_new_runnable)
	       (inc thst_top)))
	    (post-tcreate 
	     `(if (!= (fref (- thst_top 1) -> stat) thr_new_runnable)
		  (scheduling)
		(dec thst_top)))
	    (rettype (finfo-rettype *current-func*))
	    (*current-func* (make-finfo
			     :id nil
			     :rettype rettype
			     :nfunc-id nfunc-id)))
       (push '(def ln int 0) (finfo-decl *current-func*))
       (let* ((m2-body (M2 body))
	      (tcre-body `(,@thrc-decl
			   ,@(finfo-decl *current-func*)
			   ,(make-nestfunc (first m2-body))
			   ,@(second m2-body))))
	 (list `(,prev-tcreate
		 (begin ,@tcre-body)
		 ,post-tcreate
		 (label ,label-l nil))
	       `(,prev-tcreate
		 (begin ,@tcre-body)
		 ,post-tcreate)))))
    
;; thread-createの最初の宣言用
(Mtcreate-decl (,id[ID] ,texp ,@init))
->(Mtcreate-decl (cons 'def x))
(Mtcreate-decl (,scs[SCS] ,id[ID] ,texp ,@init))
-> x

#| この処理はやるとしたらtmp.ruleでやるべきこと
(if (null init)	
    (list nil `(,scs ,id ,texp ,@init))
  (let* ((n (incf n))		
	 (var-v (get-id-from-string (string+ "v" (write-to-string n)))))
    (unless (member var-v *used-identifier* :test #'string=)
      (progn (push var-v *used-identifier*)
	(setq *var* (cons `(def ,var-v ,texp) *var*))))
    (list `((=  (the ,texp ,var-v) ,@init))
	  `(,scs ,id ,texp ,var-v ))))
|#

(Mb (thread-suspend ,id[ID] ,@body))
->(let* ((ln (1+ (length (finfo-label *current-func*))))
	 (nfunc-id (finfo-nfunc-id *current-func*))
	 (m2-body (M2 body))
	 (label-l (generate-id (string+ "L" (write-to-string ln))
			       *used-identifier*)))
    ;; (print var-c)(print `ccc)  
    (push (list label-l nil) (finfo-label *current-func*))
    #| (setf (finfo-id *current-func*) thr_s) |#
    (push `(def ,id thst-ptr) (finfo-decl *current-func*))
    (list `((begin 
	     (= ,id cp)
	     (= (fref ,id -> c) ,nfunc-id)
	     (= (fref ,id -> stat) thr_suspended)
	     ,@(first m2-body)
	     (= ln ,ln)
	     (return))
	    (label ,label-l nil))      
	  `((begin 
	     (= ,id (inc thst_top))
	     (= (fref ,id -> c) ,nfunc-id)
	     (= (fref ,id -> stat) thr_new_suspended)
	     ,@(second m2-body)
	     (= ln ,ln)
	     (scheduling)))))

(Mb (thread-resume ,exp))
-> (list `((thr_resume ,exp))
	 `((thr_resume ,exp)))

;;; マルチスレッド用プリミティブ --->

; null statement
(Mb nil)
-> (list nil nil)

;expression-statement or declaration
(Mb ,otherwise)
-> (let ((me-x (Me x)))
     (if (eq '$not-expression me-x)
	 (M1 x)
       me-x))

;;;;;;;;;;;
;;; exp
; tmp.ruleの変換結果により、callは
; (the void (call (the ,texp ,exp) ,@exp-list))
; か、
; (the ,texp (= (the ,texp ,id) (the ,texp (call (the ,texp ,exp) ,@exp-list)))
; のどちらかの形で現れるようになっている。

; 通常のfunction-call
; ・引数の値を保存
; ・呼び出す関数のポインタも保存
(Me         (the ,texp (call (the (fn ,fexp1 ,@fexp) ,exp-f) ,@arg-list)))
(Me (the ,texp0
	 (= (the ,texp1 ,id)
	    (the ,texp (call (the (fn ,fexp1 ,@fexp) ,exp-f) ,@arg-list)))))
->(let* ((assign-p (pattern-variable-p 'id))
	 (nfunc-id (finfo-nfunc-id *current-func*))
	 (ln (1+ (length (finfo-label *current-func*))))	 
	 (label-l (generate-id (string+ "L" (write-to-string ln))
			       *used-identifier*))
	 (renew-ln `(= ln ,ln))
	 (label-stat `(label ,label-l nil))
	 (tmp-id (if assign-p id nil))
	 ;; 第1引数に入れ子関数へのポインタを追加
	 (call-exp `(,exp-f ,nfunc-id ,@arg-list))
	 (new-exp (if assign-p `(= ,id ,call-exp) call-exp)))
    (push (list label-l tmp-id)
	  (finfo-label *current-func*))
    (list `(,renew-ln ,new-exp ,label-stat)
	  `(,renew-ln ,new-exp )))
#|
;; 関数の返り値を代入している場合，
;; 関数呼び出し部分にMeを適用し，その結果に手を加える
(Me (the ,texp0
	 (= (the ,texp1 ,id)
	    (the ,texp (call (the (fn ,fex1p ,@fexp) ,exp-f) ,@arg-list)))))
-> (let* ((f-me-exp2 (first (Me (third (third x)))))
	  (renew-ln (first f-me-exp2))
	  (new-call-exp `(= ,id ,(second f-me-exp2)))
	  (label-stat (third f-me-exp2)))
     (setf (second (first (finfo-label *current-func*)))
	   id)
     (list `(,renew-ln ,new-call-exp ,label-stat)
	   `(,renew-ln ,new-call-exp)))
|#

(Me (the ,@rem))
-> (list (list x) (list x))

(Me (c-exp ,@rem))
-> (list (list x) (list x))

(Me ,otherwise)
-> '$not-expression


