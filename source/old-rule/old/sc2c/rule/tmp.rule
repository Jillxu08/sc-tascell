;;;temporary variableを使って、関数呼び出しが部分式にならない。
;;;無駄な変数削除してない。

(Tmp0 (,@decl-list))
->(progn
    (defvar *used-identifier* nil) 
    (defvar *prev-continue* nil)

    ;((a b c)(x y z)(m n p)...)->((a x m)(b y n)(c z p)) 
    (defun comb-list (list)
      (let ((y1 nil)(y2 nil)(y3 nil))
	(dolist (x list (list y1 y2 y3))
	  (setq y1 (append y1 (first x))
		y2 (append y2 (second x))
		y3 `(,@y3 ,(third x)))))) 
    
;;;
    (let ((*used-identifier* (get-all-identifier x))
	  (*prev-continue* nil))
      (mapcar #'Tmp1 x)))

;;;;

(Tmp1 (,scs[SCS] (,@id-list[ID]) (fn ,@texp-list) ,@body))
(Tmp1 (,scs[SCS] (,@id-list[ID]) (lightweight ,@texp-list) ,@body))
-> (let* ((fntag (car (third x)))
	  (tmpbody (Tmp2 body))
	  (newdecl (first tmpbody))
	  (newbody (second tmpbody)))
     `(,scs (,@id-list) (,fntag ,@texp-list) ,@newdecl ,@newbody ))

(Tmp1 ,otherwise)
-> otherwise

(Tmp1 nil)
-> nil

;;;;

; function-attribute & register-decl
(Tmp2 (:attr ,atr ,@body))
-> (let ((tmp2-body (Tmp2 body)))
     (list (first tmp2-body)
	   `(:attr ,atr (second tmp2-body)))) 

(Tmp2 ((register ,@regarg) ,@body))
-> (let ((tmp2-body (Tmp2 body)))
     (list (first tmp2-body)
	   `((register ,@regarg) (second tmp2-body))))

(Tmp2 (,@item-list))
-> (let* ((tmp-item-list (mapcar #'Tmp item-list))
	  (decl-list (apply #'append (mapcar #'first tmp-item-list)))
	  (prev-stat (apply #'append 
                     (mapcar #'(lambda (x) `(,@(second x) ,(third x)))
                             tmp-item-list))))
	 ; (append decl-list prev-stat))
     `(,decl-list  ,prev-stat))


;;;;

; begin
(Tmp (begin ,@body))
->(let ((tmpbody (Tmp2 body)))
    `(,(first tmpbody) nil (begin ,@(second tmpbody))))

; label
(Tmp (label ,id[ID] ,stat))
->(let ((tmpstat (Tmp stat)))
    `(,(first tmpstat) 
      ,(second tmpstat) 
      (label ,id ,(third tmpstat))))

; case
(Tmp (case ,exp))
->(let ((tmpexp (Tmpe exp)))
    `(,(first tmpexp) ,(second tmpexp) (case ,(third tmpexp))))

; default
(Tmp (default))
-> `(nil nil ,x) 

; if 
(Tmp (if ,exp ,stat1 ,@stat2))
-> (if (null stat2)
       (let* ((tmpexp (Tmpe exp))
	      (tmpstat1 (Tmp stat1))
	      (defexp (append (first tmpexp)(first tmpstat1)))) 
	 (if (null (second tmpstat1))
	     `( ,defexp ,(second tmpexp) (if ,(third tmpexp) ,(third tmpstat1)))
	     `( ,defexp ,(second tmpexp) (if ,(third tmpexp) (begin ,@(second tmpstat1)  ,(third tmpstat1))))))
       (let* ((tmpexp (Tmpe exp))
	      (tmpstat1 (Tmp stat1))
	      (tmpstat2 (Tmp (car stat2)))
	      (defexp (append (first tmpexp)(first tmpstat1)(first tmpstat2))))
	 `(,defexp 
	   ,(second tmpexp) 
	   (if ,(third tmpexp)
	       (begin ,@(second tmpstat1) ,(third tmpstat1))
	       (begin ,@(second tmpstat2) ,(third tmpstat2))))))

; switch
(Tmp (switch ,exp ,@body))
-> (let ((tmpexp (Tmpe exp))
	 (tmpbody (Tmp2 body)))
     `(,(append (first tmpexp) (first tmpbody))
       ,(second tmpexp) (switch ,(third tmpexp) ,@(second tmpbody))))

; do-while
(Tmp (do-while ,exp ,@body))
->(let* ((tmpexp (Tmpe exp))
	 (*prev-continue* (second tmpexp))
	 (tmpbody (Tmp2 body)))
    `(,(append (first tmpexp) (first tmpbody)) 
      nil
      (do-while ,(third tmpexp) ,@(second tmpbody) ,@*prev-continue*)))

; continue
(Tmp (continue))
-> `(nil ,*prev-continue* ,x)

; goto, break 
(Tmp (goto ,id))
(Tmp (break))
->  `(nil nil ,x)

; return
(Tmp (return ,@exp))
-> (if (null exp)
       `(nil nil (return))
	(let ((tmpexp (Tmpe (car exp))))
	  `(,(first tmpexp) ,(second tmpexp) (return ,(third tmpexp)))))

;;; <- マルチスレッド用プリミティブ

(Tmp (thread-create ,decl-list ,@body))
-> (let* ((tmpbody (Tmp2 body))
          (add-decl (first tmpbody))
          (newbody (second tmpbody)))
    (list nil nil `(thread-create ,(append decl-list add-decl) ,@newbody)))

(Tmp (thread-suspend ,var ,@body))
-> `(nil nil (thread-suspend ,var ,@body)))

(Tmp (thread-resume ,exp))
->(let ((tmpexp (Tmpe exp)))
   `(,(first tmpexp) ,(second tmpexp) (thread-resume ,(third tmpexp))))

;;; マルチスレッド用プリミティブ

(Tmp nil)
-> (list nil nil nil)

; expression-statement or declaration
(Tmp ,otherwise)
->(let ((exps (Tmpe x)))
    (if (eq '$NOT-EXPRESSION exps)
	(list (list (Tmp1 x)) nil)
	exps))

;;;;;;	 

; exp
(Tmpe (the ,texp ,exp[ID]))
(Tmpe (the ,texp ,exp[integerp]))
(Tmpe (the ,texp ,exp[characterp]))
(Tmpe (the ,texp ,exp[numberp]))
(Tmpe (the ,texp ,exp[stringp]))
-> `(nil nil (the ,texp ,exp))

; aref
(Tmpe (the ,texp1 (aref ,exp1 ,exp2)))
->(let* ((tmpexp1 (Tmpe exp1))
	 (tmpexp2 (Tmpe exp2)))
    `(,(append (first tmpexp1) (first tmpexp2))
      ,(append (second tmpexp2) (second tmpexp2))
      (the ,texp1 (aref ,(third tmpexp1) ,(third tmpexp2)))))

; fref
(Tmpe (the ,texp (fref ,exp ,id)))
->(let* ((tmpexp (Tmpe exp))
	 (defexp (append (first tmpexp)))
	 (bindinfo (append (second tmpexp))))
     `(,defexp ,bindinfo (the ,texp (fref ,(third tmpexp) ,id))))

; inc, dec, ++, --, unary-operator, bit-not
(Tmpe (the ,texp (inc ,exp)))
(Tmpe (the ,texp (dec ,exp)))
(Tmpe (the ,texp (++ ,exp)))
(Tmpe (the ,texp (-- ,exp)))
(Tmpe (the ,texp (bit-not ,exp)))
(Tmpe (the ,texp (/ ,exp)))
(Tmpe (the ,texp (+ ,exp)))
(Tmpe (the ,texp (- ,exp)))
->(let* ((op (caaddr x))
	 (tmpexp (Tmpe exp))
	 (bindinfo (append (second tmpexp)))
	 (defexp (append (first tmpexp))))
    `(,defexp ,bindinfo (the ,texp (,op ,(third tmpexp)))))

; ptr
(Tmpe (the ,texp (ptr ,exp)))
-> (let* ((tmpexp (Tmpe exp))
    	  (defexp (first tmpexp))
	  (bindinfo (second tmpexp)))
     `(,defexp ,bindinfo (the ,texp (ptr ,(third tmpexp)))))

; mref
(Tmpe (the ,texp (mref ,exp)))
->(let* ((tmpexp (Tmpe exp))
	 (defexp (append (first tmpexp)))
	 (bindinfo (append (second tmpexp))))
   `(,defexp ,bindinfo (the ,texp (mref ,(third tmpexp)))))

; sizeof???
(Tmpe (the ,texp (sizeof ,exp[EXPR])))
->(let* ((tmpexp (Tmpe exp)) 
	 (defexp (append (first tmpexp) nil))
	 (bindinfo (append (second tmpexp) nil)))
    `(,defexp ,bindinfo (the ,texp (sizeof ,(third tmpexp)))))

(Tmpe (the ,texp (sizeof ,texp)))
-> `(nil nil (the ,texp (sizeof ,texp)))

; cast
(Tmpe (the ,texp1 (cast ,texp2 ,exp)))
->(let* ((tmpexp (Tmpe exp))
 	 (defexp (append (first tmpexp) nil))
	 (bindinfo (append (second tmpexp) nil)))
   `(,defexp ,bindinfo (the ,texp1 (cast ,texp2 ,(third tmpexp)))))

; if-exp 
(Tmpe (the ,texp (if-exp ,exp1 ,exp2 ,exp3)))
-> (let* ((tmpexp1 (Tmpe exp1))
	  (tmpexp2 (Tmpe exp2))
	  (tmpexp3 (Tmpe exp3))
	  (defexp (append (first tmpexp1) (first tmpexp2) (first tmpexp3)))
	  (bindinfo (append (second tmpexp1)))
	  (result-id (generate-id "ifexp_result" *used-identifier*))
	  (texp2 (second tmpexp2))
	  (texp3 (second tmpexp3)))
     (if (not (or (first tmpexp2)
		  (first tmpexp3)
		  (second tmpexp2)
		  (second tmpexp3)))
	 `(,defexp
	   ,bindinfo
	   (the ,texp (if-exp ,(third tmpexp1) ,exp2 ,exp3)))
       `((,@defexp (def ,result-id ,texp)) 
	 (,@bindinfo 
	  (if ,(third tmpexp1) 
	      (begin
	       ,@(second tmpexp2)
	       (the ,texp2 (= (the ,texp ,result-id) ,(third tmpexp2))))
	    (begin
	     ,@(second tmpexp3)
	     (the ,texp3 (= (the ,texp ,result-id) ,(third tmpexp3))))))
	 (the ,texp ,result-id))))

; and 
(Tmpe (the ,texp (and ,exp1 ,exp2)))
-> (Tmpe `(the ,texp (if-exp ,exp1
		      (the int (if-exp ,exp2 (the int 1) (the int 0)))
		      (the int 0))))

; or
(Tmpe (the ,texp (or ,exp1 ,exp2)))
-> (Tmpe `(the ,texp (if-exp ,exp1
		      (the int 1)
		      (the int (if-exp ,exp2 (the int 1) (the int 0))))))

; call 
(Tmpe (the ,texp (call ,fexp ,@arg-list)))
-> (case texp
     ((void)
      (let* ((tmpexps (comb-list (mapcar #'Tmpe arg-list))) 
	     (defexp (append (first tmpexps)))
	     (bindinfo (append (second tmpexps)))
	     (ret-third `(the ,texp (call ,fexp ,@(third tmpexps)))))
	`( ,defexp ,bindinfo ,ret-third )))
     (otherwise
      (let* ((tmpexps (comb-list (mapcar #'Tmpe arg-list))) 
	     (tempid (generate-id "tmp" *used-identifier*))
	     (defexp1 `(def ,tempid ,texp))
	     (defexp (append (first tmpexps) `(,defexp1)))
	     (bindinfo1 `(the ,texp (= (the ,texp ,tempid) (the ,texp (call ,fexp ,@(third tmpexps))))))
	     (bindinfo (append (second tmpexps) `(,bindinfo1))))
	`( ,defexp ,bindinfo (the ,texp ,tempid) ))))

; operators
(Tmpe (the ,texp (* ,exp1 ,exp2)))
(Tmpe (the ,texp (/ ,exp1 ,exp2)))
(Tmpe (the ,texp (% ,exp1 ,exp2)))
(Tmpe (the ,texp (+ ,exp1 ,exp2)))
(Tmpe (the ,texp (- ,exp1 ,exp2)))
(Tmpe (the ,texp (bit-xor ,exp1 ,exp2)))
(Tmpe (the ,texp (bit-and ,exp1 ,exp2)))
(Tmpe (the ,texp (bit-or ,exp1 ,exp2)))
(Tmpe (the ,texp (<< ,exp1 ,exp2)))
(Tmpe (the ,texp (>> ,exp1 ,exp2)))
(Tmpe (the ,texp (<<= ,exp1 ,exp2)))
(Tmpe (the ,texp (>>= ,exp1 ,exp2)))
(Tmpe (the ,texp (bit-and= ,exp1 ,exp2)))
(Tmpe (the ,texp (bit-xor= ,exp1 ,exp2)))
(Tmpe (the ,texp (bit-or= ,exp1 ,exp2)))
(Tmpe (the ,texp (< ,exp1 ,exp2)))
(Tmpe (the ,texp (> ,exp1 ,exp2)))
(Tmpe (the ,texp (<= ,exp1 ,exp2)))
(Tmpe (the ,texp (>= ,exp1 ,exp2)))
(Tmpe (the ,texp (== ,exp1 ,exp2)))
(Tmpe (the ,texp (!= ,exp1 ,exp2)))
(Tmpe (the ,texp (= ,exp1 ,exp2)))
(Tmpe (the ,texp (*= ,exp1 ,exp2)))
(Tmpe (the ,texp (/= ,exp1 ,exp2)))
(Tmpe (the ,texp (&= ,exp1 ,exp2)))
(Tmpe (the ,texp (+= ,exp1 ,exp2)))
(Tmpe (the ,texp (-= ,exp1 ,exp2)))
-> (let ((op (caaddr x))
	 (tmpe-exp1 (Tmpe exp1))
	 (tmpe-exp2 (Tmpe exp2)))
     `(,(append (first tmpe-exp1) (first tmpe-exp2))
       ,(append (second tmpe-exp1) (second tmpe-exp2))
       (the ,texp (,op ,(third tmpe-exp1) ,(third tmpe-exp2)))))

; exps
(Tmpe (the ,texps (exps ,@exp-list)))
-> (let* ((tmpe-exps (mapcar #'Tmpe exp-list))
	  (butlast-tmpe-exps (butlast tmpe-exps))
	  (clast-tmpe-exps (car (last tmpe-exps))))
     `(,(apply #'append (mapcar #'first tmpe-exps))
       ,(append (apply #'append 
		       (mapcar #'(lambda (x) `(,@(second x) ,(third x)))
			       butlast-tmpe-exps))
		(second clast-tmpe-exps))
       ,(third clast-tmpe-exps)))

; c-exp
(Tmpe (c-exp ,str ,@exp-list))
-> (let* ((tmpe-exps (mapcar #'Tmpe exp-list)))
     (list
      (apply #'append (mapcar #'first tmpe-exps))
      (apply #'append (mapcar #'second tmpe-exps))
      `(c-exp ,str ,@(mapcar #'third tmpe-exps))))
 
(Tmpe ,otherwise)
-> '$NOT-EXPRESSION

 