;;;; sc0 => sc0
;;;; 関数内の全ての識別子名が異なるように名前を変換
(%require "RENAME-DEFS")

(Ren0 (,@declaration-list) )
-> (progn
     (let ((*id-alist* *id-alist*)
	   (*replace-alist* *replace-alist*)
	   (*used-id-list* (get-all-identifier declaration-list))
	   (*block-id* 0)
	   (*next-block-id* 0))	      
       (Ren1 declaration-list)))

;;;;;; declaration ;;;;;;
;variable (length of init is probably 1)
(Ren1 ((,scs[SCS] ,id[ID] ,texp ,@init)
       ,@decl-list) )
-> (bind-alists id id-repl
     (cons `(,scs ,id-repl ,texp ,@(repl-id init))
	   (Ren1 decl-list)))

;function
(Ren1 ((,scs[SCS] (,@id-list[ID]) (fn ,@texp-list) ,@body)
       ,@decl-list) )
(Ren1 ((,scs[SCS] (,@id-list[ID]) (lightweight ,@texp-list) ,@body)
       ,@decl-list) )
-> (bind-alists (car id-list) fname-repl
     (let ((fntag (car (third (car x))))
	   (body-repl nil)
	   (arg-list-repl nil))
       (begin-function
         (bind-alists (cdr id-list) arg-list-repl-temp
	   (setq body-repl (Renb body)
		 arg-list-repl arg-list-repl-temp)))
       (cons `(,scs (,fname-repl ,@arg-list-repl) (,fntag ,@texp-list)
	       ,@body-repl)
	     (Ren1 decl-list))))

;struct, union
(Ren1 ((,dd[DEF-DECL] (,soru[S-OR-U] ,id[ID]) ,@sdeclist)
       ,@decl-list) )
-> (bind-alists id id-repl
     (cons `(,dd (,soru ,id-repl) ,@sdeclist)
	   (Ren1 decl-list)))

;enum
(Ren1 ((def (enum ,id[ID]) ,@enum-list)
       ,@decl-list))
-> (let ((eid-list (mapcar #'(lambda (en) (if (listp en) (car en) en))
			   (cons id enum-list))))
     (bind-alists eid-list eid-list-repl
       (let ((enum-list-repl
	      (mapcar #'(lambda (en-eid)
			  (if (listp (car en-eid))
			      `(,(cdr en-eid) ,(cadar en-eid))
			      (cdr en-eid)))
		      (cmpd-list enum-list (cdr eid-list-repl)))
	       ))
	 (cons `(def (enum ,(car eid-list-repl)) ,@enum-list-repl)
	       (Ren1 decl-list)))))

;deftype (struct)
(Ren1 ((deftype ,id[ID] struct ,@sdecllist)
       ,@decl-list) )
-> (bind-alists id id-repl
     (cons `(deftype ,id-repl struct ,@sdecllist)
	   (Ren1 decl-list)))

;deftype (enum)
(Ren1 ((deftype ,id[ID] enum ,@enum-list)
       ,@decl-list) )
-> (let ((eid-list (mapcar #'(lambda (en) (if (listp en) (car en) en))
			   (cons id enum-list))))
     (bind-alists eid-list eid-list-repl
       (let ((enum-list-repl
	      (mapcar #'(lambda (en-eid)
			  (if (listp (car en-eid))
			      `(,(cdr en-eid) ,(cadar en-eid))
			      (cdr en-eid)))
		      (cmpd-list enum-list (cdr eid-list-repl)))
	       ))
	 (cons `(deftype ,(car eid-list-repl) enum ,@enum-list-repl)
	       (Ren1 decl-list)))))

;deftype
(Ren1 ((deftype ,id[ID] ,texp)
       ,@decl-list) )
-> (bind-alists id id-repl
     (cons `(deftype ,id-repl ,texp)   (Ren1 decl-list)))

;c-exp
(Ren1 ((c-exp ,@rem) ,@decl-list))
-> (cons `(c-exp ,@rem)   (Ren1 decl-list))

(Ren1 nil)
-> nil

; $body:ブロック内の宣言後のタグ
(Ren1 ( $body   ,@rem-body ))
-> (Renb rem-body)

(Ren1 ,otherwise)
-> (error "syntax error in ~s." (car otherwise))

;;;;;;; body +α ;;;;;;
; function-attribute & register-decl
(Renb (:attr ,atr   ,@body) )
-> `(:attr ,atr ,@(Renb body))
(Renb ((register ,@regarg)   ,@body) )
-> `((register ,@(repl-id regarg)) ,@(Renb body))

;begin
(Renb ((begin ,@body)
       ,@remain-body ) )
-> (cons `(begin ,@(inc-block-level (Renb body)))
	 (Renb remain-body))

;label
(Renb ((label ,id ,stat)
       ,@remain-body) )
-> (cons `(label ,id ,@(Renb (list stat))) (Renb remain-body))

;case
(Renb ((case ,exp)
       ,@remain-body))
-> (cons `(case ,(repl-id exp)) (Renb remain-body))

;default
(Renb ((default)
       ,@remain-body) )
-> (cons '(default) (Renb remain-body)) 

;if
(Renb ((if ,exp ,stat1 ,@stat2)
       ,@remain-body) )
-> (cons (if (null stat2)
             `(if ,(repl-id exp) ,@(Renb (list stat1)))
             `(if ,(repl-id exp) ,@(Renb (list stat1)) ,@(Renb stat2)))
         (Renb remain-body))

;switch
(Renb ((switch ,exp ,@body)
       ,@remain-body))
-> (cons `(switch ,(repl-id exp) ,@(inc-block-level (Renb body)))
         (Renb remain-body))

;do-while
(Renb ((do-while ,exp ,@body)
       ,@remain-body) )
-> (cons `(do-while ,(repl-id exp) ,@(inc-block-level (Renb body)))
         (Renb remain-body))

;goto, continue, break
(Renb ((goto ,id)   ,@remain-body) )
(Renb ((continue)   ,@remain-body) )
(Renb ((break)      ,@remain-body) )
-> (cons (car x) (Renb remain-body))

;return
(Renb ((return ,@exp)
       ,@remain-body) )
-> (cons (if (null exp)
             '(return)
	   `(return ,(repl-id (car exp))))
         (Renb remain-body))


;;; <- マルチスレッド用プリミティブ
(Renb ((thread-create ,decl-list ,@body)
       ,@remain-body))
-> (let* ((n-decls (length decl-list))
	  (renb-x (inc-block-level (Renb `(,@decl-list ,@body))))
	  (new-body (nthcdr n-decls renb-x))
	  (new-decl-list
	   (let ((new-dl nil))
	     (dotimes (i n-decls (nreverse new-dl))
	       (push (nth i renb-x) new-dl)))))
     (cons `(thread-create ,new-decl-list ,@new-body)
	   (Renb remain-body)))
 


(Renb ((thread-suspend ,id[ID] ,@body)
       ,@remain-body))
-> (cons `(thread-suspend
	   ,id
	   ,@(cdr (inc-block-level
		   (Renb (cons `(def ,id thst-ptr) body)))))
	 (Renb remain-body))

(Renb ((thread-resume ,exp)
       ,@remain-body))
-> (cons `(thread-resume ,(repl-id exp))
	 (Renb remain-body))

;;; マルチスレッド用プリミティブ ->

; null-statement
(Renb (,null-stat[NULL]
       ,@remain-body) )
-> (cons nil (Renb remain-body))

; c-expression
(Renb ((c-exp ,str ,@exp-list)   ,@remain-body))
-> (cons `(c-exp ,str ,@(mapcar #'repl-id exp-list))
	 (Renb remain-body))

; expression-statement or declaration
(Renb (,otherwise
       ,@remain-body) )
-> (if (par-expression otherwise)
       (cons (repl-id otherwise)   (Renb remain-body))
       (Ren1 `(,otherwise $body ,@remain-body)))  ;Renbに戻れるようにタグを付ける

(Renb nil)
-> nil
