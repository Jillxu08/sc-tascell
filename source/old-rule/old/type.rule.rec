;;;; sc0 => sc0-with-type-information (the <type> <expression>)

;;; 全てのexpressionを(the <type-expression> <expression>)
;;; の形にする。
;;; 関数呼び出し式の先頭に'call'を付ける。

;;; マルチスレッド用プリミティブに対応(2003/12/26)
;;; lightweight入れ子関数に対応(2003/12/28)
;;; typedef-name を全て元の名前に置き換えるよう変更(2004/1/5)
;;; 関数、関数ポインタに関する処理を修正(2004/1/7)
(%require "TYPE-DEFS")
(%initial-rule Tp0)

(Tp0 (,@declaration-list) )
-> (progn
     (defvar *str-alist* nil)
     (defvar *var-alist* nil)
     (defvar *last-var-alist* nil)

     (let ((*keyword-list* (cons 'lightweight *keyword-list*))
	     ; ...誰がやるべきか?
	   (*str-alist* *str-alist*)
	   (*var-alist* *var-alist*)
	   (*last-var-alist* *last-var-alist*))
       (Tp1 declaration-list)))

;;; *str-alist* : list of ( <strname> . ( [(<fid> . <type>)]* ) )
;;; *var-alist* : list of ( <name> . <type> )
;;; deftype -> ( name . ($type <type>) ) in *var-alist*
;;; enum and struct without name -> $<typedef-name> 
;;; (struct $str) (enum $en) etc.

;;;;;; declaration ;;;;;;
;variable (length of init is probably 1)
(Tp1 ((,scs[SCS] ,id[ID] ,texp ,@init)   ,@decl-list) )
-> (let ((*var-alist* (cons `(,id . ,(remove-type-qualifier texp))
			    *var-alist*)))
     (cons `(,scs ,id ,texp ,@(mapcar #'Tpi init)) (Tp1 decl-list)))
   ;initializer
   (Tpi (array ,@init))
   (Tpi (struct ,@init))
   -> `(,(car x) ,@(mapcar #'Tpi init))
   (Tpi ,exp)
   -> (Tpe exp)

;function
(Tp1 ((,scs[SCS] (,@id-list[ID]) (fn ,@texp-list) ,@body)   ,@decl-list) )
(Tp1 ((,scs[SCS] (,@id-list[ID]) (lightweight ,@texp-list) ,@body)   ,@decl-list) ) ;lw
-> (let* ((fn-tag (car (third (car x))))
	  (texp-list2 (mapcar #'remove-type-qualifier texp-list))
	  (*var-alist* (cons `(,(first id-list) . (ptr (,fn-tag ,@texp-list2)))
			     *var-alist*))
	  (new-body nil))
     (let ((bind-list (cmpd-list (cdr id-list) (cdr texp-list2))))
       (setq new-body
	     (let ((*var-alist* (append bind-list *var-alist*)))
	       (Tpb body))))
     (cons `(,scs (,@id-list) (,fn-tag ,@texp-list) ,@new-body)
	   (Tp1 decl-list)))

;struct, union
(Tp1 ((,dd[DEF-DECL] (,soru[S-OR-U] ,id[ID]) ,@sdeclist)   ,@decl-list) )
-> (let ((sdecl-with-type nil) (member-list nil))
     (let ((*var-alist* nil))
       (setq sdecl-with-type (Tp1 sdeclist)
	     member-list *last-var-alist*))
     (let ((*str-alist* (cons (cons id member-list) *str-alist*)))
       (cons `(,dd (,soru ,id) ,@sdecl-with-type)
	     (Tp1 decl-list))))

; :bit( for struct-declaration )
(Tp1 (:bit ,bit  ,@decl-list) )
-> `( :bit ,bit ,@(Tp1 decl-list) )      

;enum
(Tp1 ((def (enum ,id[ID]) ,@enum-list)   ,@decl-list))
-> (let ((vadd-list nil))
     (dolist (en enum-list)
       (when (consp en) (setq en (car en)))
       (push (cons en `(enum ,id)) vadd-list))
     (let ((*var-alist* (append vadd-list *var-alist*)))
       (cons `(def (enum ,id) ,@enum-list) (Tp1 decl-list))))

;deftype (struct)
(Tp1 ((deftype ,id[ID] struct ,@sdecllist)   ,@decl-list) )
-> (let ((sdecl-with-type nil) (member-list nil))
    (let ((*var-alist* nil))
      (setq sdecl-with-type (Tp1 sdeclist)
	    member-list *var-alist*))
    (let ((*str-alist* (cons (cons (cat-symbol '$ id) member-list)
			     *str-alist*))
	  (*var-alist* (cons (cons id 
				   `($type (struct ,(cat-symbol '$ id))))
			     *var-alist*)))
      (cons `(deftype ,id struct ,@sdecl-with-type)
	    (Tp1 decl-list))))

;deftype (enum)
(Tp1 ((deftype ,id[ID] enum ,@enum-list)   ,@decl-list) )
-> (let ((vadd-list nil))
     (dolist (en enum-list)
       (when (consp en) (setq en (car en)))
       (push `(,en . ,id) vadd-list))
     (push `(,id . ($type (enum ,(cat-symbol '$ id)))) vadd-list)
     (let ((*var-alist* (append vadd-list *var-alist*)))
       (cons `(deftype ,id enum ,@enum-list) (Tp1 decl-list))))

;deftype
(Tp1 ((deftype ,id[ID] ,texp)   ,@decl-list) )
-> (let ((*var-alist* (cons (cons id `($type ,(remove-type-qualifier texp))) 
			    *var-alist*)))
     (cons `(deftype ,id ,texp) (Tp1 decl-list)))

;c-exp
(Tp1 ((c-exp ,@rem)   ,@decl-list))
-> (cons (car x) (Tp1 decl-list))

(Tp1 nil)
-> (progn
     (setq *last-var-alist* *var-alist*)
     nil)

; $body:ブロック内の宣言後のタグ
(Tp1 ( $body   ,@rem-body ))
-> (Tpb rem-body)

(Tp1 ,otherwise)
-> (error "syntax error in ~s." (car otherwise))

;;;;;;; body +α ;;;;;;
; function-attribute & register-decl
(Tpb (:attr ,atr   ,@body) )
-> `(:attr ,atr ,@(Tpb body))
(Tpb ((register ,@regarg)   ,@body) )
-> `((register ,@regarg) ,@(Tpb body))

;begin
(Tpb ((begin ,@body)   ,@remain-body ) )
-> (cons `(begin ,@(Tpb body)) (Tpb remain-body))

;label
(Tpb ((label ,id ,stat)   ,@remain-body) )
-> (cons `(label ,id ,@(Tpb (list stat))) (Tpb remain-body))

;case
(Tpb ((case ,exp)   ,@remain-body))
-> (cons `(case ,(Tpe exp)) (Tpb remain-body))

;default
(Tpb ((default)   ,@remain-body) )
-> (cons '(default) (Tpb remain-body)) 

;if
(Tpb ((if ,exp ,stat1 ,@stat2)   ,@remain-body) )
-> (cons (if (null stat2)
             `(if ,(Tpe exp) ,@(Tpb (list stat1)))
             `(if ,(Tpe exp) ,@(Tpb (list stat1)) ,@(Tpb stat2)))
         (Tpb remain-body))

;switch
(Tpb ((switch ,exp ,@body)   ,@remain-body))
-> (cons `(switch ,(Tpe exp) ,@(Tpb body))
         (Tpb remain-body))

;do-while
(Tpb ((do-while ,exp ,@body)   ,@remain-body) )
-> (cons `(do-while ,(Tpe exp) ,@(Tpb body))
         (Tpb remain-body))

;goto, continue, break
(Tpb ((goto ,id)   ,@remain-body) )
(Tpb ((continue)   ,@remain-body) )
(Tpb ((break)      ,@remain-body) )
-> (cons (car x) (Tpb remain-body))

;return
(Tpb ((return ,@exp)   ,@remain-body) )
-> (cons (if (null exp)
             '(return)
	   `(return ,(Tpe (car exp))))
         (Tpb remain-body))

;;; <- マルチスレッド用プリミティブ
(Tpb ((thread-create ,decl-list ,@body)   ,@remain-body))
-> (let* ((n-decls (length decl-list))
	  (tpb-x (Tpb `(,@decl-list ,@body)))
	  (new-body (nthcdr n-decls tpb-x))
	  (new-decl-list (firstn tpb-x n-decls)))
     (cons `(thread-create ,new-decl-list ,@new-body)
	   (Tpb remain-body)))

(Tpb ((thread-suspend ,id[ID] ,@body)   ,@remain-body))
-> (let ((*var-alist* (cons (cons id 'thst-ptr) 
			    *var-alist*)))
     (cons `(thread-suspend ,id ,@(Tpb body))
	   (Tpb remain-body)))

(Tpb ((thread-resume ,exp)   ,@remain-body))
-> (cons `(thread-resume ,(Tpe exp))
	 (Tpb remain-body))
;;; マルチスレッド用プリミティブ ->

;expression-statement or declaration
(Tpb (,otherwise   ,@remain-body) )
-> (let ((expression-stat (Tpe otherwise)))
     (if (eq '$not-expression expression-stat)
	 (Tp1 `(,otherwise $body ,@remain-body))  ;Tpbに戻れるようにタグを付ける
       `(,expression-stat ,@(Tpb remain-body))))

(Tpb nil)
-> nil

;;;;;;; expression ;;;;;;;

; identifier
(Tpe ,id[ID])
-> `(the ,(assoc-vartype id) ,id)

; constant
(Tpe ,num[integerp])
-> `(the int ,num)
(Tpe ,cha[characterp])
-> `(the char ,cha)
(Tpe ,num[numberp])
-> `(the double ,num)

; string-literal
(Tpe ,str[stringp])
-> `(the (array char) ,str)

; aref
(Tpe (aref ,exp1 ,@rem-exp))
-> (cond
    ((cdr rem-exp)
     (Tpe `(aref (aref ,exp1 ,(car rem-exp)) ,@(cdr rem-exp))))
    ((null rem-exp)
     (Tpe exp1))
    (t
     (let* ((exp-with-type (Tpe exp1))
	    (exp-type (cadr exp-with-type)))
       (unless (and (listp exp-type)
		    (or (eq 'ptr (car exp-type))
			(eq 'array (car exp-type))))
	 (error "Can't apply aref to ~s." exp1))
       `(the ,(deref-type exp-type)
	 (aref ,exp-with-type ,(Tpe (car rem-exp)))))))

; fref
(Tpe (fref ,exp1 ,id1 ,@rem-id) )
-> (if rem-id
       (Tpe `(fref (fref ,exp1 ,id1) ,@rem-id))
     (let* ((exp1-with-type (Tpe exp1))
	    (exp1-type (cadr exp1-with-type)))
       (unless (and (listp exp1-type)
		    (or (eq 'struct (car exp1-type))
			(eq 'union  (car exp1-type))))
	 (error "~s is neither struct or union" exp1))
       (let* ((*var-alist* (assoc-struct (cadr exp1-type)))
	      (id1-with-type (Tpe id1)))
	 `(the ,(cadr id1-with-type) (fref ,exp1-with-type ,id1)))))

; inc, dec, ++, --, bit-not
(Tpe (inc ,exp))
(Tpe (dec ,exp))
(Tpe (++ ,exp))
(Tpe (-- ,exp))
(Tpe (bit-not ,exp))
-> (let ((exp-with-type (Tpe exp)))
      `(the ,(cadr exp-with-type) (,(car x) ,exp-with-type))) 

; ptr
(Tpe (ptr ,exp))
-> (let ((exp-with-type (Tpe exp)))
      `(the (ptr ,(cadr exp-with-type)) (ptr ,exp-with-type)))

; mref
(Tpe (mref ,exp))
-> (let* ((exp-with-type (Tpe exp))
	  (exp-type (cadr exp-with-type)))
     (unless (and (listp exp-type)
		  (or (eq 'ptr (car exp-type))
		      (eq 'array (car exp-type))))
       (error "Can't apply mref to ~s." exp))
     `(the ,(deref-type exp-type) (mref ,exp-with-type)))      

; not
(Tpe (not ,exp))
-> `(the int ,(Tpe exp))

; sizeof
(Tpe (sizeof ,id[ID]))
-> (let ((idtype (assoc-vartype id)))
     (break)
     `(the int 
       (sizeof ,(if (eq '$type (car idtype))
                    id
                    `(the ,idtype ,id)))))
(Tpe (sizeof ,exp[EXPR]) )
-> `(the int (sizeof ,(Tpe exp)))
(Tpe (sizeof ,texp))
-> `(the int (sizeof ,texp))
             
; cast
(Tpe (cast ,texp ,exp))
-> `(the ,texp (cast ,texp ,(Tpe exp)))

; operator(arithmetic)
(Tpe (* ,exp1 ,@rem-exp))
(Tpe (/ ,exp1 ,@rem-exp))
(Tpe (% ,exp1 ,@rem-exp))
(Tpe (+ ,exp1 ,@rem-exp)) ;unary-operatorの+, -もここで
(Tpe (- ,exp1 ,@rem-exp))
(Tpe (bit-xor ,exp1 ,@rem-exp))
(Tpe (bit-and ,exp1 ,@rem-exp))
(Tpe (bit-or  ,exp1 ,@rem-exp))
; operator(bit-shift)
(Tpe (<< ,exp1 ,@rem-exp))
(Tpe (>> ,exp1 ,@rem-exp))
; operator(logical)
(Tpe (and ,exp1 ,@rem-exp))
(Tpe (or  ,exp1 ,@rem-exp))
; comparator ( (length rem-exp) is expected to be 1)
(Tpe (<  ,exp1 ,@rem-exp))
(Tpe (>  ,exp1 ,@rem-exp))
(Tpe (<= ,exp1 ,@rem-exp))
(Tpe (>= ,exp1 ,@rem-exp))
(Tpe (== ,exp1 ,@rem-exp))
(Tpe (!= ,exp1 ,@rem-exp))
; assignment-operator ( (length rem-exp) is expected to be 1)
(Tpe (=  ,exp1 ,@rem-exp))
(Tpe (*= ,exp1 ,@rem-exp))
(Tpe (/= ,exp1 ,@rem-exp))
(Tpe (%= ,exp1 ,@rem-exp))
(Tpe (+= ,exp1 ,@rem-exp))
(Tpe (-= ,exp1 ,@rem-exp))
(Tpe (<<= ,exp1 ,@rem-exp))
(Tpe (>>= ,exp1 ,@rem-exp))
(Tpe (bit-and= ,exp1 ,@rem-exp))
(Tpe (bit-xor= ,exp1 ,@rem-exp))
(Tpe (bit-or=  ,exp1 ,@rem-exp))
; exps
(Tpe (exps ,exp1 ,@rem-exp))
-> (let ((op (car x)))
     (cond
      ((cdr rem-exp)
       (case op
	 ((< > <= >= == !=
	     = *= /= %= += -= <<= >>= bit-and= bit-xor= bit-or=)
	  (error "~s:too many arguments." x))
	 (otherwise
	  (Tpe `(,op (,op ,exp1 ,(car rem-exp)) ,@(cdr rem-exp))))))
      ((null rem-exp)
       (case op
	 ((< > <= >= == !=
	     = *= /= %= += -= <<= >>= bit-and= bit-xor= bit-or=)
	  (error "~s:too few arguments." x))
	 (otherwise
	  (let ((exp1-with-type (Tpe exp1)))
	    `(the ,(cadr exp1-with-type) (,op ,exp1-with-type))))))
      (t
       (let* ((exp2 (car rem-exp))
	      (exp-with-type1 (Tpe exp1))
	      (exp-with-type2 (Tpe exp2))
	      (exp-type1 (cadr exp-with-type1))
	      (exp-type2 (cadr exp-with-type2))
	      (whole-op
	       (case op
		 ((* / % + - bit-xor bit-and bit-or)
		  (type-conversion exp-type1 exp-type2))
		 ((<< >> = *= /= %= += -= <<= >>= 
		      bit-and= bit-xor= bit-or=)
		  (cadr exp-with-type1))
		 ((exps)
		  (cadr exp-with-type2))
		 ((and or < > <= >= == !=)
		  'int)
		 (otherwise (error "unexpected operator in Tpe.")))))
	 `(the ,whole-op (,op ,exp-with-type1 ,exp-with-type2))))))     

; if-exp
(Tpe (if-exp ,exp1 ,exp2 ,exp3))
-> (let* ((exp-with-type1 (Tpe exp1))
	  (exp-with-type2 (Tpe exp2))
	  (exp-with-type3 (Tpe exp3))
	  (exp-type2 (cadr exp-with-type2))
	  (exp-type3 (cadr exp-with-type3))
	  (whole-op (type-conversion exp-type2 exp-type3)))
     `(the ,whole-op (if-exp ,exp-with-type1
			     ,exp-with-type2
			     ,exp-with-type3)))

; c-exp
(Tpe (c-exp ,str ,@exp-list))
-> `(c-exp ,str ,@(mapcar #'Tpe exp-list))

; function-call
(Tpe (,fexp[EXPR] ,@arg-list))
-> (let* ((fexp-with-type (Tpe fexp))
	  (fexp-type (cadr fexp-with-type))
	  (type-fn nil))
     (unless (and (listp fexp-type)
		  (eq 'ptr (car fexp-type))
		  (listp (setq type-fn (cadr fexp-type)))
		  (or (eq 'fn (car type-fn))
		      (eq 'lightweight (car type-fn)))) ;lw
       (error "~s is not a function." fexp))
     `(the ,(cadr type-fn) (call (the ,type-fn ,(caddr fexp-with-type))
			    ,@(mapcar #'Tpe arg-list)))) 

(Tpe nil)
-> nil

(Tpe ,otherwise)
-> '$not-expression
