;;;temporary variableを使って、関数呼び出しが部分式にならない。
;;;無駄な変数削除してない。

(Tmp0 (,@decl-list))
->(progn
    (defvar *used-identifier* nil) 
    (setq n 1)
    (setq tmp-id 'tmp0)

  ; get temporary variable "tmp1"...
    (defun get-tmp-id (tmp-id)	
      (let ((ns)(nns))
	(setq nns (string+ `("tmp" ,(write-to-string n))))
	(setq ns (id-to-scid nns))
	(unless (member ns *used-identifier* :test #'string=)
	  (push-tmp-id ns))
	  (incf n)
	  (setq tmp-id nns))
      tmp-id)
     
   ; push variables such as "tmp1" to identifier list
    (defun push-tmp-id (id)
      (unless (member (par-identifier id) *used-identifier* :test #'string=)
	(push id *used-identifier*)))

   ; get 'tmp from string "tmp"
    (defun get-id-from-string (idstring)
      (let ((idx))
	(with-input-from-string (stream idstring)
	  (setq idx (read stream)))))	 

   ;((a b c)(x y z)(m n p)...)->((a x m)(b y n)(c z p)) 
    (defun comb-list (list)
      (let ((y1 nil)(y2 nil)(y3 nil))
	(dolist (x list y1)
	  (unless (null (first x))
	    (setq y1 (append (first x) y1))))
	(dolist (x list y2)
	  (unless (null (second x))
	    (setq y2 (append (second x) y2))))
	(dolist (x list y3)
	  (setq y3 (cons (third x) y3)))
	(list (reverse y1)(reverse y2)(reverse y3))))

    ;to del nil in `def or `(= tmp ())??
    (defun comb-def (x y)
      (let ((def nil))
	(if (null (first x))
	    (setq def y)
	    (setq def (append (first x) `(,y))))))
    
;;;
    (let ((*used-identifier* (get-all-identifier x)))
      (mapcar #'Tmp1 x)))

;;;;

(Tmp1 (,scs[SCS] (,@id-list[ID]) (fn ,@texp-list) ,@body))
-> (let* ((tmpbody (Tmp2 body))
	  (newdecl (first tmpbody))
	  (newbody (second tmpbody)))
     (setq n 1)
     `(,scs (,@id-list) (fn ,@texp-list) ,@newdecl ,@newbody ))

(Tmp1 ,otherwise)
-> otherwise

(Tmp1 nil)
-> nil

;;;;

(Tmp2 (,@item-list))
-> (let* ((tmp-item-list (mapcar #'Tmp item-list))
	  (decl-list (apply #'append (mapcar #'first tmp-item-list)))
	  (prev-stat (apply #'append 
                     (mapcar #'(lambda (x) `(,@(second x) ,(third x)))
                             tmp-item-list))))
	 ; (append decl-list prev-stat))
     `(,decl-list  ,prev-stat))
;;;;

; function-attribute & register-decl??
(Tmp (:attr ,atr ,@body))
-> `(nil nil (:attr ,atr ,@(Tmp2 body)))

(Tmp ((register ,@regarg) ,@body))
->(let ((tmpbody (Tmp2 body)))
    `(,(first tmpbody) nil ((register ,@regarg) ,@(second tmpbody))))

; begin
(Tmp (begin ,@body))
->(let ((tmpbody (Tmp2 body)))
    `(,(first tmpbody) nil (begin ,@(second tmpbody))))

; label
(Tmp (label ,id[ID] ,@stat))
->(let ((tmpbody (Tmp2 stat)))
    `(,(first tmpbody) nil (label ,id ,@(second tmpbody))))

; case
(Tmp (case ,exp))
->(let ((tmpexp (Tmpe exp)))
	`(,(first tmpexp) ,(second tmpexp) (case ,(third tmpexp))))

; default
(Tmp (default))
-> `(nil nil ,x) 

; if 
(Tmp (if ,exp ,stat1 ,@stat2))
-> (if (null stat2)
	(let* ((tmpexp (Tmpe exp))
	       (tmpstat1 (Tmp stat1))
	       (defexp (append (first tmpexp)(first tmpstat1)))) 
	  (if (null (second tmpstat1))
	      `( ,defexp ,(second tmpexp) (if ,(third tmpexp) ,(third tmpstat1)))
	   `( ,defexp ,(second tmpexp) (if ,(third tmpexp) (begin ,@(second tmpstat1)  ,(third tmpstat1))))))
	(let* ((tmpexp (Tmpe exp))
	       (tmpstat1 (Tmp stat1))
	       (tmpstat2 (Tmp (car stat2)))
	       (defexp (append (first tmpexp)(first tmpstat1)(first tmpstat2))))
	     `( ,defexp ,(second tmpexp) (if ,(third tmpexp)
		 (begin ,@(second tmpstat1) ,(third tmpstat1))
		 (begin ,@(second tmpstat2) ,(third tmpstat2))))))

; switch
(Tmp (switch ,exp ,@body))
-> (let ((tmpexp (Tmpe exp)))
	`( ,(first tmpexp) ,(second tmpexp) (switch ,(third tmpexp) ,@(Tmp2 body))))

; do-while
(Tmp (do-while ,exp ,@body))
->(let* ((tmpexp (Tmpe exp))
	 (tmpbody (Tmp2 body)))
	`(,(append (first tmpexp)(first tmpbody)) ,(second tmpexp) (do-while ,(third tmpexp) ,@(second tmpbody))))

; goto, continue, break 
(Tmp (goto ,id))
(Tmp (continue))
(Tmp (break))
->  `(nil nil ,(car x))

; return
(Tmp (return ,@exp))
-> (if (null exp)
       `(nil nil (return))
	(let ((tmpexp (Tmpe (car exp))))
	  `(,(first tmpexp) ,(second tmpexp) (return ,(third tmpexp)))))

(Tmp (def ,@exp))
-> `(nil nil ,x)

(Tmp (deftype ,@exp))
-> `(nil nil ,x) 

;;; <- マルチスレッド用プリミティブ

(Tmp (thread-create ,decl-list ,@body))
-> (let* ((tmpbody (Tmp2 body))
          (add-decl (first tmpbody))
          (newbody (second tmpbody)))
    (list nil nil `(thread-create ,(append decl-list add-decl) ,@newbody)))

(Tmp (thread-suspend ,var ,@body))
-> `(nil nil (thread-suspend ,var ,@body)))

(Tmp (thread-resume ,exp))
->(let ((tmpexp (Tmpe exp)))
   `(,(first tmpexp) ,(second tmpexp) (thread-resume ,(third tmpexp))))

;;; マルチスレッド用プリミティブ

; expression-statement 
(Tmp ,otherwise)
->(let* ((exps (Tmpe x))
	 (firstexp (first exps))
	 (secondexp (second exps))
	 (thirdexp (third exps)))
 `(,firstexp ,secondexp ,thirdexp))

(Tmp nil)
-> nil

;;;;;;	 

; exp
(Tmpe (the ,texp ,exp[ID]))
(Tmpe (the ,texp ,exp[integerp]))
(Tmpe (the ,texp ,exp[characterp]))
(Tmpe (the ,texp ,exp[numberp]))
(Tmpe (the ,texp ,exp[stringp]))
-> `(nil nil (the ,texp ,exp))

; aref
(Tmpe (the ,texp1 (aref ,texp2 ,exp)))
->(let* ((tmpexp (Tmpe exp))
	 (defexp (append (first tmpexp) nil))
	 (bindinfo (append (second tmpexp) nil)))
     `(,defexp ,bindinfo (the ,texp1 (aref ,texp2 ,(third tmpexp)))))

; fref
(Tmpe (the ,texp (fref ,exp ,id)))
->(let* ((tmpexp (Tmpe exp))
	 (defexp (append (first tmpexp)))
	 (bindinfo (append (second tmpexp))))
     `(,defexp ,bindinfo (the ,texp (fref ,(third tmpexp) ,id))))

; inc, dec, ++, --, unary-operator, bit-not
(Tmpe (the ,texp (inc ,exp)))
(Tmpe (the ,texp (dec ,exp)))
(Tmpe (the ,texp (++ ,exp)))
(Tmpe (the ,texp (-- ,exp)))
(Tmpe (the ,texp (bit-not ,exp)))
->(let* ((op (caaddr x))
	 (tmpexp (Tmpe exp))
	 (tempid1 (get-id-from-string (get-tmp-id tmp-id)))
	 (tempid `(the ,texp ,tempid1))
	 (defexp1 `(def ,tempid1 ,texp))
	 (bindinfo1 `(the ,texp (= (the ,texp ,tempid1) (the ,texp (,op ,(third tmpexp))))))
	 (bindinfo (append (second tmpexp) `(,bindinfo1)))
	 (defexp (append (first tmpexp) `(,defexp1))))
    `(,defexp ,bindinfo ,tempid)))

; ptr
(Tmpe (the (ptr ,texp) (ptr ,exp)))
-> (let* ((tmpexp (Tmpe exp))
    	  (defexp (first tmpexp))
	  (bindinfo (second tmpexp)))
     `(,defexp ,bindinfo (the (ptr ,texp) (ptr ,(third tmpexp)))))

; mref
(Tmpe (the ,texp (mref ,exp)))
->(let* ((tmpexp (Tmpe exp))
	 (defexp (append (first tmpexp)))
	 (bindinfo (append (second tmpexp))))
   `(,defexp ,bindinfo (the ,texp (mref ,(third tmpexp)))))

; sizeof???
(Tmpe (the int (sizeof ,exp[EXP])))
->(let* ((tmpexp (Tmpe exp)) 
	 (defexp (append (first tmpexp) nil))
	 (bindinfo (append (second tmpexp) nil)))
    `(,defexp ,bindinfo (the int (sizeof ,(third tmpexp)))))

(Tmpe (the int (sizeof ,texp)))
-> `(nil nil (the int (sizeof ,texp)))

; cast
(Tmpe (the ,texp (cast ,texp ,exp)))
->(let* ((tmpexp (Tmpe exp))
 	 (defexp (append (first tmpexp) nil))
	 (bindinfo (append (second tmpexp) nil)))
   `(,defexp ,bindinfo (the ,texp (cast ,texp ,(third tmpexp)))))

; if-exp 
(Tmpe (the ,texp (if-exp ,exp1 ,exp2 ,exp3)))
-> (let* ((tmpexp1 (Tmpe exp1))
	  (tmpexp2 (Tmpe exp2))
	  (tmpexp3 (Tmpe exp3))
	  (defexp (append (first tmpexp1) (first tmpexp2) (first tmpexp3)))
	  (bindinfo (append (second tmpexp1))))
	`( ,defexp (,bindinfo (if ,(third tmpexp1) ,(second tmpexp2) ,(third tmpstat2))) (the ,texp (if-exp ,(third tmpexp1) ,(third tmpexp2) ,(third tmpexp3)))))

; and 
(Tmpe (the int (and ,exp1 ,exp2)))
-> (let* ((tmpexp1 (Tmpe exp1))
	  (tmpexp2 (Tmpe exp2))
  	  (defexp (append (first tmpexp1) (first tmpexp2)))
	  (bindinfo (append (second tmpexp1))))
     (if (null (second tmpexp2))
	 `( ,defexp ,bindinfo (the int (and ,(third tmpexp1) ,(third tmpexp2))))
	 `( ,defexp ,(remove nil `(,bindinfo (if ,(third tmpexp1) ,@(second tmpexp2)))) (the int (and ,(third tmpexp1) ,(third tmpexp2))))))

; or
(Tmpe (the int (or ,exp1 ,exp2)))
-> (let* ((tmpexp1 (Tmpe exp1))
	  (tmpexp2 (Tmpe exp2))
  	  (defexp (append (first tmpexp1) (first tmpexp2)))
	  (bindinfo (append (second tmpexp1))))
     (if (null (second tmpexp2))
	 `( ,defexp ,bindinfo (the int (or ,(third tmpexp1) ,(third tmpexp2))))
	 `( ,defexp ,(remove nil `(,bindinfo (unless ,(third tmpexp1) ,(second tmpexp2)))) (the int (or ,(third tmpexp1) ,(third tmpexp2))))))

; =
(Tmpe (the ,texp (= ,exp1 ,exp2)))
-> (let* ((tmpexp1 (Tmpe exp1))
	  (tmpexp2 (Tmpe exp2))
	  (tempid1 (get-id-from-string (get-tmp-id tmp-id)))
	  (tempid `(the ,texp ,tempid1))
	  (defexp1 `(def ,tempid1 ,texp))
    	  (defexp (append (first tmpexp1)(first tmpexp2)`(,defexp1)))
	  (bindinfo1 `(the ,texp (= (the ,texp ,tempid1) (the ,texp (= ,(third tmpexp1) ,(third tmpexp2))))))
	  (bindinfo (append (second tmpexp1)(second tmpexp2)`(,bindinfo1))))
     `( ,defexp ,bindinfo ,tempid))

; call 
(Tmpe (the ,texp (call ,fexp ,@arg-list)))
-> (case texp
	((void)
	`(nil nil ,x))
	(otherwise
	 (let* ((tmpexps (comb-list (mapcar #'Tmpe arg-list))) 
	  (tempid2 (get-id-from-string (get-tmp-id tmp-id))) 
	  (tempid `(the ,texp ,tempid2))
	  (defexp1 `(def ,tempid2 ,texp))
    	  (defexp (append (first tmpexps) `(,defexp1)))
	  (bindinfo1 `(the ,texp (= (the ,texp ,tempid2)(the ,texp (call ,fexp ,@(third tmpexps))))))
	  (bindinfo (append (second tmpexps) `(,bindinfo1))))
     `( ,defexp ,bindinfo ,tempid ))))

; operators
(Tmpe (the ,texp (,op ,@exp-list)))
-> (case op
     ((* / % + - bit-xor bit-and bit-or << >> <<= >>=  bit-and= bit-xor= bit-or= < > <= >= == != exps)
      (let* ((lexp (Tmpe (car exp-list)))
	     (rexp (Tmpe (cadr exp-list))))
	(if (null rexp)
	    (let ((defexp (append (first lexp)))
		  (bindinfo (append (second lexp))))
	      `(,defexp ,bindinfo (the ,texp (,op ,(third lexp)))))
	    (let ((defexp (append (first lexp)(first rexp)))
		  (bindinfo (append (second lexp)(second rexp))))
	      `(,defexp ,bindinfo (the ,texp (,op ,(third lexp) ,(third rexp))))))))
     ((*= /= %= += -=))
     (let* ((lexp (Tmpe (car exp-list)))
	    (rexp (Tmpe (cadr exp-list))))
	(if (null rexp)
    	    (tempid1 (get-id-from-string (get-tmp-id tmp-id)))
	    (tempid `(the ,texp ,tempid1))
	    (defexp1 `(def ,tempid1 ,texp))
	    (defexp (append (first lexp)(first rexp)`(,defexp1)))
	    (bindinfo1 `(the ,texp (,op (the ,texp ,tempid1) (the ,texp (,op ,(third lexp) ,(third rexp))))))
	    (bindinfo (append (second lexp)(second rexp)`(,bindinfo1))))
       `( ,defexp ,bindinfo ,tempid)))

(Tmpe nil)
-> nil

(Tmpe ,otherwise)
-> otherwise

 