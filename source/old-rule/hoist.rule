;;; hoisting sc0 の 全ての宣言を関数本体の先頭に移動
;;; rename.rule を適用済みであること。
;;; lightweight, multithread にも対応。
;;; !!! initializer が副作用を起こす場合は、正しく動作しない

:lisp-begin
(defpackage "HOIST"
  (:use "SCT-UESR" "CL"))
(in-package "HOIST")

(defvar *used-identifier* nil)
(defvar *top-level* t)

(defun remove-const (x)
  (when (not (listp x)) (return-from remove-const x))
  (setq x (remove 'const x))
  (when (= 1 (length x))
    (return-from remove-const (remove-const (car x))))
  (mapcar #'remove-const x))     

;; Hs1, Hsb, Hse の返り値を宣言部とbody部に分ける
(defun split-decl-and-body (x)
  (list (apply #'append (mapcar #'first x))
        (remove nil (mapcar #'second x))))
:lisp-end

(Hs0 (,@declaration-list) )
-> (let ((*used-id-list* (get-all-identifier declaration-list))
         (*top-level* t))
     (apply #'append
	      (split-decl-and-body (mapcar #'Hs1 declaration-list))))

;;; 以下, Hs1, Hsb, Hse の返り値は、
;;; (<関数本体の先頭に出すS式のリスト>
;;;  <元の場所に残すS式>)

;;;;;; declaration ;;;;;;
;;variable (without initializer)
(Hs1 (,scs[SCS] ,id[ID] ,texp))
-> (list `(,x) nil)
   
;;variable (with initializer)
(Hs1 (,scs[SCS] ,id[ID] ,texp ,init))
-> (let* ((new-texp (remove-const texp)))
     (cond
       (*top-level*
	(list (list x) nil))
       ;; string-literal, array
       ((or (stringp init)
	    (and (listp init)
		 (eq 'array (car init))))
	(let* ((init-id (generate-id (string+ (par-identifier id) "_init")
				     *used-id-list*))
	       (sizeof-arg (if (stringp init) init init-id)))
	  (list `((,scs ,id ,new-texp ,init)
		  (,scs ,init-id ,new-texp ,init))
		`(memcpy ,id ,init-id (sizeof ,sizeof-arg)))))

       ;; struct
       ((and (listp init)
	     (eq 'struct (car init)))
	(let ((init-id (generate-id (string+ (par-identifier id) "_init")
				    *used-id-list*)))
	  (list `((,scs ,id ,new-texp ,init)
		  (,scs ,init-id ,new-texp ,init))
		`(= ,id ,init-id))))

       ;; otherwise
       (t
	(list `((,scs ,id ,new-texp ,init))
	      `(= ,id ,init)))))

;;function
(Hs1 (,scs[SCS] (,@id-list[ID]) (fn ,@texp-list) ,@body))
(Hs1 (,scs[SCS] (,@id-list[ID]) (lightweight ,@texp-list) ,@body)) ;lw
-> (let ((fn-tag (car (third x)))
	 (*top-level* nil)
	 ;; 最初から先頭にある宣言
	 (sepbody1 nil)
	 ;; 残りのblock-item
	 (sepbody2 nil))
     (let ((decl-end-p nil))
       (dolist (bi body (setq sepbody1 (reverse sepbody1)
			      sepbody2 (reverse sepbody2)))
	 (unless (and (listp bi)
		      (or (par-storage-class-specifier (first bi))
			  (eq 'deftype (first bi)))
		      (par-identifier (second bi)))
	   (setq decl-end-p t))
	 (if decl-end-p
	     (push bi sepbody2)
	   (push bi sepbody1))))
     (let ((hs2-sepbody2 (hs2 sepbody2)))
       (list `((,scs (,@id-list) (,fn-tag ,@texp-list) 
		,@sepbody1 ,@(apply #'append hs2-sepbody2)))
	     nil)))

;;struct, union
(Hs1 (,dd[DEF-DECL] (,soru[S-OR-U] ,id[ID]) ,@sdeclist))
;;enum
(Hs1 (def (enum ,id[ID]) ,@enum-list))
;;deftype (struct)
(Hs1 (deftype ,id[ID] struct ,@sdecllist))
;;deftype (enum)
(Hs1 (deftype ,id[ID] enum ,@enum-list))
;deftype
(Hs1 (deftype ,id[ID] ,texp))
-> (list `(,x) nil)

(Hs1 ,otherwise)
-> (list `(,x) nil)

;;;;;;; body +α ;;;;;;
; function-attribute & register-decl
(Hs2 (:attr ,atr   ,@body) )
-> `(:attr ,atr ,@(Hs2 body))
(Hs2 ((register ,@regarg)   ,@body) )
-> `((register ,@regarg) ,@(Hs2 body))

(Hs2 (,@body))
-> (split-decl-and-body (mapcar #'Hsb body))

;;;;;; statement ;;;;;;

;;begin
(Hsb (begin ,@body))
-> (let ((hs2-body (Hs2 body)))
     (list (first hs2-body)
	   `(begin ,@(second hs2-body))))

;;label
(Hsb (label ,id ,stat))
-> (let ((hsb-stat (Hsb stat)))
     (list (first hsb-stat)
	   `(label ,id ,(second hsb-stat))))

;;case
(Hsb (case ,exp))
;;default
(Hsb (default))
-> (list nil x)

;;if
(Hsb (if ,exp ,stat1 ,@stat2))
-> (let ((hsb-stat1 (Hsb stat1))
	 (hsb-stat2 (if stat2 (Hsb (car stat2)) nil)))
     (if stat2
	 (list (append (first hsb-stat1) (first hsb-stat2))
	       `(if ,exp ,(second hsb-stat1) ,(second hsb-stat2)))
	 (list (first hsb-stat1)
	       `(if ,exp ,(second hsb-stat1)))))


;;switch
(Hsb (switch ,exp ,@body))
-> (let ((hs2-body (Hs2 body)))
     (list (first hs2-body)
	   `(switch ,exp ,@(second hs2-body))))

;;do-while
(Hsb (do-while ,exp ,@body))
-> (let ((hs2-body (Hs2 body)))
     (list (first hs2-body)
	   `(do-while ,exp ,@(second hs2-body))))

;;goto, continue, break
(Hsb (goto ,id) )
(Hsb (continue) )
(Hsb (break) )
;;return
(Hsb (return ,@exp) )
-> (list nil x)

;;; <- マルチスレッド用プリミティブ

;; thread-create内部の宣言は外に出さなくてよい?
(Hsb (thread-create ,decl-list ,@body) )
-> (let ((hs2-body (Hs2 body)))
     (list nil
	   `(thread-create ,(append decl-list (first hs2-body))
	     ,@(second hs2-body))))

(Hsb (thread-suspend ,id ,@body) )
-> (let ((hs2-body (Hs2 body)))
     (list (first hs2-body)
	   `(thread-suspend ,id ,@(second hs2-body))))

(Hsb (thread-resume ,exp))
-> (list nil x)

;;; マルチスレッド用プリミティブ ->

(Hsb ,exp[EXPR])
-> (list nil x)

;;declaration
(Hsb ,otherwise)
-> (Hs1 x)

