;;; 入れ子関数を使ったSC-0(with typeinfo) -> 普通のSC-0(with typeinfo?)
;;; "hoist.rule", "type.rule", "tmp.rule" が適用済みであること
;;;
;;; 入れ子関数の定義は
;;; (def (<identifier-list>) (lightweight <type-expression-list>) ...)

;; 2004/06/14 c-expressionに対応

;;; 未解決の問題
;;; *staticなローカル変数の扱い
;;; *lightweight の関数ポインタに mref が適用されたときの扱い
;;; *引数の array型は ptrと同一視してやるとよい．
;;; *局所変数へのポインタを使用していると危険
;;;  ->ポインタを取得している局所変数は常にestackで扱うようにする
;;;  ->一応対処したが、その変数が引数、あるいは初期値を持っていた場合
;;;    efp->"var" の値に初期値をおいてやる必要がある。
;;;    引数がポインタを獲得されたとき，estackに移動してる？
;;;  Nf1でごちゃごちゃやるより add-localを仕様変更したほうがよさげ
:lisp-begin
(defpackage "NESTED-FUNCTION"
  (:nicknames "LW" "NESTFUNC")
  (:use "SCT-USER" "CL" "SC-MISC" "SC-UTIL")
  (:export "*ESTACK-SIZE*" "*ALL-IN-ESTACK*"))
(in-package "NESTED-FUNCTION")

(set-rule-environment
 (:package-sensitive nil))

;;; estack[]のサイズ
(defvar *estack-size* 65536)
;;; 局所変数などを全て明示的スタックに置く(= CL-SC)？
(defparameter *all-in-estack* nil)
;;; 使用済みidentifierのリスト
(defvar *used-id-list* nil)
;;; 関数フレームの構造体情報
;;; ( <(元のソースでの)関数名> . <構造体情報> ) のリスト
;;; <構造体情報> := ( <構造体名> ) 
(defvar *frame-alist* nil)
;;; 現在いる関数の情報
(defvar *current-func* nil)

(scr:require "NESTFUNC-DEFS")

;;; マルチスレッド環境で，スタックの最初のフレームを判断する条件
(defun thread-origin-p (finfo-or-fid)
  (let ((fid (if (symbolp finfo-or-fid)
		 finfo-or-fid
		 (finfo-name finfo-or-fid))))
    (or (eq 'main fid)
	(eq 'thread-origin fid))))

:lisp-end

(Nf0 (,@declaration-list) )
-> (let ((*keyword-list* (cons 'lightweight *keyword-list*))
	 (*used-id-list* (get-all-identifier x))
	 (*all-in-estack* (or (member :closure *parameters*)
			      *all-in-estack*)) 
	 (*frame-alist* nil)
	 (*current-func* nil))
     (cons
      '(%include "rule/nestfunc.sh")
      (let* ((nf1-result (mapcar #'Nf1 declaration-list))
	     (combined-result
	      (mapcar #'(lambda (x)
			  (append
			   (first x) (second x)
			   (third x) (list (fourth x))))
		      nf1-result)))
	(remove nil (apply #'append combined-result)))))

;;; これ以降, Nf1, Nfb, Nfe の返り値は、
;;; (<関数宣言の直前に出すS式のリスト>
;;;  <直近のブロックの先頭に出すS式のリスト>
;;;  <直前に出すS式のリスト>
;;;  <自分自身の変換後のS式>)

;;;;;; declaration ;;;;;;
;;; variable
(Nf1 (,scs[SCS] ,id[ID] ,texp {,init}) )
-> (cond
     ((null *current-func*)
      (list nil `(,x) nil nil))
     ((string= (identifier-sc2c texp) "__label__")
      ;; for local-label
      ;; フレーム復帰用コードは、あとでlabelのある場所で追加
      (push (cons id nil)
            (finfo-local-label *current-func*))
      (list nil nil nil nil))       
     (t
      (let* ((init (if (pattern-variable-p 'init) init nil))
             (decl0 (add-local id texp :var :init init))
             (decl (if (estack-variable-p id)
                       '()
                       `( ,(firstn decl0 3) )) )
             (init-exp (if init
                           `(the ,(third decl0)
                             (= 
                              ,(Nfe-xfp `(the ,(third init) ,id))
                              ,(fourth decl0)))
                           '() )))
        ;; 例外（初期値が文字列 or 配列）
        (when (and init
                   (or (stringp (third init))
                       (eq 'array (car init))))
          (setq decl `(,decl0) )
          (setq init-exp nil) )
        (list nil decl nil init-exp) )))
     
;;; function(top-level)
;;; ・main以外の第一引数にespを追加
;;; ・esp,estack(main), new-espの付加。call-idの追加
;;; ・入れ子関数(closure-t)を呼ぶ関数ではargpを付加
;;; ・復帰処理の挿入
;;; ・efp, esp, new-expの初期化;
;;; ・関数の引数の保存用変数を付加
;;; ・関数の結果の保存用変数を付加 (<- tmp.ruleで)
;;; ・フレーム情報構造体を付加して構造体の定義を外に出す
;;;   * tmp_esp
;;;   * argp
;;;   * call_id
;;;   * その他ローカル変数
;;; ・入れ子関数の定義を外に出して、関数内ではclosure-t型に
;;; ・関数呼び出しをwhile( tmp-res = ... ){ <保存>,return,<復帰> } に変える。
;;;   mainとその他では{ ... } のとこの処理が違う
(Nf1 (,scs[SCS] (,fid[ID] ,@id-list[ID]) (fn ,@texp-list) ,@body) )
-> (let ((new-id-list id-list)        ;変換後のid-list
	 (new-texp-list texp-list)    ;変換後のtexp-list
	 (add-decl-list '() ))        ;追加する宣言のリスト
     ;; Cの関数ならなにもしない
     (when (cid-p fid) 
       (return-from Nf1 `(nil (,x) nil nil)))

     ;; main以外では、第一引数の追加
     (if (thread-origin-p fid)
	 (setq new-id-list id-list
	       new-texp-list (mapcar #'lw2ct texp-list))
	 (setq new-id-list (cons 'esp id-list)
	       new-texp-list `(,(car (lw2ct texp-list)) (ptr char)
			       ,@(mapcar #'lw2ct (cdr texp-list)))))

     ;; 関数を局所変数として登録
     (when *current-func*
       (add-local fid `(ptr (fn ,@new-texp-list)) :var))
     
     ;; bodyがからっぽなら第一引数だけ追加
     (when (null body)
       (return-from Nf1
         `(nil
           ((,scs (,fid ,@new-id-list) (fn ,@new-texp-list)))
           nil nil)))

     (let ((*current-func* (make-finfo :name fid
				       :ret-type (car texp-list)
				       :estack-var (Nf-search-ptr body))))
       ;frame構造体を登録する
       (get-frame fid)
       ;; 引数をframeに追加
       (do ((argid id-list (cdr argid))
	    (argtype (cdr texp-list) (cdr argtype)))
	   ((or (endp argid) (endp argtype)))
	 (add-local (car argid) (car argtype) :var))

       ;; 先頭の宣言の追加
       ;; estack: 明示的スタック
       ;; esp: 明示的スタックポインタ（main以外では追加引数）
       ;; esp-flag: espの下位2ビットのフラグ部分
       ;; ; 最下位 -- スタック積み直し中フラグ
       ;; ; 下から2つめ -- 未使用
       ;; new-esp: espにフラグを追加したりして関数呼出しの引数にする
       ;; efp: 明示的スタックフレームポインタ
       (if (thread-origin-p fid)
	   (pushs (add-local 'esp '(ptr char) :system
                             :init 'estack)
		  (add-local 'estack `(array char ,*estack-size*) :system)
		  add-decl-list)
           (unless *all-in-estack*
             (push (add-local 'esp-flag 'size-t :system
                              :init '(bit-and (cast size-t esp) 3))
                   add-decl-list)))

       (unless *all-in-estack*
         (push (add-local 'new-esp '(ptr char) :system)
               add-decl-list) )
       (push (add-local 
              'efp `(ptr (struct ,(get-frame-name fid))) :system)
             add-decl-list)

       (let* ((nfb-body (Nfb0 body))
	      (new-body
	       (append
		(apply #'append (mapcar #'second nfb-body)) ; body->宣言
		(make-resume *current-func*)        ; 復帰処理
		(make-init-efp-esp *current-func*)  ; efp, esp 設定
                (save-args-into-estack id-list (cdr texp-list))    
                                        ; all-in-estack時
                (when *all-in-estack* (make-normalize-nf))
		(apply #'append                     ; body->本体
		       (mapcar #'(lambda (x)
				   `(,@(third x) ,(fourth x)))
			       nfb-body)))))
	 ;; 必要ならargpの宣言を追加
	 (when (finfo-argp *current-func*)
	   (push '(def argp (ptr char)) add-decl-list))
	 (list 
	  ;; 構造体&入れ子関数の定義を外に出す
	  `(,(make-frame-decl *current-func*)
	    ,@(apply #'append (mapcar #'first nfb-body)))
	  ;; 新しい関数宣言
	  `((,scs (,fid ,@new-id-list) (fn ,@new-texp-list)
	     ,@(append add-decl-list
		       (remove nil new-body))))
	  nil nil))))

;;; lightweightの関数宣言
;;; 引数と返り値の型を変更。
;;; 代わりに関数の先頭で引数を受け取る処理を書き、
;;; returnをいじる必要がある。
(Nf1 (,scs[SCS] (,fid[ID] ,@id-list[ID]) (lightweight ,@texp-list) ,@body) )
-> (let* ((parent-name (finfo-name *current-func*))
	  (parent-func *current-func*)
	  (extid (make-extid fid)) ;; 外に出す関数名
	  #+() (int-name  ; フレームに登録する、closure-tの変数の名前
                (generate-id (string+ (identifier-sc2c fid) "0") 
                             *used-id-list*))
	  (add-decl-list-p nil))
     ;; 入れ子関数リストに追加
     (add-nestfunc fid extid)

     (let ((*current-func* (make-finfo :name extid
				       :parent-func parent-func
				       :ret-type (car texp-list)
				       :estack-var (Nf-search-ptr body)))
	   (add-decl-list nil)) 
       ;; frame構造体を登録
       (get-frame extid)
       ;; 先頭の宣言を追加
       (unless *all-in-estack*
         (push (add-local 'new-esp '(ptr char) :system) add-decl-list) )
       (push (add-local 'efp
                        `(ptr (struct ,(get-frame-name extid))) :system)
             add-decl-list)
       (push (add-local 'xfp
                        `(ptr (struct ,(get-frame-name parent-name)))
                        :var :init 'xfp0)
             add-decl-list)
       (unless *all-in-estack*
         (push (add-local 'esp-flag 'size-t :system
                          :init '(bit-and (cast size-t esp) 3))
               add-decl-list) )
       (push (add-local 'parmp '(ptr char) :system
                        :init `(cast (ptr char)
                                ,(if *all-in-estack*
                                     'esp
                                     '(bit-xor
                                       (cast size-t esp)
                                       esp-flag))) )
             add-decl-list)
       ;; 引数を明示的スタックのトップからpopしながら獲得
       (do ((id0 id-list (cdr id0))
	    (tp0 (cdr texp-list) (cdr tp0)))
	   ((endp id0))
         (let ((decl (add-local (car id0) (car tp0) :var)))
                                        ; all-in-estack でも副作用が必要
           (unless *all-in-estack*
             (push `(,@decl (pop-arg ,(car tp0) parmp))
                   add-decl-list) )))
       ;; 返り値
       (let* ((nfb-body (Nfb0 body))
	      (new-body
	       (append
		(apply #'append (mapcar #'second nfb-body))
		(make-resume *current-func*)
		(make-init-efp-esp *current-func*)
                (save-args-into-estack id-list (cdr texp-list))
                                        ;all-in-estack時
                (when *all-in-estack* (make-normalize-nf))
		(apply #'append
		       (mapcar #'(lambda (x)
				   `(,@(third x) ,(fourth x)))
			       nfb-body))
		(list '(return 0)))))
	 ;; 必要ならargpの宣言を追加
	 (when (finfo-argp *current-func*)
	   (push '(def argp (ptr char)) add-decl-list))
	 (setq add-decl-list (nreverse add-decl-list))
	 (list
	  ;; 1
	  `(,(make-frame-decl *current-func*)
	    ,@(apply #'append (mapcar #'first nfb-body))
	    ;; 外に出す関数宣言
	    (,scs (,extid esp xfp0) (fn (ptr char) (ptr char) (ptr void))
	     ,@(append add-decl-list (remove nil new-body))))
	  ;; 2
	  add-decl-list-p
	  ;; 3,4
	  nil nil))))

;;; struct, union
;;; 多分なにもしなくていい
;;; このへん、関数内で定義されるとちょっと鬱陶しいことになりそう
(Nf1 (,dd[DEF-DECL] (,soru[S-OR-U] ,id[ID]) ,@sdeclist) )
-> (list nil (list x) nil nil)
     
;;; enum
;;; なにもしない
(Nf1 (def (enum ,id[ID]) ,@enum-list) )
-> (list nil (list x) nil nil)

;;; deftype (struct)
;;; なにもしない
(Nf1 (deftype ,id[ID] struct ,@sdecllist) )
-> (list nil (list x) nil nil)

;;; deftype (enum)
;;; なにもしない
(Nf1 (deftype ,id[ID] enum ,@enum-list) )
-> (list nil (list x) nil nil)

;;; deftype
;;; なにもしない
(Nf1 (deftype ,id[ID] ,texp) )
-> (list nil (list `(deftype ,id ,(lw2ct texp))) nil nil)

(Nf1 (c-exp ,@rem))
-> (list nil (list x) nil nil)

(Nf1 ,otherwise)
-> (error "syntax error at ~s." x)

;;;;;;; bodyの最初の余計なやつを取り除く
;;; function-attribute & register-decl
(Nfb0 (:attr ,atr ,@body) )
-> `( ,(list nil nil nil ':attr)
      ,(list nil nil nil atr)
      ,@(Nfb0 body))

(Nfb0 ((register ,@regarg)   ,@body) )
-> `( ,(list nil nil nil (car x))
      ,@(Nfb0 body))

(Nfb0 ,otherwise)
-> (mapcar #'Nfb x)

;;;;;; body ;;;;;;;
;;; begin
(Nfb (begin ,@body) )
-> (combine-ret-list (Nfb0 body) '(begin))

;;; label
(Nfb (label ,id ,stat) )
-> (progn
     ;; 局所ラベルとして宣言済のラベルに対して、
     ;; 入れ子関数からgotoで脱出してきたとき用の復帰情報を付与
     (multiple-value-bind (lab-level llab-info)
	 (find-local-label id *current-func*)
       (when (and lab-level (= lab-level 0))
	 (rplacd llab-info (make-frame-resume *current-func*))))       
     (let ((nfb-stat (Nfb stat)))
       (list (first nfb-stat) (second nfb-stat)
	     (cons `(label ,id nil) (third nfb-stat))
	     (fourth nfb-stat))))

;;; case (expから外にでるものはないはず)
(Nfb (case ,exp) )
-> (list nil nil nil `(case ,(Nfe-xfp exp)))

;;; default
(Nfb (default) )
-> (list nil nil nil '(default))

;;; if
(Nfb (if ,exp ,stat1 ,@stat2) )
-> (let ((nfe-exp (Nfe exp))
	 (nfb-stat1 (Nfb stat1)))
     (if (null (setq stat2 (car stat2)))
	 (list (append (first nfe-exp) (first nfb-stat1))
	       (append (second nfe-exp) (second nfb-stat1))
	       (third nfe-exp)
	       `(if ,(fourth nfe-exp)
		    (begin ,@(third nfb-stat1) ,(fourth nfb-stat1))))
       (let ((nfb-stat2 (Nfb stat2)))
	 (list (append (first nfe-exp) (first nfb-stat1) (first nfb-stat2))
	       (append (second nfe-exp) (second nfb-stat1) (second nfb-stat2))
	       (third nfe-exp)
	       `(if ,(fourth nfe-exp)
		    (begin ,@(third nfb-stat1) ,(fourth nfb-stat1))
		  (begin ,@(third nfb-stat2) ,(fourth nfb-stat2)))))))

;;; switch (exp から外にでるものはないはず)
(Nfb (switch ,exp ,@body) )
-> (combine-ret-list (Nfb0 body) `(switch ,(Nfe-xfp exp)))

;;; do-while (exp から外にでるものはないはず)
(Nfb (do-while ,exp ,@body) )
-> (combine-ret-list (Nfb0 body) `(do-while ,(Nfe-xfp exp)))

;;; goto
(Nfb (goto ,id))
-> (multiple-value-bind (lab-level llab-info labnum)
       (find-local-label id *current-func*)
     (if (or (null lab-level) (= lab-level 0))
	 (list nil nil nil `(goto ,id))   ; 通常のgoto
       ;; 親関数にgotoで脱出
       (let* ((xfp-exp (butlast
			`(fref
			  ,@(apply #'append
				    (make-list lab-level 
					       :initial-element '(xfp ->))))))
	      (callid-exp (append xfp-exp '(-> call-id))))
	 (list nil nil
	       `( (= ,callid-exp ,(- labnum)) ) ; goto先のcall-id書き換え
		`(return (cast (ptr char) ,xfp-exp)))))) ; goto先のefpをreturn

;;; continue, break
(Nfb (continue) )
(Nfb (break) )
-> (list nil nil nil x)

;;; 返り値なしreturn
(Nfb (return) )
-> (if (finfo-parent-func *current-func*)
       (list nil nil nil '(return 0))
       (list nil nil nil '(return)))

;;; return (exp から外にでるものはないはず)
(Nfb (return ,exp) )
-> (if (finfo-parent-func *current-func*)
       (list nil nil
	     `( (= (mref-t ,(finfo-ret-type *current-func*) efp)
		   ,(Nfe-xfp exp)) )
	     '(return 0))
     (list nil nil nil `(return ,(Nfe-xfp exp))))

;;; null-statement
(Nfb nil)
-> (list nil nil nil nil)

;;; expression-statement or declaration
(Nfb ,otherwise )
-> (let ((nfe-x (Nfe x)))
     (if (eq '$not-expression nfe-x)
	 (Nf1 x)
       nfe-x))

;;;;;;; expression (with type-info) ;;;;;;;

;;; tmp.ruleの変換結果により、callは
;;; (the void (call (the ,texp ,exp) ,@exp-list))
;;; か、
;;; (the ,texp (= (the ,texp ,id)
;;;               (the ,texp (call (the ,texp ,exp) ,@exp-list)))
;;; のどちらかの形で現れるようになっている。

;;; 通常のfunction-call
;;; ・引数の値を保存
;;; ・呼び出す関数のポインタも保存
(Nfe (the ,texp0
	  (= (the ,texp1 ,id)
	     (the ,texp (call (the (fn ,@texp-list) ,exp-f) ,@exp-list)))))
(Nfe         (the ,texp (call (the (fn ,@texp-list) ,exp-f) ,@exp-list)))
-> (let ((assign-p (pattern-variable-p 'id))
	 (decl-prev-tmpid-list nil)  ; list of (<decl> <prev> <tmpid>)
	 (id-tmp nil) (type-tmp nil))
     ;; Cの関数ならなにもしない
     (when (cid-p exp-f)
       (let ((rvalue `(the ,texp (call (the (fn ,@texp-list) ,exp-f)
                                  ,@(mapcar #'Nfe-xfp exp-list))) ))
         (return-from Nfe
           `(nil nil nil 
             ,(if assign-p
                  `(= ,(Nfe-xfp `(the ,texp1 ,id)) ,rvalue)
                  rvalue)) )))
     ;; 関数ポインタ保存
     (if (simple-exp-p exp-f)
	 (push `(nil nil ,exp-f) decl-prev-tmpid-list)
	 (progn
	   (setq id-tmp (generate-id "tmp_fp" *used-id-list*)
		 type-tmp `(ptr (fn
                                 ,(car texp-list)
                                 #|(ptr char) ,@(cdr texp-list))))|# )))
	   (push (list (add-local id-tmp type-tmp :tmp)
		       `(= ,id-tmp ,(Nfe-xfp `(the ,type-tmp ,exp-f)))
		       id-tmp)
		 decl-prev-tmpid-list)))
     ;; 引数保存
     (dolist (exp exp-list)
       (if (simple-exp-p (third exp))
	   (push `(nil nil ,(Nfe-xfp exp)) decl-prev-tmpid-list)
	   (progn
	     (setq id-tmp (generate-id "tmp_arg" *used-id-list*)
		   type-tmp (Nf-gettype exp))
	     (push (list (add-local id-tmp type-tmp :tmp)
			 `(= ,id-tmp ,(Nfe-xfp exp))
			 id-tmp)
		   decl-prev-tmpid-list))))
     (setq decl-prev-tmpid-list (nreverse decl-prev-tmpid-list))
     ;; ここが返り値。かなり面倒なのがわかったのでexpressionには型情報無し
     ;; あとでuntypeすればいっしょ
     (let* ((decl-list (remove nil (mapcar #'first decl-prev-tmpid-list)))
	    (prev-list (remove nil (mapcar #'second decl-prev-tmpid-list)))
	    (tmpid-list (mapcar #'third decl-prev-tmpid-list))
	    (fcall-exp `(call
                         ,(car tmpid-list)
                         ,(if *all-in-estack* 'esp 'new-esp)
                         ,@(cdr tmpid-list)))
	    (eq-exp  (when assign-p
		       `(== (= ,(Nfe-xfp `(the ,texp1 ,id)) ,fcall-exp)
  		            (special ,(car texp-list)))))
	    (neq-exp `(!= (= (fref efp -> tmp-esp)
			     (mref-t (ptr char) esp))
                       0)))
       (unless *all-in-estack*
         (push '(= new-esp esp) prev-list))
       (list nil 
             decl-list
	     prev-list
	     `(while ,(if assign-p
			  `(and ,eq-exp ,neq-exp)
			  `(exps ,fcall-exp ,neq-exp))
               ,@(cond
                  ;; all-in-estack時 gotoによる非局所脱出の面倒を見る
                  (*all-in-estack*
                   `((if (< (cast (ptr char) (fref efp -> tmp-esp))
                            (cast (ptr char) efp))
                         ,(if (finfo-parent-func *current-func*)
                              '(return (fref efp -> tmp-esp))
                              (make-suspend-return)))
                     (= (fref efp -> tmp-esp) 0)
                     (goto LGOTO)
                     ) )
                  ;; main および 入れ子関数
                  ((or (thread-origin-p (finfo-name *current-func*))
                       (finfo-parent-func *current-func*))
                   `((def goto-fr (ptr char))
                     (= (mref-t (ptr char) esp) 0)
                     ;; フレーム情報保存＆入れ子関数の正規化
                     ,@(make-frame-save)
                     ,@(make-normalize-nf)
                     (= goto-fr (lw-call (fref efp -> tmp-esp)))
                     ,@(unless (thread-origin-p (finfo-name *current-func*))
                               `((if (and goto-fr
                                          (< (cast (ptr char) goto-fr)
                                             (cast (ptr char) efp)))
                                     (return goto-fr))))
                     (if (== (cast (ptr char) goto-fr)
                             (cast (ptr char) efp))
                         (goto LGOTO))
                     ,@(make-frame-resume) ; 入れ子関数での変更を反映
                     ) )
                  ;; main 以外の通常関数
                  (t
                   `(
                     ;; フレーム情報の保存,入れ子関数の正規化 
                     ,@(make-frame-save)
                     ,@(make-normalize-nf)
                     ;; call-idの更新
                     (= (fref efp -> call-id)
                      ,(length (finfo-label-list *current-func*)))
                     ;; return
                     ,(make-suspend-return)
                     ;; 復帰位置
                     (label 
                      ,(caar (push 
                              (cons (generate-id "L_CALL"
                                                 *used-id-list*)
                                    nil)
                              (finfo-label-list *current-func*)))
                      nil)
                     ,@(make-frame-resume)
                     ) ))
               ;; main, main以外共通。
               ;;「消すと遅くなる??」の部分
               ,@(unless *all-in-estack*
                   `(,@(mapcar
                        #'(lambda (x)
                            `(= ,(second x) (fref efp -> ,(second x))))
                        decl-list)
                     (= new-esp (+ esp 1)))) ))))

;;; lightweightのfunction-call
;;; argpをpush
;;; 引数たちもpush
;;; フレーム情報の保存、resume後復帰。
(Nfe (the ,texp0
	  (= (the ,texp1 ,id)
	     (the ,texp (call (the (lightweight ,@texp-list) ,exp-f)
			      ,@exp-list)))))
(Nfe         (the ,texp (call (the (lightweight ,@texp-list) ,exp-f)
			      ,@exp-list)))
-> (let ((assign-p (pattern-variable-p 'id))
	 (return-p (not (or (thread-origin-p (finfo-name *current-func*))
			    (finfo-parent-func *current-func*)
			    *all-in-estack*)))
	 (fp-id nil) (fp-type nil) fp-decl fp-prev
	 (xfp-exp-f
	  (Nfe-xfp `(the (lightweight ,@texp-list) ,exp-f))))
     ;; argpが必要であることを教える。
     (setf (finfo-argp *current-func*) t)
     ;; 関数ポインタ保存
     (if (simple-exp-p xfp-exp-f)
	 (setq fp-id xfp-exp-f
	       fp-decl nil fp-prev nil)
       (progn
	   (setq fp-id (generate-id "tmp_fp" *used-id-list*)
		 fp-type (lw2ct `(ptr (lightweight ,@texp-list))))
	   (setq fp-decl (list (add-local fp-id fp-type :system)))
	   (setq fp-prev (list `(= ,fp-id ,xfp-exp-f)))))
     ;; 返り値
     (list nil fp-decl nil
	   `(begin
	     ,@(unless return-p
		  '( (def goto-fr (ptr char)) ))
	     ,@fp-prev
	     (= argp (aligned-add esp (sizeof (ptr char))))
	     ;; 引数のpush
	     ,@(mapcar
		(compose
		 #'(lambda (x)
		     `(push-arg ,(second x) ,(third x) argp))
		 #'Nfe-xfp)
		(reverse exp-list))
	     ;; 入れ子関数へのポインタをargpに置く
	     (= (mref-t (ptr closure-t) argp) ,fp-id)
	     ;; 入れ子関数の正規化
	     ,@(unless *all-in-estack*
                 (make-normalize-nf))
	     ;; フレーム情報の保存
	     ,@(make-frame-save)
	     ,@(when return-p
  	         `((= (fref efp -> argp) argp)      ; 後で返り値を獲得するため
		   (= (fref efp -> tmp-esp) argp))) ; returnしながら伝えるため
	     ,@(if return-p
                   ;; main以外の関数 (非all-in-estack)
                   `(
                     ;; call-idの更新
                     (= (fref efp -> call-id)
                      ,(length (finfo-label-list *current-func*)))
                     ;; return
                     ,(make-suspend-return)
                     ;; 復帰位置
                     (label ,(caar
                              (push (cons (generate-id "L_CALL"
                                                       *used-id-list*)
                                          nil)
                                    (finfo-label-list *current-func*)))
                      nil)
                     ,@(make-frame-resume)
                     )
		   ;; mainおよび入れ子関数
                   ;; all-in-estack時 は強制的にこっち
		   `(
		     (= goto-fr (lw-call argp))
		     (if goto-fr
			 (if (< (cast (ptr char) goto-fr)
				(cast (ptr char) efp))
			     ,(if (finfo-parent-func *current-func*)
                                  '(return goto-fr)
                                  `(begin
                                    (= (fref efp -> tmp-esp) goto-fr)
                                    ,(make-suspend-return)))
                             (begin
                              (= (fref efp -> tmp-esp) 0)
                              (goto LGOTO))))
                     ,@(unless *all-in-estack*
                         (make-frame-resume))
		     )
		   )
	     ;; 帰り値の代入（必要な場合）
	     ,@(when assign-p
                     `( (= ,(Nfe-xfp `(the ,texp1 ,id))
                         (mref-t
			  ,texp1 
			  ,(if return-p
			       '(fref efp -> argp)
			       'argp)) )))
	     )))

;;; type.ruleの変換により、expressionのS式は必ずtheで始まるようになってる
;;; 入れ子関数内では、identifierを親関数のフレーム構造体のメンバ参照に
;;; 変える必要がある。
(Nfe (the ,@rem))
-> (list nil nil nil (Nfe-xfp x))
;;; c-exp
(Nfe (c-exp ,str ,@rem))
-> (list nil nil nil `(c-exp ,str ,@(mapcar #'Nfe-xfp rem)))

(Nfe ,otherwise)
-> '$not-expression

;;; Nfe-xfp:
;;; ＊ 入れ子関数内における親関数の変数への参照を xfp->idの形に置き換える
;;; ＊ ポインタを獲得しているローカル変数への参照を efp->id に置き換える
;;; ＊ 入れ子関数への参照を明示的スタックへの参照に置き換える
(Nfe-xfp (the ,texp ,id[ID]) )
-> (multiple-value-bind (n-up kind) (howmany-outer id)
     (case kind
       ((:var)
        (cond 
          ;; 親関数のid -- "xfp->..."
          ((> n-up 0)
           `(fref 
             ,@(apply #'append
                      (make-list n-up :initial-element '(xfp ->)) )
             ,id))
          ;; 明示的スタックに置かれたもの -- "efp->... "
          ((estack-variable-p id)
           `(the ,texp (fref efp -> ,id)) )
          ;; その他．処理不要
          (t `(the ,texp ,id)) ))
       ((:nestfunc)
        (cond
          ((> n-up 0)
           `(ptr (fref
                  ,@(apply #'append
                           (make-list n-up :initial-element '(xfp ->)) )
                  ,id)) )
          (t
           `(ptr (fref efp -> ,id))) ))
       ((nil)     ; 処理不要
        `(the ,texp ,id) )
       (otherwise
        (error "unknown kind of var (~s)." kind)) )) 

(Nfe-xfp (the ,texp (fref ,exp ,@exp-list)) )
-> `(the ,texp (fref ,(Nfe-xfp exp) ,@exp-list))
(Nfe-xfp (the ,texp (,op ,@list)) )
-> `(the ,texp (,op ,@(mapcar #'Nfe-xfp list)))
(Nfe-xfp (c-exp ,str ,@rem))
-> `(c-exp ,str ,@(mapcar #'Nfe-xfp rem))

(Nfe-xfp ,otherwise)
-> otherwise

;;; expression-with-typeinfo からtype-expressionを得る。
(Nf-gettype (the ,texp ,exp))
-> texp
(Nf-gettype ,otherwise)
-> (error "Nf-gettype: ~s is not expression." x)

;;; bodyを受け取って、ptrでポインタを獲得している変数名のリストを返す
(Nf-search-ptr (,@body))
-> (remove-duplicates 
    (mapcan #'Nf-search-ptr1 body)
    :test #'string=)

(Nf-search-ptr1 (the ,texp1 (ptr (the ,texp2 ,exp))))
-> (let ((cid nil))
     (cond ((setq cid (identifier-sc2c exp))
	    ;;(print x)
	    (list cid))
	   ((listp exp)
	    (mapcan #'Nf-search-ptr1 `(the ,texp2 ,exp)))
	   (t
	    nil)))

(Nf-search-ptr1 (the ,texp1 (fref ,exp-t ,@rem)))
-> (Nf-search-ptr1 exp-t)

(Nf-search-ptr1 (,@list))
-> (mapcan #'Nf-search-ptr1 list)

(Nf-search-ptr1 ,otherwise)
-> nil

