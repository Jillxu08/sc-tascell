;;;temporary variableを使って、関数呼び出しが部分式にならないようにする。
:lisp-begin
(defpackage "TMP"
  (:use "SCT-USER" "CL"))
(in-package "TMP")

(defvar *used-identifier* nil) 
(defvar *prev-continue* nil)
(defvar *subexpression* nil)

(scr:require "TMP-DEFS")

;; ((a b c)(x y z)(m n p)...)->((a x m)(b y n)(c z p)) 
(defun comb-list (list)
  (let ((y1 nil)(y2 nil)(y3 nil))
    (dolist (x list (list y1 y2 y3))
      (setq y1 (append y1 (first x))
            y2 (append y2 (second x))
            y3 `(,@y3 ,(third x)))))) 
:lisp-end

(Tmp0 (,@decl-list))
->(progn
    (let ((*used-identifier* (get-all-identifier x))
	  (*prev-continue* nil))
      (mapcar #'Tmp1 x)))

;;;;

(Tmp1 (,scs[SCS] (,@id-list[ID]) (fn ,@texp-list) ,@body))
(Tmp1 (,scs[SCS] (,@id-list[ID]) (lightweight ,@texp-list) ,@body))
-> (let* ((fntag (car (third x)))
	  (tmpbody (Tmp2 body))
	  (newdecl (first tmpbody))
	  (newbody (second tmpbody)))
     `(,scs (,@id-list) (,fntag ,@texp-list) ,@newdecl ,@newbody ))

(Tmp1 ,otherwise)
-> otherwise

(Tmp1 nil)
-> nil

;;;;

; function-attribute & register-decl
(Tmp2 (:attr ,atr ,@body))
-> (let ((tmp2-body (Tmp2 body)))
     (list (first tmp2-body)
	   `(:attr ,atr (second tmp2-body)))) 

(Tmp2 ((register ,@regarg) ,@body))
-> (let ((tmp2-body (Tmp2 body)))
     (list (first tmp2-body)
	   `((register ,@regarg) (second tmp2-body))))

(Tmp2 (,@item-list))
-> (let* ((tmp-item-list (mapcar #'Tmp item-list))
	  (decl-list (apply #'append (mapcar #'first tmp-item-list)))
	  (prev-stat (apply #'append 
                     (mapcar #'(lambda (x) `(,@(second x) ,(third x)))
                             tmp-item-list))))
	 ; (append decl-list prev-stat))
     `(,decl-list  ,prev-stat))


;;;;

; begin
(Tmp (begin ,@body))
->(let ((tmpbody (Tmp2 body)))
    `(nil nil (begin ,@(first tmpbody) ,@(second tmpbody))))

; label
(Tmp (label ,id[ID] ,stat))
->(let ((tmpstat (Tmp stat)))
    `(,(first tmpstat) 
      ,(cons `(label ,id ,nil) (second tmpstat)) 
      ,(third tmpstat)) )

; case
(Tmp (case ,exp))
->(let ((tmpexp (Tmp-subexp exp)))
    `(,(first tmpexp) ,(second tmpexp) (case ,(third tmpexp))))

; default
(Tmp (default))
-> `(nil nil ,x) 

; if 
(Tmp (if ,exp ,stat1))
(Tmp (if ,exp ,stat1 ,stat2))
-> (let* ((stat2 (if (pattern-variable-p 'stat2) stat2 nil))
          (tmpexp (Tmp-subexp exp))
          (tmpstat1 (Tmp stat1))
          (tmpstat2 (if stat2 (Tmp stat2) nil))
          (def-exp (first tmpexp))
          (def-stat1 (first tmpstat1))
          (def-stat2 (first tmpstat2))
          (newstat1 
           (if (or def-stat1 (second tmpstat1))
               `(begin ,@def-stat1 ,@(second tmpstat1) ,(third tmpstat1))
               (third tmpstat1)))
          (newstat2
           (if (or def-stat2 (second tmpstat2))
               `(begin ,@def-stat2 ,@(second tmpstat2) ,(third tmpstat2))
               (third tmpstat2))) )
     `(,def-exp 
       ,(second tmpexp)
       (if ,(third tmpexp) ,newstat1 ,newstat2)))

; switch
(Tmp (switch ,exp ,@body))
-> (let ((tmpexp (Tmp-subexp exp))
	 (tmpbody (Tmp2 body)))
     `(,(first tmpexp)
       ,(second tmpexp) 
       (switch ,(third tmpexp) 
        ,@(first tmpbody)
        ,@(second tmpbody))))

; do-while
(Tmp (do-while ,exp ,@body))
->(let* ((tmpexp (Tmp-subexp exp))
	 (*prev-continue* (second tmpexp))
	 (tmpbody (Tmp2 body)))
    `(,(first tmpexp) 
      nil
      (do-while ,(third tmpexp) 
        ,@(first tmpbody)
        ,@(second tmpbody)
        ,@*prev-continue*)))

; continue
(Tmp (continue))
-> `(nil ,*prev-continue* ,x)

; goto, break 
(Tmp (goto ,id))
(Tmp (break))
->  `(nil nil ,x)

; return
(Tmp (return ,@exp))
-> (if (null exp)
       `(nil nil (return))
	(let ((tmpexp (Tmp-subexp (car exp))))
	  `(,(first tmpexp) ,(second tmpexp) (return ,(third tmpexp)))))

;;; <- マルチスレッド用プリミティブ

(Tmp (thread-create ,decl-list ,@body))
-> (let* ((tmpbody (Tmp2 body))
          (add-decl (first tmpbody))
          (newbody (second tmpbody)))
    (list nil nil `(thread-create ,(append decl-list add-decl) ,@newbody)))

(Tmp (thread-suspend ,var ,@body))
-> `(nil nil (thread-suspend ,var ,@body))

(Tmp (thread-resume ,exp))
->(let ((tmpexp (Tmp-subexp exp)))
   `(,(first tmpexp) ,(second tmpexp) (thread-resume ,(third tmpexp))))

;;; マルチスレッド用プリミティブ

(Tmp nil)
-> (list nil nil nil)

; expression-statement or declaration
(Tmp ,otherwise)
->(let ((exps (Tmpe x)))
    (if (eq '$NOT-EXPRESSION exps)
	(list (list (Tmp1 x)) nil)
	exps))

;;;;;;	 

(Tmp-subexp ,subexp)
-> (let ((*subexpression* t))
     (Tmp subexp))

; exp
(Tmpe (the ,texp ,exp[ID]))
(Tmpe (the ,texp ,exp[integerp]))
(Tmpe (the ,texp ,exp[characterp]))
(Tmpe (the ,texp ,exp[numberp]))
(Tmpe (the ,texp ,exp[stringp]))
-> `(nil nil (the ,texp ,exp))

; aref
(Tmpe (the ,texp1 (aref ,exp1 ,exp2)))
->(let* ((tmpexp1 (Tmp-subexp exp1))
	 (tmpexp2 (Tmp-subexp exp2)))
    `(,(append (first tmpexp1) (first tmpexp2))
      ,(append (second tmpexp2) (second tmpexp2))
      (the ,texp1 (aref ,(third tmpexp1) ,(third tmpexp2)))))

; fref
(Tmpe (the ,texp (fref ,exp ,id)))
->(let* ((tmpexp (Tmp-subexp exp))
	 (defexp (append (first tmpexp)))
	 (bindinfo (append (second tmpexp))))
     `(,defexp ,bindinfo (the ,texp (fref ,(third tmpexp) ,id))))

; inc, dec, ++, --, unary-operator, bit-not
(Tmpe (the ,texp (inc ,exp)))
(Tmpe (the ,texp (dec ,exp)))
(Tmpe (the ,texp (++ ,exp)))
(Tmpe (the ,texp (-- ,exp)))
(Tmpe (the ,texp (bit-not ,exp)))
(Tmpe (the ,texp (/ ,exp)))
(Tmpe (the ,texp (+ ,exp)))
(Tmpe (the ,texp (- ,exp)))
->(let* ((op (caaddr x))
	 (tmpexp (Tmp-subexp exp))
	 (bindinfo (append (second tmpexp)))
	 (defexp (append (first tmpexp))))
    `(,defexp ,bindinfo (the ,texp (,op ,(third tmpexp)))))

; ptr
(Tmpe (the ,texp (ptr ,exp)))
-> (let* ((tmpexp (Tmp-subexp exp))
    	  (defexp (first tmpexp))
	  (bindinfo (second tmpexp)))
     `(,defexp ,bindinfo (the ,texp (ptr ,(third tmpexp)))))

; mref
(Tmpe (the ,texp (mref ,exp)))
->(let* ((tmpexp (Tmp-subexp exp))
	 (defexp (first tmpexp))
	 (bindinfo (second tmpexp)))
    `(,defexp ,bindinfo (the ,texp (mref ,(third tmpexp)))))

; not
(Tmpe (the ,texp (not ,exp)))
->(let* ((tmpexp (Tmp-subexp exp))
	 (defexp (first tmpexp))
	 (bindinfo (second tmpexp)))
    `(,defexp ,bindinfo (the ,texp (not ,(third tmpexp)))))

; sizeof???
(Tmpe (the ,texp (sizeof (the ,texp ,exp0))) )
(Tmpe (the ,texp (sizeof ,texp)))
-> `(nil nil (the int (sizeof ,texp)))

; cast
(Tmpe (the ,texp1 (cast ,texp2 ,exp)))
->(let* ((tmpexp (Tmp-subexp exp))
 	 (defexp (append (first tmpexp) nil))
	 (bindinfo (append (second tmpexp) nil)))
   `(,defexp ,bindinfo (the ,texp1 (cast ,texp2 ,(third tmpexp)))))

; if-exp 
(Tmpe (the ,texp (if-exp ,exp1 ,exp2 ,exp3)))
-> (let* ((tmpexp1 (Tmp-subexp exp1))
	  (tmpexp2 (Tmp-subexp exp2))
	  (tmpexp3 (Tmp-subexp exp3))
	  (defexp (append (first tmpexp1) (first tmpexp2) (first tmpexp3)))
	  (bindinfo (append (second tmpexp1)))
	  (texp2 (second tmpexp2))
	  (texp3 (second tmpexp3))	
	  (void-p (eq 'void texp))
	  (result-id 
	   (if void-p nil (generate-id "ifexp_result" *used-identifier*)))
	  (defexp1 (if void-p '() (list `(def ,result-id ,texp))))
	  (ass-exp2 (if void-p
			(list (third tmpexp2))
			(list `(the ,texp2 (= (the ,texp ,result-id) 
					    ,(third tmpexp2))))))
	  (ass-exp3 (if void-p
		        (list (third tmpexp3))
			(list `(the ,texp3 (= (the ,texp ,result-id)
					    ,(third tmpexp3))))))
	  (result-exp (if void-p '(the int 0) `(the ,texp ,result-id))))
     (if (not (or (first tmpexp2)
		  (first tmpexp3)
		  (second tmpexp2)
		  (second tmpexp3)))
	 `(,defexp
	   ,bindinfo
	   (the ,texp (if-exp ,(third tmpexp1) ,exp2 ,exp3)))
	 `((,@defexp ,@defexp1)
	   (,@bindinfo 
	    (if ,(third tmpexp1) 
		(begin
		 ,@(second tmpexp2)
		 ,@ass-exp2)
		(begin
		 ,@(second tmpexp3)
		 ,@ass-exp3)))
	   ,result-exp)))

; and 
(Tmpe (the ,texp (and ,exp1 ,exp2)))
-> (Tmp-subexp `(the ,texp (if-exp ,exp1
		      (the int (if-exp ,exp2 (the int 1) (the int 0)))
		      (the int 0))))

; or
(Tmpe (the ,texp (or ,exp1 ,exp2)))
-> (Tmp-subexp `(the ,texp (if-exp ,exp1
		      (the int 1)
		      (the int (if-exp ,exp2 (the int 1) (the int 0))))))

; call 
(Tmpe (the ,texp (call ,fexp ,@arg-list)))
-> (cond
     ((not *subexpression*)
      (let* ((tmpexps (comb-list (mapcar #'Tmp-subexp arg-list))) 
	     (defexp (append (first tmpexps)))
	     (bindinfo (append (second tmpexps)))
	     (ret-third `(the ,texp (call ,fexp ,@(third tmpexps)))))
	`( ,defexp ,bindinfo ,ret-third )))
     (t
      (let* ((void-p (eq 'void texp))
	     (tmpexps (comb-list (mapcar #'Tmp-subexp arg-list))) 
	     (tempid (generate-id "tmp" *used-identifier*))
	     (defexp1 (if void-p '() `(def ,tempid ,texp)))
	     (defexp (append (first tmpexps) `(,defexp1)))
	     (call-exp `(the ,texp (call ,fexp ,@(third tmpexps))))
	     (bindinfo1
	      (if void-p
		  call-exp
		  `(the ,texp (= (the ,texp ,tempid) ,call-exp)) ))
	     (bindinfo (append (second tmpexps) `(,bindinfo1)))
	     (repl-exp (if void-p '(the int 0) `(the ,texp ,tempid))))
	`( ,defexp ,bindinfo ,repl-exp ))))

; operators

;; もともと (= a (f x)) の形のものは変形しないように細工
(Tmpe (the ,texp (= (the ,idtexp ,id[ID]) ,exp2)))
-> (let ((tmpe-exp2 (Tmpe exp2)))    ; Tmp-subexp でなくてよい
     `(,(first tmpe-exp2)
       ,(second tmpe-exp2)
       (the ,texp (= (the ,idtexp ,id)
                     ,(third tmpe-exp2)))) )

(Tmpe (the ,texp (* ,exp1 ,exp2)))
(Tmpe (the ,texp (/ ,exp1 ,exp2)))
(Tmpe (the ,texp (% ,exp1 ,exp2)))
(Tmpe (the ,texp (+ ,exp1 ,exp2)))
(Tmpe (the ,texp (- ,exp1 ,exp2)))
(Tmpe (the ,texp (bit-xor ,exp1 ,exp2)))
(Tmpe (the ,texp (bit-and ,exp1 ,exp2)))
(Tmpe (the ,texp (bit-or ,exp1 ,exp2)))
(Tmpe (the ,texp (<< ,exp1 ,exp2)))
(Tmpe (the ,texp (>> ,exp1 ,exp2)))
(Tmpe (the ,texp (<<= ,exp1 ,exp2)))
(Tmpe (the ,texp (>>= ,exp1 ,exp2)))
(Tmpe (the ,texp (bit-and= ,exp1 ,exp2)))
(Tmpe (the ,texp (bit-xor= ,exp1 ,exp2)))
(Tmpe (the ,texp (bit-or= ,exp1 ,exp2)))
(Tmpe (the ,texp (< ,exp1 ,exp2)))
(Tmpe (the ,texp (> ,exp1 ,exp2)))
(Tmpe (the ,texp (<= ,exp1 ,exp2)))
(Tmpe (the ,texp (>= ,exp1 ,exp2)))
(Tmpe (the ,texp (== ,exp1 ,exp2)))
(Tmpe (the ,texp (!= ,exp1 ,exp2)))
(Tmpe (the ,texp (= ,exp1 ,exp2)))
(Tmpe (the ,texp (*= ,exp1 ,exp2)))
(Tmpe (the ,texp (/= ,exp1 ,exp2)))
(Tmpe (the ,texp (&= ,exp1 ,exp2)))
(Tmpe (the ,texp (+= ,exp1 ,exp2)))
(Tmpe (the ,texp (-= ,exp1 ,exp2)))
-> (let ((op (caaddr x))
	 (tmpe-exp1 (Tmp-subexp exp1))
	 (tmpe-exp2 (Tmp-subexp exp2)))
     `(,(append (first tmpe-exp1) (first tmpe-exp2))
       ,(append (second tmpe-exp1) (second tmpe-exp2))
       (the ,texp (,op ,(third tmpe-exp1) ,(third tmpe-exp2)))))

; exps
(Tmpe (the ,texps (exps ,@exp-list)))
-> (let* ((tmpe-exps (mapcar #'Tmp-subexp exp-list))
	  (butlast-tmpe-exps (butlast tmpe-exps))
	  (clast-tmpe-exps (car (last tmpe-exps))))
     `(,(apply #'append (mapcar #'first tmpe-exps))
       ,(append (apply #'append 
		       (mapcar #'(lambda (x) `(,@(second x) ,(third x)))
			       butlast-tmpe-exps))
		(second clast-tmpe-exps))
       ,(third clast-tmpe-exps)))

; c-exp
(Tmpe (c-exp ,str ,@exp-list))
-> (let* ((tmpe-exps (mapcar #'Tmp-subexp exp-list)))
     (list
      (apply #'append (mapcar #'first tmpe-exps))
      (apply #'append (mapcar #'second tmpe-exps))
      `(c-exp ,str ,@(mapcar #'third tmpe-exps))))
 
(Tmpe ,otherwise)
-> '$NOT-EXPRESSION

