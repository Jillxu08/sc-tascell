;; HSC -> SC-0 (with nested-functions)
;;
;; Written by Akinori Tomobayashi (Feb, 2006)
;; 

:lisp-begin
(defpackage "GC"
  (:use "SCT-USER" "CL" "SC-UTIL" "SC-MISC"))
(in-package "GC")



(defparameter desc-id (generate-id "DESC"))

;各関数の中身はこの変数に入れて、まとめて出力する
(defvar *all-in-the-function* nil)
;newが作った仮の変数名と、その型名によって作られたdef文のリスト
(defvar *temp-def-list-newstruct* nil)
(defvar *temp-def-list-newarray* nil)

;nestfunc機能のon/off
(defvar *nestfn-tag* nil)

;使った名前を記憶
(defvar *used-identifier* nil) 

;def,declの部分が終わったらこれが1になる
(defvar *flag* nil)

;mainでscan0のかわりにreturnを出力するために使う
(defvar *main* nil)

;new(struct)のために使う。
(defvar *struct-sname-member* nil)
(defvar *temp-struct-sname-member* nil)

;descriptor用
(defvar *desc-list* nil)

;offsetof用
(defvar *of-name* nil)
(defvar *of-type* nil)

(defun make-offsetof (type namelist)
  (if (not (eq nil namelist))
      (progn
	(cons
	 `(offsetof ,type ,(car namelist))
	 (make-offsetof type (cdr namelist))))))

;型と名前をくっつけてリストにする
(defvar *name-type-list* nil)
(defvar *def-move-name-list* nil)

(defun make-name-type-set (namelist typelist)
  (if (not (eq nil typelist))
      (progn
	(cons
	 `(,(car namelist) ,(car typelist))
	 (make-name-type-set (cdr namelist) (cdr typelist))))))

;move関数を書くための関数
(defun make-move (inputlist)
  (if (not (eq nil inputlist))
      (cons
       (if (not (eq nil (car inputlist)))
       `(= ,(car inputlist) (csym::move ,(car inputlist))))
       (make-move (cdr inputlist)))))

;型と_dをリストにする関数
(defun make-d (type list)
  (if (eq nil list)
      nil
      (if (eq type (caar list))
	  (cadar list)
	  (make-d type (cdr list)))))


;new(struct) 製作用
(defun make-new-struct (name type struct-name-member-list value-list)
  (if (or (equal struct-name-member-list nil)
	  (equal value-list              nil)
	  )
      nil
      (if (eq (second type) (second (caar struct-name-member-list)))
	  (give-value name (cdar struct-name-member-list) value-list)
	  (make-new-struct name type (cdr struct-name-member-list) value-list)
	  )))

(defun give-value (name list1 list2)
    (if (or (eq list1 nil)
	    (eq list2 nil))
	nil
	`((= (fref (mref ,name) ,(car list1)) ,(car list2))
	  ,@(give-value name (cdr list1) (cdr list2)))))

:lisp-end

;;;
(G0 ,all-list)
 -> (let (
	  (*desc-list* nil)
	  (*struct-sname-member* nil)
	  (*nestfn-tag* (if (member :changefn *parameters*) 'fn 'lightweight))
	  (*used-identifier* (get-all-identifier x))
	  )
      (list*
       '(%include "mygc-macroheader.sh")
       (mapcan #'G1 all-list)
       )
      )

;main,function  -- scan1 & move --
;csym::なら何もしない
(G1 (def (,fname ,@arg-list) (fn ,@arg-type-list) ,@contents))
 -> (let (
	  (*all-in-the-function* nil)
	  (*temp-def-list-newstruct* nil)
	  (*temp-def-list-newarray* nil)
	  (*name-type-list* nil)
	  (*def-move-name-list* nil)
	  (*flag* nil)
	  (*main* nil)
	  )
     (list
      (progn
	(if (eq fname 'main)
	    (progn
	      (setq *main* t)
	      (setq *all-in-the-function* 
		    `(def (,fname ,@arg-list)
		      (fn ,@arg-type-list)
		      ,@(mapcan #'G3 contents)
		      )
		    )
	      (prog2
		  (setq *all-in-the-function* 
			`(,(car *all-in-the-function*) 
			  ,(cadr *all-in-the-function*)
			  ,(caddr *all-in-the-function*)
			  ,@*temp-def-list-newstruct* 
;			  ,@*temp-def-list-newarray* 
			  ,@(cdddr *all-in-the-function*)))
		  *all-in-the-function*
		(setq *main* nil)
		)
  	      );main
	    (if (cid-p fname)
		x
		(progn
		  (setq *name-type-list* (make-name-type-set arg-list (cdr arg-type-list)));arg-listからmove対象を調べる(mainでは行わない)
		  (setq *all-in-the-function*
			`(def (,fname scan0 ,@arg-list)
			  (fn ,(car arg-type-list) sht ,@(cdr arg-type-list))
			  ,@(mapcan #'G3 contents)
			  ));function(not main)
		  (setq *all-in-the-function* 
			`(,(car *all-in-the-function*)
			  ,(cadr *all-in-the-function*) 
			  ,(caddr *all-in-the-function*)
			  ,@*temp-def-list-newstruct*
;			  ,@*temp-def-list-newarray* 
			  ,@(cdddr *all-in-the-function*)))
		  *all-in-the-function*
		  )
		)
	    ))))
;struct
(G1 (def (struct ,sname) ,@struct-member))
 -> (let ( 
	  (*of-name* nil)
	  (*of-type* nil)
	  (struct-sname nil)
	  (*temp-struct-sname-member* nil)
	  (*sname-node* nil)
	  (*sname-d* nil)
	  (add-desc-t nil)
	  )
      (remove nil
	      (list
	       (prog1
		   (progn
		     (setq struct-sname (list 'struct sname))
		     (setq *temp-struct-sname-member* (cons struct-sname *temp-struct-sname-member*))
		     (if (not (cid-p sname))
			 (setq add-desc-t `(def d desc_t))
			 );snameがcsym::なら追加されない
		     (remove nil
			     `(def (struct ,sname)
			       ,add-desc-t
			       ,@(mapcar #'G2 struct-member)
			       )
			     )
		     )
		 
		 (setq *sname-node* 
		       (generate-id (string+ (identifier-sc2c sname) "_node")))
		 (setq *sname-d* 
		       (generate-id (string+ (identifier-sc2c sname) "_d")))
		 (setq *desc-list* (cons (list sname *sname-d*) *desc-list*))
		 (setq *temp-struct-sname-member* (reverse *temp-struct-sname-member*))
		 (setq *struct-sname-member* (cons *temp-struct-sname-member* *struct-sname-member*))
		 )
	       (if (not (cid-p sname))
		   `(def ,*sname-node* (array size_t) (array ,@(make-offsetof struct-sname (reverse *of-name*))))
		   )
	       (if (not (cid-p sname))
		   `(def ,*sname-d* descriptor (,desc-id (struct ,sname) ,*sname-node*))
		   )
	       )))

;mygc-header.shを入れるために(def xyzzy int)のマッチをする
(G1 (def xyzzy int))
 -> (list '(%include "mygc-header.sh"))
;otherwise
(G1 ,otherwise)
 -> (list x)

      
;structの定義に出てくるポインタを記憶する
;また、名前を記憶する。
(G2 (def ,name (ptr ,type) ,@value))
 -> (let ((ptr-plus-type nil))
      (progn
	(setq *temp-struct-sname-member* (cons name *temp-struct-sname-member*))
	(setq *of-name* (cons name *of-name*))
	(setq *of-type* (cons type *of-type*))
	x)
      )
(G2 (def ,name ,type))
(G2 (decl ,name ,type))
(G2 (def ,name ,type ,value))
(G2 (decl ,name ,type ,value))
 -> (progn
      (setq *temp-struct-sname-member* (cons name *temp-struct-sname-member*))
      x))
(G2 ,otherwise)
 -> (list x)


;defの部分では、ptrならmoveの対象になり、make-move関数を呼び出してmoveを書く。
;def以外ではそのまま返す。
;ptrなら全部たどる
;def-ptr,decl-ptr
(G3 (def ,name (ptr ,type) ,@value))
(G3 (decl ,name (ptr ,type) ,@value))
 -> (progn
      (if (not (cid-p name))
	  (setq *def-move-name-list* (cons name *def-move-name-list*)))
      (list x)
      );ptrならmove対象としてリストに加える。csym::がついていたらmove対象から外す。
;def
(G3 (def ,name ,type))
(G3 (def ,name ,type ,value))
 -> (list x)
;decl
(G3 (decl ,name ,type))
(G3 (decl ,name ,type ,value))
 -> (list x)
;otherwise(def,decl以外)
(G3 ,otherwise)
 -> (if (eq *flag* nil)
	(let (
	      (tempmove nil)
	      )
	  (progn
	    (setq *flag* t)
	    (setq tempmove (remove nil `(
					 def (scan1) (,*nestfn-tag* void void)
		 			 ,@(make-move (mapcar #'G4 *name-type-list*));関数の引数
					 ,@(make-move *def-move-name-list*)          ;ポインタ
					 )
				   ))
	    (if (eq *main* t)
		(list
		 `(def gctp int)
		 `(,@tempmove (return))
		 `(= gctp (if-exp (> argc 3) (csym::atoi (aref argv 3)) 0))
		 `(csym::gc-init (if-exp (< gctp 0) 0 gctp)
		   (if-exp (> argc 4) (csym::atoi (aref argv 4)) 0) 
		   (if-exp (> argc 5) (csym::atoi (aref argv 5)) 0) 
		   (if-exp (> argc 6) (csym::atoi (aref argv 6)) 0)
		   )
		 (G5 x)
		 );main
		(list
		 `(,@tempmove (scan0))
		 (G5 x)
		 );not main
		)))
	(list (G5 x))
	)


;ポインタなら型の名前を記憶する
;ptrなら全部たどる
(G4 (,name (ptr ,type)))
 -> name
(G4 ,otherwise)
 -> '()


	      
;(while expression block-item-list-opt)
(G5 (while ,exp ,@body))
 -> `(while ,exp ,@(mapcar #'G5 body))
;(do-while expression block-item-list-opt)
(G5 (do-while ,exp ,@body))
 -> `(do-while ,exp ,@(mapcar #'G5 body))
;(begin block-item-list-opt)
(G5 (begin ,@body))
 -> (remove nil `(begin ,@(mapcar #'G5 body)))
;(switch expression block-item-list-opt)
(G5 (switch ,exp ,@body))
 -> `(switch ,exp ,@(mapcar #'G5 body))
;(case expression)
(G5 (case ,exp))
 -> `(case ,exp)
;(default)
(G5 (default))
 -> '(default)
;(return expression-opt)
(G5 (return))
-> (G5 '(return ()))
(G5 (return ,exp))
 -> (remove nil `(return ,(G5 exp)))
;(if expression statement statement-opt)
(G5 (if ,exp ,stat1))
 -> `(if ,(G5 exp) ,(G5 stat1))
(G5 (if ,exp ,stat1 ,stat2))
 -> `(if ,(G5 exp) ,(G5 stat1) ,(G5 stat2))
;(for (expression-list-opt expression expression) block-item-list-opt)
(G5 (for (,exp1 ,exp2) ,@body))
 -> `(for (,(G5 exp1) ,(G5 exp2)) ,@(mapcar #'G5 body))
(G5 (for (,exp1 ,exp2 ,exp3) ,@body))
 -> `(for (,(G5 exp1) ,(G5 exp2) ,(G2 exp3)) ,@(mapcar #'G5 body))

;;Expressions
;new(struct)
(G5 (the ,new-texp (new (the ,init-texp (init ,type (struct ,@value-list))))))
 -> (let (
	  (type-d nil)
	  (g2-value-list nil)
	  (temp-obname nil)
	  )
      (progn
	(setq type-d (make-d (cadr init-texp) *desc-list*))
	(setq g2-value-list (mapcar #'G5 value-list))
	(setq temp-obname (generate-id "tmp_object" *used-identifier*))
	(setq *temp-def-list-newstruct* (cons `(def ,temp-obname (ptr ,init-texp)) *temp-def-list-newstruct*))
	`(exps
	  (= ,temp-obname (cast (ptr ,init-texp) (getmem scan1 (ptr ,type-d))))
	  ,@(make-new-struct temp-obname init-texp *struct-sname-member* value-list)
	  ,temp-obname
	  )
	)
      )
;new(array)
;(G5 (the ,new-texp (new (the ,init-texp (init (array ,type1 ,arsize) (array (the ,type2 ,default) ,@value-list))))))
; -> (let (
;	  (temp-arname nil)
;	  (temp-count nil)
;	  )
;      (progn
;	(setq temp-arname (generate-id "tmp_arname" *used-identifier*))
;	(setq temp-count (generate-id "tmp_count" *used-identifier*))
;	(setq *temp-def-list-newarray* (cons `(def ,temp-count int 0) *temp-def-list-newarray*))
;	(setq *temp-def-list-newarray* (cons `(def ,temp-arname (array ,type1 ,arsize)) *temp-def-list-newarray*))
;	`(exps
;	  `(do-while (,temp-count < ,arsize)
;	    (= (aref ,temp-arname ,temp-count) ,default)
;	    )
;	  ,temp-arname
;	  )
;	)
;      )
;(aref expression-list)
(G5 (the ,texp (aref ,exp1 ,@exp-list)))
 -> `(the ,texp (aref ,(G5 exp1) ,@(mapcar #'G5 exp-list)))
;(fref expression field-identifier-list) 
(G5 (the ,texp (fref ,exp ,@body))) 
 -> `(the ,texp (fref ,(G5 exp) ,@(mapcar #'G5 body)))
;(inc/dec/++/-- expression)  
(G5 (the ,texp (inc ,exp)))
 -> `(the ,texp (inc ,(G5 exp))) 
(G5 (the ,texp (dec ,exp))) 
 -> `(the ,texp (dec ,(G5 exp)))
(G5 (the ,texp (++ ,exp))) 
 -> `(the ,texp (++ ,(G5 exp))) 
(G5 (the ,texp (-- ,exp)))
 -> `(the ,texp (-- ,(G5 exp)))
;(unary-operator expression)
(G5 (the ,texp (ptr ,exp)))
 -> `(the ,texp (ptr ,(G5 exp)))
(G5 (the ,texp (mref ,exp)))
 -> `(the ,texp (mref ,(G5 exp)))
(G5 (the ,texp (bit-not ,exp)))
 -> `(the ,texp (bit-not ,(G5 exp)))
(G5 (the ,texp (not ,exp)))
 -> `(the ,texp (not ,(G5 exp)))
;(sizeof expression)
(G5 (the ,texp (sizeof ,exp)))
 -> `(the ,texp (sizeof ,(G5 exp)))
;(cast type-expression expression)
(G5 (the ,cast-texp (cast ,texp ,exp)))
 -> `(the ,cast-texp (cast ,texp ,(G5 exp)))
;(operator expression-list)
(G5 (the ,texp (* ,exp1 ,@exp-list)))
 -> `(the ,texp (* ,(G5 exp1) ,@(mapcar #'G5 exp-list)))
(G5 (the ,texp (/ ,exp1 ,@exp-list)))
 -> `(the ,texp (/ ,(G5 exp1) ,@(mapcar #'G5 exp-list)))
(G5 (the ,texp (% ,exp1 ,@exp-list)))
 -> `(the ,texp (% ,(G5 exp1) ,@(mapcar #'G5 exp-list)))
(G5 (the ,texp (+ ,exp1 ,@exp-list)))
 -> `(the ,texp (+ ,(G5 exp1) ,@(mapcar #'G5 exp-list)))
(G5 (the ,texp (- ,exp1 ,@exp-list)))
 -> `(the ,texp (- ,(G5 exp1) ,@(mapcar #'G5 exp-list)))
(G5 (the ,texp (<< ,exp1 ,@exp-list)))
 -> `(the ,texp (<< ,(G5 exp1) ,@(mapcar #'G5 exp-list)))
(G5 (the ,texp (>> ,exp1 ,@exp-list)))
 -> `(the ,texp (>> ,(G5 exp1) ,@(mapcar #'G5 exp-list)))
(G5 (the ,texp (bit-xor ,exp1 ,@exp-list)))
 -> `(the ,texp (bit-xor ,(G5 exp1) ,@(mapcar #'G5 exp-list)))
(G5 (the ,texp (bit-and ,exp1 ,@exp-list)))
 -> `(the ,texp (bit-and ,(G5 exp1) ,@(mapcar #'G5 exp-list)))
(G5 (the ,texp (bit-or ,exp1 ,@exp-list)))
 -> `(the ,texp (bit-or ,(G5 exp1) ,@(mapcar #'G5 exp-list)))
(G5 (the ,texp (and ,exp1 ,@exp-list)))
 -> `(the ,texp (and ,(G5 exp1) ,@(mapcar #'G5 exp-list)))
(G5 (the ,texp (or ,exp1 ,@exp-list)))
 -> `(the ,texp (or ,(G5 exp1) ,@(mapcar #'G5 exp-list)))
;(comparator expression expression)
(G5 (the ,texp (< ,exp1 ,exp2)))
 -> `(the ,texp (< ,(G5 exp1) ,(G5 exp2)))
(G5 (the ,texp (> ,exp1 ,exp2)))
 -> `(the ,texp (> ,(G5 exp1) ,(G5 exp2)))
(G5 (the ,texp (<= ,exp1 ,exp2)))
 -> `(the ,texp (<= ,(G5 exp1) ,(G5 exp2)))
(G5 (the ,texp (>= ,exp1 ,exp2)))
 -> `(the ,texp (>= ,(G5 exp1) ,(G5 exp2)))
(G5 (the ,texp (== ,exp1 ,exp2)))
 -> `(the ,texp (== ,(G5 exp1) ,(G5 exp2)))
(G5 (the ,texp (!= ,exp1 ,exp2)))
 -> `(the ,texp (!= ,(G5 exp1) ,(G5 exp2)))
;(if-exp expression expression expression)
(G5 (the ,texp (if-exp ,exp1 ,exp2 ,exp3)))
 -> `(the ,texp (if-exp ,(G5 exp1) ,(G5 exp2) ,(G5 exp3)))
;(assignment-operator expression expression)
(G5 (the ,texp (= ,exp1 ,exp2)))
 -> `(the ,texp (= ,(G5 exp1) ,(G5 exp2)))
(G5 (the ,texp (*= ,exp1 ,exp2)))
 -> `(the ,texp (*= ,(G5 exp1) ,(G5 exp2)))
(G5 (the ,texp (/= ,exp1 ,exp2)))
 -> `(the ,texp (/= ,(G5 exp1) ,(G5 exp2)))
(G5 (the ,texp (%= ,exp1 ,exp2)))
 -> `(the ,texp (%= ,(G5 exp1) ,(G5 exp2)))
(G5 (the ,texp (+= ,exp1 ,exp2)))
 -> `(the ,texp (+= ,(G5 exp1) ,(G5 exp2)))
(G5 (the ,texp (-= ,exp1 ,exp2)))
 -> `(the ,texp (-= ,(G5 exp1) ,(G5 exp2)))
(G5 (the ,texp (<<= ,exp1 ,exp2)))
 -> `(the ,texp (<<= ,(G5 exp1) ,(G5 exp2)))
(G5 (the ,texp (>>= ,exp1 ,exp2)))
 -> `(the ,texp (>>= ,(G5 exp1) ,(G5 exp2)))
(G5 (the ,texp (bit-and= ,exp1 ,exp2)))
 -> `(the ,texp (bit-and= ,(G5 exp1) ,(G5 exp2)))
(G5 (the ,texp (bit-xor= ,exp1 ,exp2)))
 -> `(the ,texp (bit-xor= ,(G5 exp1) ,(G5 exp2)))
(G5 (the ,texp (bit-or= ,exp1 ,exp2)))
 -> `(the ,texp (bit-or= ,(G5 exp1) ,(G5 exp2)))
;(exps expression-list)
(G5 (the ,texp (exps ,exp1 ,@exp-list)))
 -> `(the ,texp (exps ,exp1 ,@(mapcar #'G5 exp-list)))
;function call
(G5 (the ,ret-exp (call (the ,texp ,exp) ,@exp-list)))
 -> (if (cid-p exp)
	x;csym
	`(the ,ret-exp (call (the ,texp ,exp) scan1 ,@exp-list));not csym(general function)
	)
;(expression-list)
(G5 (the ,texp (,exp1 ,@exp-list)))
 -> `(the ,texp (,(G5 exp1) ,(mapcar #'G5 exp-list)))

;otherwise
(G5 ,otherwise)
 -> x

