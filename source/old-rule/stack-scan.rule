;;; stack-scan 
;;; n 回ごとにスタック情報を出力する．
;;; 要 type.rule

:lisp-begin
(defpackage "STACK-SCAN"
  (:nicknames "STSC")
  (:use "SCT-USER" "CL" "SC-MISC" "SC-UTIL"))
(in-package "STSC")

(defvar *current-func* nil)
(defconstant *scan0* 'scan0)  ; 呼び出し元のスキャン
(defconstant *scan1* 'scan1)  ; 自分自身のスキャン
(defparameter *nestfunc-tag* 'fn)
(defparameter *scan-type* `(ptr (,*nestfunc-tag* void void))) ; scan の型
(defparameter *scan-ftype* (second *scan-type*))
(defparameter *scan-start* 10) ; 何回の関数呼び出しごとにscan?
(defparameter *scan-increment* 3)

(defstruct (finfo (:constructor create-finfo (name)))
  (name nil :type symbol)
  (arg-list (list)  :type list)  ;; list of (<local-id> . <type>)
  (lvar-list (list) :type list)) ;; list of (<local-id> . <type>)

(defun make-nestfunc (&optional (cfunc *current-func*))
  (declare (type finfo cfunc))
  `(def (,*scan1*) ,*scan-ftype*
    (csym::printf ,(format nil "<~S " (finfo-name cfunc)))
    ,@(mapcar
       #'(lambda (id-type &aux (id (car id-type)) (type (cdr id-type)))
	   `(csym::printf ,(format nil "~S=0x%x " id) (cast int ,id)))
       (finfo-arg-list cfunc))
    (csym::printf ,(format nil ">~%"))
    ,@(mapcar 
       #'(lambda (id-type &aux (id (car id-type)) (type (cdr id-type)))
	   `(csym::printf ,(format nil "~S=0x%x~%" id) (cast int ,id)))
       (finfo-lvar-list cfunc))
    ,(if (eq 'main (finfo-name cfunc))
	 '(begin
	   (csym::printf "~%") 
	   (return))
	 `(,*scan0*))) )

;;; 関数型に引数を追加
(defun push-nestfunc-type (texp)
  (if (and (consp texp)
	   (or (eq 'fn (car texp))
	       (eq 'lightweight (car texp))))
      `(,(car texp) ,*scan-type* ,@(cdr texp))
      texp))
:lisp-end

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(program (,@decl-list))
-> (append
    `((def count int 0)
      (def scan-inc int ,*scan-increment*)
      (def scan-start int ,*scan-start*))
    (mapcar #'decl decl-list))

;;;;;;;;;; declaration
;;; variable definition / declaration
(decl (,scs[SCS] ,id[ID] ,texp {,init}))
-> (progn
     (when *current-func*
       (push (cons id texp) 
             (finfo-lvar-list *current-func*)))
     x)

;;; function definition
(decl (,scs[SCS] (,func-id ,@arg-id[ID]) (fn ,func-texp ,@arg-texp) ,@body))
-> (let* ((*current-func* (create-finfo func-id)))
     (mapc #'(lambda (id texp)
	       (push (cons id texp)
		     (finfo-arg-list *current-func*)))
	   arg-id arg-texp)
     (let ((new-body (bi-list0 body)))
       (if (eq 'main func-id)
	   `(,scs (,func-id ,@arg-id) (fn ,func-texp ,@arg-texp) ,@new-body)
	   `(,scs
	     (,func-id ,*scan0* ,@arg-id)
	     (fn ,func-texp ,*scan-type* ,@arg-texp)
	     ,@new-body) )))

(decl (,dd[DEF-DECL] (,soru[S-OR-U] ,id[ID]) ,@sdeclist))
(decl (def (enum ,id[ID]) ,@enum-list))
(decl (deftype ,id[ID] struclt ,@sdecllist))
(decl (deftype ,id[ID] enum ,@enum-list))
-> x
(decl (deftype ,id[ID] ,texp))
-> `(deftype ,id ,(push-nestfunc-type texp))

(decl ,otherwise)
-> (values x :non-decl)

;;;;;;;;;; body
(bi-list0 (:attr ,atr @body))
-> `(:attr ,atr ,@(bi-list0 body))
(bi-list0 ((register ,@regarg) ,@body))
-> `((register ,@regarg) ,@(bi-list0 body))
(bi-list0 ())
-> ()
(bi-list0 (,@body))
-> (multiple-value-bind (newdecl declp) (decl (car body))
     (if (eq :non-decl declp)
         `(,(make-nestfunc *current-func*)
           ,@(mapcar #'statement body))
         `(,newdecl ,@(bi-list0 (cdr body)))))

;;;;;;;;;; statement
;;; begin
(statement (begin ,@body) )
-> `(begin ,@(bi-list0 body))
;;; label
(statement (label ,id ,stat) )
-> `(label ,id ,(statement stat))
;;; case
(statement (case ,the-exp) )
-> `(case ,(the-expression the-exp))
;;; default
(statement (default))
-> `(case (default))
;;; if
(statement (if ,the-exp ,stat1 {,stat2}) )
-> (if (pattern-variable-p 'stat2)
       `(if ,(the-expression the-exp) ,(statement stat1) ,(statement stat2))
       `(if ,(the-expression the-exp) ,(statement stat1)))
;;; switch (exp から外にでるものはないはず)
(statement (switch ,the-exp ,@body) )
-> `(switch ,(the-expression the-exp) ,@(bi-list0 body))
;;; do-while (exp から外にでるものはないはず)
(statement (do-while ,the-exp ,@body) )
-> `(do-while ,(the-expression the-exp) ,@(bi-list0 body))
;;; goto, continue, break
(statement (goto ,id))
(statement (continue) )
(statement (break) )
-> x
;;; 返り値なしreturn
(statement (return) )
-> x
;;; return 
(statement (return ,the-exp) )
-> `(return ,(the-expression the-exp))
;;; null-statement
(statement nil)
-> x
(statement ,stat-the-exp)
-> (the-expression stat-the-exp)

;;;;;;;;;; expression
(the-expression (the ,texp ,exp))
-> `(the ,(push-nestfunc-type texp) ,(expression exp))

(expression (sizeof (the ,texp ,exp)))
-> `(sizeof ,(the-expression (second x)))
(expression (sizeof ,texp))
-> x

(expression (fref ,the-exp ,@fids))
-> `(fref ,(the-expression the-exp) ,@fids)

(expression (cast ,texp ,the-exp))
-> `(cast ,texp ,(the-expression the-exp))

(expression (call (the ,ftexp ,fexp) ,@the-args))
-> (let ((the-fexp (second x)))
     (if (and (symbolp fexp)
	      (eq c2sc:*clang-package* (symbol-package fexp)))
	 `(call ,the-fexp ,@(mapcar #'the-expression the-args))
	 `(exps
	   (if-exp (> (+= count scan-inc) scan-start)
	           (exps (-= count scan-start) (scan1))
	           0)
	   ((the ,(push-nestfunc-type ftexp) ,fexp)
	    ,*scan1*
	    ,@(mapcar #'the-expression the-args)))))
     
(expression (,op ,@the-exps))
-> `(,op ,@(mapcar #'the-expression the-exps))

(expression ,otherwise)
-> otherwise
