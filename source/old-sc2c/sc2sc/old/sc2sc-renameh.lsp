;;;
;;; hoistingの際名前が衝突しないようにリネーム
;;; let->begin, (for (decl...))->(begin decl (for ...)))に変更
;;;

(defconstant *iniv-postfix* "_init")

(defvar *local-id* nil)
(defvar *sync-id* nil)
(defvar *rename-list* nil) ;; (oldname(string) newname(symbol) valid(bool))

;;; <--------------------------------- 汎用
(defun get-new-id (&optional (basename "__sc2cid_") postfix)
  (let ((n 0) ns (ngname `(,@*local-id* ,@*sync-id*)))
    (unless (or (member basename ngname :test 'string=)
		(and postfix
		     (member (string+ `(,basename ,postfix))
			     ngname :test 'string=)))
      (return-from get-new-id basename))
    (loop
     (setq ns  (string+ `(,basename ,(write-to-string n))))
     (unless (or (member ns ngname :test 'string=)
		 (and postfix
		      (member (string+ `(,ns ,postfix))
			      ngname :test 'string=)))
       (return ns))
     (incf n))))

(defun id-to-scid (id)
  (let ((symstr "") (mode *print-case*))
    (dotimes (n (length id) (make-symbol symstr))
      (let ((idn (aref id n)))
	(cond
	  ((and (eq ':downcase mode)
		(upper-case-p idn))
	   (setq mode :upcase)
	   (add-string symstr (string+ `("@" ,idn))))
	  ((and (eq ':upcase mode)
		(lower-case-p idn))
	   (setq mode :downcase)
	   (add-string symstr (string+ `("@" ,idn))))
	  (t (add-string symstr (string idn))))))))

(defun push-sync-id (id)
  (when (and (stringp id) 
	     (not (member id *sync-id* :test #'string=)))
    (push id *sync-id*)))

(defun validate-rename (oldname)
  (setf (third (find oldname *rename-list* :key #'car :test #'string=)) t))
;;; 汎用 --------------------------------->

(defun renameh (x)
  (let ((*local-id* nil) (*sync-id* nil) (*rename-list* nil))
    (mapcar #'renameh-ext x)))

(defun renameh-ext (x &aux id)
(if (par-storage-class-specifier (car x)) `(,(car x) ,@(renameh-ext (cdr x))))
  (cond 
    ((setq id (par-function-identifier (car x)))
     (push-sync-id (car id))
     (if (and (listp (second x))
	      (eq 'fn (car (second x))))
	 (let ((*local-id* *sync-id*))
	   (renameh-fun x))
	 x))
    ((and (listp (car x))
	  (or (eq 'struct (caar x))
	      (eq 'union  (caar x))))
     (push-sync-id (par-identifier (cadar x)))
     x)
    ((and (listp (car x))
	  (eq 'enum (caar x)))
     (push-sync-id (par-identifier (cadar x)))
     (dolist (xi x x)
       (push-sync-id (if (listp xi)
			 (par-identifier (car xi))
			 (par-identifier xi)))))
    
    ((eq 'deftype (car x))
     (push-sync-id (par-identifier (cadr x)))
     (when (eq 'enum (caddr x))
       (dolist (xi (cdddr x))
	 (push-sync-id (if (listp xi)
			   (par-identifier (car xi))
			   (par-identifier xi)))))
     x)

    (t x)))

;; xはinlinedでないfunction宣言
(defun renameh-fun (x)
  (let ((*local-id* *local-id*)
	(*rename-list* *rename-list*)
	(*sync-id* nil) arg-list pbil bil)
    (when (listp (car x)) (setq arg-list (cdar x)))

    ;; block-item-list の獲得
    (setq pbil (cdr x))
    (when (eq ':attr (cadr pbil)) (setq pbil (cddr pbil)))
    (when (par-register-declarator (cadr pbil)) (setq pbil (cdr pbil)))
    (setq bil (cdr pbil))
    
    (get-decl-id bil (mapcar #'par-identifier arg-list))
    (when (listp (car x))
      (setf (car x)
	    (cons (caar x)
		  (mapcar 
		   #'(lambda (arg &aux (arg-id (par-identifier arg)))
		       (unless (member arg-id *sync-id* :test #'string=)
			 (push arg-id *sync-id*)
			 (validate-rename arg-id))
		       (exec-rename arg))
		    arg-list))))
    (rplacd pbil (renameh-bil bil))
    x))

(defun get-decl-id (bil &optional arg-id-list &aux id)
  (let ((*sync-id* *sync-id*))
    (dolist (arg-id arg-id-list)
      (push-sync-id arg-id))

    (dolist (bi bil id)
      (cond 
	((par-storage-class-specifier (car bi))
	 (cond
	   ;; variable, function
	   ((setq id (par-function-identifier (second bi)))
	    (push-sync-id (car id)))
	   ;; struct-or-union
	   ((and (listp (second bi))
		 (or (eq 'struct (car (second bi))
		     (eq 'union  (car (second bi))))))
	    (push-sync-id (par-identifier (cadr (second bi)))))
	   ;; enum
	   ((and (listp (second bi))
		 (eq 'enum (car (second bi))))
	    (push-sync-id (par-identifier (cadr (second bi))))
	    (dolist (en (cddr bi))
	      (push-sync-id (if (listp en)
				(par-identifier (car en))
				(par-identifier en)))))))
	;; defs
	((par-compound-storage-class-specifier (car bi))
	 (dolist (in (cddr bi))
	   (push-sync-id (if (listp in)
			     (par-identifier (car in))
			     (par-identifier in)))))
	;; deftype
	((eq 'deftype (car bi))
	 (push-sync-id (par-identifier (second bi)))
	 (when (eq 'enum (third bi))
	   (dolist (en (cdddr bi))
	     (push-sync-id (if (listp en)
			       (par-identifier (car en))
			       (par-identifier en))))))))
    (dolist (sid *sync-id*)
      (let ((newid (get-new-id sid *iniv-postfix*)))
	(push newid *local-id*)
	(push (string+ `(,newid ,*iniv-postfix*)) *local-id*)
	(unless (string= sid newid)
	  (push `(,sid ,(id-to-scid newid) ,nil) *rename-list*))))))


(defun renameh-bil (x)
  (mapcar 'renameh-bitem x))

(defun renameh-bitem (x &aux id)
  (when (not (listp x))
    (return-from rename-bitem `(,(exec-rename x))))
  
  (cond
    ((par-storage-class-specifier (car x))
     (cond
       ;; variable, function - decl
       ((setq id (par-function-identifier (second x)))
	(setq id (car id))
	(unless (member id *sync-id* :test #'string=)
	  (push id *sync-id*)
	  (validate-rename id))
	(if (and (listp (third x))
		 (eq 'fn (car (third x))))
	    (let ((fid (if (listp (second x))
			   (exec-rename (second x))
			   (cons (rename (car (second x))) (cdr (second x))))))
	       (cons (first x)
		     (renameh-fun `(,fid 
				    ,(exec-rename (third x)) ,@(cdddr x)))))
	    (exec-rename x)))
       ;; struct-or-union
       ((and (listp (second x))
	     (or (eq 'struct (car (second x)))
		 (eq 'union  (car (second x)))))
	(setq id (par-identifier (second (second x))))
	(unless (member id *sync-id* :test #'string=)
	  (push id *sync-id*)
	  (validate-rename id))
	`(,(first x) ,(exec-rename (second x)) ,@(cddr x)))
       ;; enum
       ((and (listp (second x))
	     (eq 'enum (car (second x))))
	(setq id (par-identifier (second (second x))))
	(unless (member id *sync-id* :test #'string=)
	  (push id *sync-id*)
	  (validate-rename id))
	(setf (second x) (exec-rename (second x)))
	(do ((el (cddr x) (cdr el))) ((endp el))
	  (setq id (par-identifier (if (listp (car el))
				       (caar el)
				       (car el))))
	  (unless (member id *sync-id* :test #'string=)
	    (push id *sync-id*)
	    (validate-rename id))
	  (setf (car el) (exec-rename (car el))))
	x)))
    ;; defs
    ((par-compound-storage-class-specifier (car x))
     (setf (second x) (exec-rename (second x)))
     (do ((il (cddr x) (cdr il))) ((endp il))
       (setq id (par-identifier (if (listp (car il))
				    (caar il)
				    (car il))))
       (unless (member id *sync-id* :test #'string=)
	 (push id *sync-id*)
	 (validate-rename id))
       (setf (car il) (exec-rename (car il))))
     x)
    ;; deftype
    ((eq 'deftype (car x))
     (setq id (par-identifier (second x)))
     (unless (member id *sync-id* :test #'string=)
       (push id *sync-id*)
       (validate-rename id))
     (case (third x)
       ((struct union) 
	`(deftype ,(exec-rename (second x)) ,@(cddr x)))
       ((enum)
	(do ((el (cdddr x) (cdr el))) ((endp el))
	  (setq id (par-identifier (if (listp (car el))
				       (caar el)
				       (car el))))
	  (unless (member id *sync-id* :test #'string=)
	    (push id *sync-id*)
	    (validate-rename id))
	  (setf (car el) (exec-rename (car el))))
	`(deftype ,(exec-rename (second x)) ,@(cddr x)))
       (otherwise
	(exec-rename x))))
    
    (t (renameh-stat x))))

(defun renameh-stat (x)
  (when (not (listp x))
    (return-from rename-stat `(,(exec-rename x))))

  (case (car x)
    ((begin)
     (let ((*sync-id* nil) (*rename-list* *rename-list*))
       (get-decl-id (cdr x))
       `(begin ,@(renameh-bil (cdr x)))))
    ((let)
     (when (listp (second x))
       (do ((dcl (second x) (cdr dcl))) ((endp dcl))
	 (let ((dc (car dcl)))
	   (when (and (listp dc)
		      (or (par-function-identifier (car dc))
			  (par-struct-or-union-specifier (car dc))
			  (par-enum-specifier (car dc))))
	     (setf (car dcl) (cons 'def dc))))))
     (renameh-stat `(begin ,@(second x) ,@(cddr x))))
    ((label)
     `(label ,(second x) ,(renameh-stat (third x))))
    ((case)
     `(case (exec-rename (second x))))
    ((if)
     `(if ,(exec-rename (second x)) ,@(mapcar #'renameh-stat (cddr x))))
    ((switch)
     (let ((sec (exec-rename (second x)))
	   (*sync-id* nil) (*rename-list* *rename-list*))
       (get-decl-id (cddr x))
       `(switch ,sec ,@(renameh-bil (cddr x)))))
    ((while)
     (let ((sec (exec-rename (second x)))
	   (*sync-id* nil) (*rename-list* *rename-list*))
       (get-decl-id (cddr x))
       `(while ,sec ,@(renameh-bil (cddr x)))))
    ((do-while)
     (let ((sec (exec-rename (second x)))
	   (*sync-id* nil) (*rename-list* *rename-list*))
       (get-decl-id (cddr x))
       `(do-while ,sec ,@(renameh-bil (cddr x)))))
    ((for)
     (if (par-inlined-declaration (car (second x)))
	 (renameh-stat
	  `(begin ,@(butlast (second x) 2)
	    (for ,(lastn (second x) 2) ,@(cddr x))))
	 (let ((sec (exec-rename (second x)))
	       (*sync-id* nil) (*rename-list* *rename-list*))
	   (get-decl-id (cddr x))
	   `(for ,sec ,@(renameh-bil (cddr x))))))
    ((loop)
     (let ((*sync-id* nil) (*rename-list* *rename-list*))
       (get-decl-id (cdr x))
       `(loop ,@(renameh-bil (cdr x)))))
    ((goto)
     x)
    ((return)
     (exec-rename x))
    (otherwise (exec-rename x))))

(defun exec-rename (x &aux id r)
  (if (listp x)
      (if (eq 'fref (car x))
	  `(fref ,(exec-rename (second x)) ,@(cddr x))
	  (mapcar #'exec-rename x))
      (if (and (setq id (par-identifier x)) 
	       (setq r (member id *rename-list* 
			       :key '(lambda (ren)
				      (if (third ren) (car ren) nil))
			       :test #'equal)))
	  (second (car r))
	  x)))
  
	   
      
 