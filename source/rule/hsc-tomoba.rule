;; HSC -> LW-SC
;;
;; Written by Akinori Tomobayashi (Feb, 2006)
;; 

(defparameter desc-id (generate-id "DESC"))

;各関数の中身はこの変数に入れて、まとめて出力する
(defvar *all-in-the-function* nil)
;newが作った仮の変数名と、その型名によって作られたdef文のリスト
(defvar *temp-def-list-newstruct* nil)
(defvar *temp-def-list-newarray* nil)

;nestfunc機能のon/off
(defvar *nestfn-tag* nil)

;def,declの部分が終わったらこれが1になる
(defvar *flag* nil)

;mainでscan0のかわりにreturnを出力するために使う
(defvar *main* nil)

;new(struct)のために使う。
(defvar *struct-sname-member* nil)
(defvar *temp-struct-sname-member* nil)

;descriptor用
(defvar *desc-list* nil)

;offsetof用
(defvar *of-name* nil)
(defvar *of-type* nil)

;型と名前をくっつけてリストにする
(defvar *name-type-list* nil)
(defvar *def-move-name-list* nil)

(scr:require "HSC-DEFS")

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(in-package "RULE")

(define-ruleset hsc (sc2c)
  (initiator 'sc-program)
  (nestfunc-tag ~lightweight))

;;;
(defrule sc-program hsc
  ((#?,all-list)
   (let ((*desc-list* nil)
	 (*struct-sname-member* nil)
	 (*nestfn-tag* (ruleset-param 'nestfunc-tag)))
     (list*
      ~(%include "mygc-macroheader.sh")
      (mappend #'declaration all-list))) )
  )

(defrule declaration hsc
  ;;main,function  -- scan1 & move --
  ;;csym::なら何もしない
  ((#?(def (,fname ,@arg-list) (fn ,@arg-type-list) ,@contents))
   (let ( (*all-in-the-function* nil)
	  (*temp-def-list-newstruct* nil)
	  (*temp-def-list-newarray* nil)
	  (*name-type-list* nil)
	  (*def-move-name-list* nil)
	  (*flag* nil)
	  (*main* nil) )
     (list
      (progn
	(if (eq fname ~main)
	    (progn
	      (setq *main* t)
	      (setq *all-in-the-function* 
		    ~(def (,fname ,@arg-list)
		      (fn ,@arg-type-list)
		      ,@(mapcan #'block-item contents)
		      )
		    )
	      (prog2
		  (setq *all-in-the-function* 
			~(,(car *all-in-the-function*) 
			  ,(cadr *all-in-the-function*)
			  ,(caddr *all-in-the-function*)
			  ,@*temp-def-list-newstruct* 
			   ;; ,@*temp-def-list-newarray* 
			  ,@(cdddr *all-in-the-function*)))
		  *all-in-the-function*
		(setq *main* nil)
		)
  	      );main
	    (if (cid-p fname)
		x
		(progn
		  (setq *name-type-list* (hsc:make-name-type-set arg-list (cdr arg-type-list)))
					;arg-listからmove対象を調べる(mainでは行わない)
		  (setq *all-in-the-function*
			~(def (,fname scan0 ,@arg-list)
			  (fn ,(car arg-type-list) sht ,@(cdr arg-type-list))
			  ,@(mapcan #'block-item contents)
			  )) ;function(not main)
		  (setq *all-in-the-function* 
			~(,(car *all-in-the-function*)
			  ,(cadr *all-in-the-function*) 
			  ,(caddr *all-in-the-function*)
			  ,@*temp-def-list-newstruct*
			   ;; ,@*temp-def-list-newarray* 
			  ,@(cdddr *all-in-the-function*)))
		  *all-in-the-function*
		  )
		)
	    )))) )
  ;;struct
  ((#?(def (struct ,sname) ,@struct-member))
   (let ( 
	  (*of-name* nil)
	  (*of-type* nil)
	  (struct-sname nil)
	  (*temp-struct-sname-member* nil)
	  (*sname-node* nil)
	  (*sname-d* nil)
	  (add-desc-t nil)
	  )
      (remove nil
	      (list
	       (prog1
		   (progn
		     (setq struct-sname (list ~struct sname))
		     (setq *temp-struct-sname-member* (cons struct-sname *temp-struct-sname-member*))
		     (if (not (cid-p sname))
			 (setq add-desc-t `(def d desc_t))
			 ) ;snameがcsym::なら追加されない
		     (remove nil
			     ~(def (struct ,sname)
			       ,add-desc-t
			       ,@(mapcar #'struct-declaration struct-member)
			       )
			     )
		     )
		 
		 (setq *sname-node* 
		       (generate-id (string+ (identifier sname) "_node")))
		 (setq *sname-d* 
		       (generate-id (string+ (identifier sname) "_d")))
		 (setq *desc-list* (cons (list sname *sname-d*) *desc-list*))
		 (setq *temp-struct-sname-member* (reverse *temp-struct-sname-member*))
		 (setq *struct-sname-member* (cons *temp-struct-sname-member* *struct-sname-member*))
		 )
	       (if (not (cid-p sname))
		   ~(def ,*sname-node* (array size_t) (array ,@(hsc:make-offsetof struct-sname (reverse *of-name*))))
		   )
	       (if (not (cid-p sname))
		   ~(def ,*sname-d* descriptor (,desc-id (struct ,sname) ,*sname-node*))
		   )
	       ))) )
  ;;mygc-header.shを入れるために(def xyzzy int)のマッチをする
  ((#?(def xyzzy int))
   (list ~(%include "mygc-header.sh")) )
  ;;otherwise
  (otherwise
   (list x) )
  )

      
;; structの定義に出てくるポインタを記憶する
;; また、名前を記憶する。
(defrule struct-declaration hsc
  ((#?(def ,name (ptr ,type) ,@value))
   (let ((ptr-plus-type nil))
     (setq *temp-struct-sname-member* (cons name *temp-struct-sname-member*))
     (setq *of-name* (cons name *of-name*))
     (setq *of-type* (cons type *of-type*))
     x) )
  ((#?(def ,name ,type {,value})
    #?(decl ,name ,type {,value}))
   (setq *temp-struct-sname-member* (cons name *temp-struct-sname-member*))
   x)
  (otherwise
   (list x))
  )


;;defの部分では、ptrならmoveの対象になり、make-move関数を呼び出してmoveを書く。
;;def以外ではそのまま返す。
;;ptrなら全部たどる
;;def-ptr,decl-ptr
(defrule block-item hsc
  ((#?(def ,name (ptr ,type) ,@value)
    #?(decl ,name (ptr ,type) ,@value))
   ;;ptrならmove対象としてリストに加える。csym::がついていたらmove対象から外す。
   (if (not (cid-p name))
       (setq *def-move-name-list* (cons name *def-move-name-list*)))
   (list x) )	
  ;;def
  ((#?(def ,name ,type {,value}))
   (list x))
  ;;decl
  ((#?(decl ,name ,type {,value}))
   (list x) )
  ;;otherwise(def,decl以外)
  (otherwise
   (if (eq *flag* nil)
       (let ((tempmove nil))
	 (setq *flag* t)
	 (setq tempmove
	       (remove nil ~(def (scan1) (,*nestfn-tag* void void)
			      ,@(hsc:make-move (mapcar #'pointer-type *name-type-list*));関数の引数
			      ,@(hsc:make-move *def-move-name-list*)          ;ポインタ
			      )
		       ))
	 (if (eq *main* t)
	     (list
	      ~(def gctp int)
	      ~(,@tempmove (return))
	      ~(= gctp (if-exp (> argc 3) (csym::atoi (aref argv 3)) 0))
	      ~(csym::gc-init (if-exp (< gctp 0) 0 gctp)
			      (if-exp (> argc 4) (csym::atoi (aref argv 4)) 0) 
			      (if-exp (> argc 5) (csym::atoi (aref argv 5)) 0) 
			      (if-exp (> argc 6) (csym::atoi (aref argv 6)) 0)
			      )
	      (statement x)
	      );main
	     (list
	      ~(,@tempmove (scan0))
	      (statement x)
	      );not main
	     ))
       (list (statement x))
       ) )
  )

;;ポインタなら型の名前を記憶する
;;ptrなら全部たどる
(defrule pointer-type hsc
  ((#?(,name (ptr ,type)))
   name)
  (otherwise
   nil)
  )

(defrule statement hsc
  ;; (while expression block-item-list-opt)
  ((#?(while ,exp ,@body))
   ~(while ,exp ,@(mapcar #'statement body)) )
  ;; (do-while expression block-item-list-opt)
  ((#?(do-while ,exp ,@body))
   ~(do-while ,exp ,@(mapcar #'statement body)) )
  ;; (begin block-item-list-opt)
  ((#?(begin ,@body))
   (remove nil ~(begin ,@(mapcar #'statement body))) )
  ;; (switch expression block-item-list-opt)
  ((#?(switch ,exp ,@body))
   ~(switch ,exp ,@(mapcar #'statement body)) )
  ;; (case expression)
  ((#?(case ,exp))
   ~(case ,exp) )
  ;; (default)
  ((#?(default))
   ~(default) )
  ;; (return expression-opt)
  ((#?(return))
   (statement ~(return ())) )
  ((#?(return ,exp))
   (remove nil ~(return ,(statement exp))) )
  ;; (if expression statement statement-opt)
  ((#?(if ,exp ,stat1))
   ~(if ,(statement exp) ,(statement stat1)) )
  ((#?(if ,exp ,stat1 ,stat2))
   ~(if ,(statement exp) ,(statement stat1) ,(statement stat2)) )
  ;; (for (expression-list-opt expression expression) block-item-list-opt)
  ((#?(for (,exp1 ,exp2) ,@body))
   ~(for (,(statement exp1) ,(statement exp2)) ,@(mapcar #'statement body)) )
  ((#?(for (,exp1 ,exp2 ,exp3) ,@body))
   ~(for (,(statement exp1) ,(statement exp2) ,(struct-declaration exp3))
	 ,@(mapcar #'statement body)) )

  ;;; Expressions
  ;; new(struct)
  ((#?(the ,new-texp (new (the ,init-texp (init ,type (struct ,@value-list))))))
   (let (
	  (type-d nil)
	  (g2-value-list nil)
	  (temp-obname nil)
	  )
      (setq type-d (hsc:make-d (cadr init-texp) *desc-list*))
      (setq g2-value-list (mapcar #'statement value-list))
      (setq temp-obname (generate-id "tmp_object"))
      (setq *temp-def-list-newstruct*
	    (cons ~(def ,temp-obname (ptr ,init-texp)) *temp-def-list-newstruct*))
      ~(exps
	(= ,temp-obname (cast (ptr ,init-texp) (getmem scan1 (ptr ,type-d))))
	  ,@(hsc:make-new-struct temp-obname init-texp *struct-sname-member* value-list)
	  ,temp-obname
	  )
      ))
  ;;new(array)
  ;; (statement (the ,new-texp (new (the ,init-texp (init (array ,type1 ,arsize) (array (the ,type2 ,default) ,@value-list))))))
  ;; -> (let (
  ;;	  (temp-arname nil)
  ;;	  (temp-count nil)
  ;;	  )
  ;;      (progn
  ;;	(setq temp-arname (generate-id "tmp_arname"))
  ;;	(setq temp-count (generate-id "tmp_count"))
  ;;	(setq *temp-def-list-newarray* (cons ~(def ,temp-count int 0) *temp-def-list-newarray*))
  ;;	(setq *temp-def-list-newarray* (cons ~(def ,temp-arname (array ,type1 ,arsize)) *temp-def-list-newarray*))
  ;;	~(exps
  ;;	  ~(do-while (,temp-count < ,arsize)
  ;;	    (= (aref ,temp-arname ,temp-count) ,default)
  ;;	    )
  ;;	  ,temp-arname
  ;;	  )
  ;;	)
  ;;      )

  ;; (aref expression-list)
  ((#?(the ,texp (aref ,exp1 ,@exp-list)))
   ~(the ,texp (aref ,(statement exp1) ,@(mapcar #'statement exp-list))) )
  ;; (fref expression field-identifier-list) 
  ((#?(the ,texp (fref ,exp ,@id-list))) 
   ~(the ,texp (fref ,(statement exp) ,@id-list)) )
  ;; (unary-operator expression)
  ((#?(the ,texp (,op[~(inc dec ++ -- ptr mref bit-not not cast)] ,exp)))
   ~(the ,texp (,op ,(statement exp))) )
  ;; (sizeof expression)
  ((#?(the ,texp0 (sizeof (the ,texp ,exp))))
   ~(the ,texp0 (sizeof ,(statement ~(the ,texp exp)))) )
  ((#?(the ,texp (sizeof ,texp)))
   ~(the ,texp (sizeof ,texp)))
  ;; (operator expression-list), exps
  ((#?(the ,texp (,op[~(* / % + - << >> bit-xor bit-and bit-or and or < > <= >= == != exps)] ,exp1 ,@exp-list)))
   ~(the ,texp (,op ,(statement exp1) ,@(mapcar #'statement exp-list))) )
  ;; (if-exp expression expression expression)
  ((#?(the ,texp (if-exp ,exp1 ,exp2 ,exp3)))
   ~(the ,texp (if-exp ,(statement exp1) ,(statement exp2) ,(statement exp3))) )
  ;; (assignment-operator expression expression)
  ((#?(the ,texp (,op[~(= *= /= %= += -= <<= >>= bit-and= bit-xor= bit-or=)] ,exp1 ,exp2)))
   ~(the ,texp (,op ,(statement exp1) ,(statement exp2))) )
  ;; function call
  ((#?(the ,ret-exp (call (the ,texp ,exp) ,@exp-list)))
   (if (cid-p exp)
       ~(the ,ret-exp (call (the ,texp ,exp)
			    ,@(mapcar #'statement exp-list)))
       ~(the ,ret-exp (call (the ,texp ,exp)
			    scan1
			    ,@(mapcar #'statement exp-list)))
       ))
  (otherwise
   x)
  )

