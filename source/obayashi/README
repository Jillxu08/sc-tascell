・各ファイルの説明

009b.c:ワーカの共通部分

lu.c, fib.c, nq.c, cmp.c, pen.c: それぞれLU分解，フィボナッチ，
n-queen問題の全解探索，配列の要素の比較，ペントミノパズルの全解探索のプログラム
のユーザが記述する部分

sp2-03.rb: 拠点サーバプログラム

ui00b.rb: ユーザインタフェイスプログラム

tcpcon: プログラムの標準入出力をTCPソケットにリダイレクトするスクリプト

worker.h: ユーザ記述部分用のヘッダファイル


・使い方

$ gcc fib.c 009b.c -O2 -lpthread -o fib

などしてコンパイルする．
ワーカを一つだけ走らせるときは，ワーカスレッド数を引数で指定して起動し，
標準入力から入力を与える．(引数を指定しないときはスレッド数は1)

$ ./lu 4
treq 0 any
task 0 0 0  < 入力
10          < 入力
...
rslt 0
 55
treq 0 any
...

拠点サーバを使うときは

$ ruby sp2-03.rb &
$ ./tcpcon localhost 8882 ./fib 2 &
$ ./tcpcon localhost 8883 ./fib 2 & <- 必要な回数(ワーカ数-1)実行する
$ ruby ui001.rb

のような感じ．


・今後の課題
軽量な入れ子関数を使う
  ->LW-SCを使うにはプログラムの大部分をSCで書く必要がある
↓平石さんのコメント
----
最低限，
「その関数から先の呼出しで入れ子関数が呼ばれる可能性がある関数」
すべてをSCで書き直す必要がある．

ライブラリ的な関数を除けば，ほぼ全てを書き直す必要がある．
なお，printf などSCで書いていない関数を呼びだすときは，
(decl (csym::printf) (fn int (ptr (const char)) va-args))
(csym::printf "..." a b)
のようにしておく（宣言がいることと，csym:: をつけること）

> pthread_create(&tid, &attr, worker, arg);
worker として渡す関数は必ず  "thread-origin" という名前の関数にし，
argが本来の worker関数へのポインタも含むようにする．
（arg には，workerへのポインタと，workerに渡す引数が含まれている）

たぶん，argはworkerの中で構造体のポインタにキャストするように
なってると思うので，
その構造体のメンバに，worker のポインタを追加すればいいと思う．

(def (struct worker-arg)
  (def func (ptr (fn (ptr void) (ptr void))))
  ... 本来の worker-arg の中身 ...
)

(= (fref arg -> func) worker)
(csym::pthread-create (ptr tid) (ptr attr) thread-origin arg)

"thread-origin" 関数は，argに含まれている関数ポインタと引数の情報を
使って，workerを呼出すように（SCで）定義する．

(def (thread-origin arg) (fn (ptr void) (ptr void))
  (def w-arg (cast (ptr (struct woker-arg)) arg))
  ((fref w-arg -> func) w-arg))
---


拠点サーバの改良など
  ->タスクや結果の本体などはワーカ同士で直接通信するようにする
    など，全体の通信量を減らすような工夫をする
  ->書き込みブロックによるデッドロックの解消
    ->読み出しが書き込みのために(ロックやブロックなどによって)
      待たされないようにする
      ->書き込みと読み出しが同じスレッドにあるとまずい
        rubyだとスレッドを分けてもだめみたい(ruby自体のスレッドの実装手法のせいか?)
        rubyでなく別の言語で実装し直す必要がありそう

ワーカのバグの修正
  ->スレッド数が増えると動作が安定しない 
    ->スレッド内でやりとりしているメッセージがたまにロストしている?

ワーカスレッド数が増えると exec_queue_cmd の処理が増え，全体の処理がもたつく可能性がある

高水準言語の実装
  ->SC処理系を利用する

共有メモリでの実行について
  ->分散で実行するときはデータのコピーを渡してタスクを実行するが，共有メモリ上
    で実行する場合はデータのアドレスを渡す場合がある．
    しかし，場合によっては共有メモリ上で実行する場合もデータをコピーする必要が
    ある(例 LU分解．複数スレッドがメモリの同じ場所に書き込むなどの可能性がある)．
    この場合，高水準言語での記述やコード生成はどうするか?
    ->LU分解のコードは共有メモリで実行する場合に必要なときだけデータをコピー
      するようにしている．このあたりの処理は人手で調節したため，高水準言語から
      のコード生成ではどうするかが問題になる．
      コピーする場合をプログラマが明示的に記述する必要があるか．