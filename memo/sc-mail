今週のミーティングのSCについて考えてみました。
struct/union/enum あたりも考慮してみましたが、unnamedなものが
ややこしくなってしまいますね。
あと、配列は型式だけでよさそうですね。

ちなみに、
Cの細かい仕様などを考慮する際には
 http://www.faqs.org/faqs/C-faq/faq/
が役に立ちます。


八杉

----------------------------------------

int f (int x) { return x; }
(def (f x) (fn int int) (return x))

int x;
(def x int)

int x, y;
(def x int)
(def y int)

extern int x;
(extern x int)

static int x;
(static x int)

int x = 0;
(def x int 0)

int f (int x) {
  int a;
  int b = x + 1;
  static c = 0;
  a = b * 2;
  return a + c++;
}
(def (f x) (fn int int)
  (auto a int)
  (auto b int (+ x 1))
  (static c int 0)
  (set a (* b 2))
  (return (+ a (inc c))))

int f (int);
(def f (fn int int))

extern int f (int);
(extern f (fn int int))

struct s;
(defstruct s)

struct s {
  int x, y;
  double d;
};
(defstruct s
  (def x int)
  (def y int)
  (def d double))

struct s {
  int x, y;
  double d;
} data;
(defstruct s
  (def x int)
  (def y int)
  (def d double))
(def data (struct s))

typedef struct {
  int x, y;
  double d;
} xyd_t, *xyd_ptr_t;
(without-name anonymous
  (defstruct anonymous
      (def x int) (def y int) (def d double))
  (deftype xyd-t (struct anonymous))
  (deftype xyd-ptr-t (ref (struct anonymous))))

int a[10];
(def a (array int 10))

int a[5][2];
(def a (array int 5 2))
// = (def a (array (array int 2) 5))

int g(){ return a[x][y]; }
(def (g) (fn int) (return (aref a x y)))
// = (def (g) (fn int) (return (aref (aref a x) y)))

int a1[]= {1, 2, 3};
(def a (array int) (1 2 3))

void *(*gg(void *(*ff) (int, int))) (int, int) {
  return ff;
}
(def (gg ff) (fn (ref (fn (ref void) int int))
                 (ref (fn (ref void) int int)))
  (return ff))
  
typedef void *(*gg_t(void *(*) (int, int))) (int, int) ;
(deftype gg-t (fn (ref (fn (ref void) int int))
                  (ref (fn (ref void) int int))))

enum { C0, C1 } qq1, qq2;
(without-name anonymous
  (defenum anonymous C0 C1)
  (def qq1 (enum anonymous))
  (def qq2 (enum anonymous)))

enum abc { A, B, C };
(defenum abc A B C)

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

引用を消してしまいましたが、関数型も型式になってますね。

>> int f (int x) { return x; }
>> (def (f x) (fn int int) (return x))

argument とその型は、ちょっと分りにくいかもしれませんが、
この例のように分けてかいたほうが気持いいですね。

>> int f (int x) {
>>   int a;
>>   int b = x + 1;
>>   static c = 0;
>>   a = b * 2;
>>   return a + c++;
>> }
>> (def (f x) (fn int int)
>>   (auto a int)
>>   (auto b int (+ x 1))
>>   (static c int 0)
>>   (set a (* b 2))
>>   (return (+ a (inc c))))

(auto a int) は (def a (auto int)) のほうが気持よくないですか？
同様に (def c (static int))
...
と思ったけど、よく考えると Visual Basic でも
Dim x As Integer
Public y As Long
Private z As String
のように storage class を Dim (def に相当)の代わりに書くので
これでいいのかもしれません。確か gcc では storage class が 2 つ以上
つくとエラーにしてましたよね。

>> extern int f (int);
>> (extern f (fn int int))

これはいとして、

static inline int f (int);

は、

(static f (inline-fn int int))

とかするといいでしょうか。

>> struct s;
>> (defstruct s)
>>
>> struct s {
>>   int x, y;
>>   double d;
>> };
>> (defstruct s
>>   (def x int)
>>   (def y int)
>>   (def d double))
>>
>> struct s {
>>   int x, y;
>>   double d;
>> } data;
>> (defstruct s
>>   (def x int)
>>   (def y int)
>>   (def d double))
>> (def data (struct s))
>>
>> typedef struct {
>>   int x, y;
>>   double d;
>> } xyd_t, *xyd_ptr_t;
>> (without-name anonymous
>>   (defstruct anonymous
>>       (def x int) (def y int) (def d double))
>>   (deftype xyd-t (struct anonymous))
>>   (deftype xyd-ptr-t (ref (struct anonymous))))

typedef struct {
  int x, y;
  double d;
} xyd_t, *xyd_ptr_t;

は、

(typedef xyd-t (structtype (def x int) (def y int) (def d double)))
(typedef xyd-ptr-t
         (ref (structtype (def x int) (def y int) (def d double))))

でどうでしょう。
structtype が含まれている型は、関数の引数とキャストには使うことが
できない型ということにするか、関数の引数かキャストの型に
使われているときはトランスレータが勝手な名前をつけるとか。

union/enum を加えると、ややこしくなりすぎるんでしょうか。

--
うがわ

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

> (static f (inline-fn int int))
>
> とかするといいでしょうか。

inline 指定しても型は変化しないので、

(static f (fn int int) :attr (inline))

がよいかと思います。gcc用の __attribute__ もここで書けばよいかと.

> >> typedef struct {
> >>   int x, y;
> >>   double d;
> >> } xyd_t, *xyd_ptr_t;
> >> (without-name anonymous
> >>   (defstruct anonymous
> >>       (def x int) (def y int) (def d double))
> >>   (deftype xyd-t (struct anonymous))
> >>   (deftype xyd-ptr-t (ref (struct anonymous))))
>
> typedef struct {
>   int x, y;
>   double d;
> } xyd_t, *xyd_ptr_t;
>
> は、
>
> (typedef xyd-t (structtype (def x int) (def y int) (def d double)))
> (typedef xyd-ptr-t
>          (ref (structtype (def x int) (def y int) (def d double))))
>
> でどうでしょう。

(deftype にしたいというのはおいておいて、)
これで最初は考えていたのですが、ボツにしました。

typedef struct {
  int x, y;
  double d;
} xyd_t;

typedef struct {
  int x, y;
  double d;
} *xyd_ptr_t;

と二つの「struct定義(を伴う型定義)」に分けた場合、

 {
  xyd_ptr_t a;
  xyd_t b;
  b = *a;
 }

は型エラーになります。それぞれのstruct定義で
 *別々の* 「見えないstructタグ」
が追加されていると考えればよいでしょう。

> >> typedef struct {
> >>   int x, y;
> >>   double d;
> >> } xyd_t, *xyd_ptr_t;
> >> (without-name anonymous
> >>   (defstruct anonymous
> >>       (def x int) (def y int) (def d double))
> >>   (deftype xyd-t (struct anonymous))
> >>   (deftype xyd-ptr-t (ref (struct anonymous))))

名前を考えたくないだけでなく、長く書きたくないのなら、

typedef struct {
  int x, y;
  double d;
} xyd_t, *xyd_ptr_t, (*gen_xyd_t)(int, int, double);

(without-name A
  (defstruct A
      (def x int) (def y int) (def d double))
  (deftype xyd-t (struct A))
  (deftype xyd-ptr-t (ref (struct A)))
  (deftype gen-xyd-t (ref (fn (struct A) int int double))))

のような感じでしょうか。また "without-name" よりは、

(hide A
  (defstruct A
      (def x int) (def y int) (def d double))
  (deftype xyd-t (struct A))
  (deftype xyd-ptr-t (ref (struct A)))
  (deftype gen-xyd-t (ref (fn (struct A) int int double))))

のほうがよいかもしれません。

ちなみに、

typedef struct {  int x; int y; double d;} xyd_t, *xyd_ptr_t;
(hide A
  (defstruct A
      (def x int) (def y int) (def d double))
  (deftype xyd-t (struct A))
  (deftype xyd-ptr-t (ref (struct A))))

と

struct {  int x; int y; double d;} xyd, *xyd_ptr;
(hide A
  (defstruct A
      (def x int) (def y int) (def d double))
  (def xyd (struct A))
  (def xyd-ptr (ref (struct A))))

は良いけど、

(hide A
  (defstruct A
      (def x int) (def y int) (def d double))
  (deftype xyd-ptr-t (ref (struct A)))
  (def xyd (struct A)))

は、対応する C のコードが書けませんね。A に対応する衝突しない名前を
自動生成するしかない?

八杉

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

> 今週のミーティングのSCについて考えてみました。

式についてちょっと考えました。

----

a[x][y]
(aref a x y) または (aref (aref a x) y)

a[10]
(aref a 10)

ss.f1
(part ss f1)

*a
(deref a)

ssp->f1
(fref ssp f1)

&a
(ref a)

a++
(inc a)

++a
(++ a)

+a
(plus a)

-a
(minus a)

a+b
(+ a b)

(int)a
(cast a int)

a|b
(bit-or a b)

a||b
(or a b)

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

鵜川です。

<200210232257.HAA23110@ryujin.kuis.kyoto-u.ac.jp>の記事において
yasugi@kuis.kyoto-u.ac.jpさんは書きました。

>> > (typedef xyd-t (structtype (def x int) (def y int) (def d double)))
>> > (typedef xyd-ptr-t
>> >          (ref (structtype (def x int) (def y int) (def d double))))
>> >
>> > でどうでしょう。
>>
>> (deftype にしたいというのはおいておいて、)
>> これで最初は考えていたのですが、ボツにしました。
>>
>> typedef struct {
>>   int x, y;
>>   double d;
>> } xyd_t;
>>
>> typedef struct {
>>   int x, y;
>>   double d;
>> } *xyd_ptr_t;
>>
>> と二つの「struct定義(を伴う型定義)」に分けた場合、
>>
>>  {
>>   xyd_ptr_t a;
>>   xyd_t b;
>>   b = *a;
>>  }
>>
>> は型エラーになります。それぞれのstruct定義で
>>  *別々の* 「見えないstructタグ」
>> が追加されていると考えればよいでしょう。

SC が少しがんばれば、全ての無名のstructに名前を付けていって、
同じ定義は同じ名前というようにすれば、解決できるのでしょうか。
分割コンパイルも問題なさそうな気がします。

-- inc.h
struct {
  double r, i;
} cmplx_t, *cmplx_ptr_t;
extern cmplx_pgt_t add_cmplx_ptr(cmplx_ptr_t x, cmplx_ptr_t y);
extern cmplx_t add_cmplx(cmplx_t, cmplx_t y);
-- a.c
#include <inc.h>
f () {
  cmplx_t x, y;
  ...
  add_cmplx_ptr(&x, &y);
  add_cmplx(x, y);
  ...
}
-- b.c
#include <inc.h>
cmplx_ptr add_cmplx_ptr(cmplx_ptr_t x, cmplx_ptr_t y){...}
cmplx_t add_cmplx(cmplx_t x, cmplx_t y){...}

というような場合、 inc.h は、 a.c と b.c でそれぞれ、

-- a.c
struct ___SC_anonymous_struct_1 {
  double r, i;
};
typedef ___SC_anonymous_struct_1 cmplx_t, *cmplx_ptr_t;
extern cmplx_pgt_t add_cmplx_ptr(cmplx_ptr_t x, cmplx_ptr_t y);
extern cmplx_t add_cmplx(cmplx_t, cmplx_t y);
-- b.c
struct ___SC_anonymous_struct_5 {
  double r, i;
};
typedef ___SC_anonymous_struct_5 cmplx_t, *cmplx_ptr_t;
extern cmplx_pgt_t add_cmplx_ptr(cmplx_ptr_t x, cmplx_ptr_t y);
extern cmplx_t add_cmplx(cmplx_t, cmplx_t y);

のように、別の構造体名が付いてしまうことが考えられます。しかし、
分割コンパイルの場合、コンパイル単位間では型の名前の情報は重要では
ないので、それぞれに別の名前が付いても問題ないと思います。

SC が複雑になるのを避けるのなら hide とかで特殊なスコープを作って
しまうほうがいいかもしれませんが。
--
うがわ
