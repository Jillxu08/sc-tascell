%% 2002/11/7 Thu. ミーティング
\documentstyle[a4j]{jarticle}

\begin{document}
	
\newcommand{\opt}{$_{opt}$}

%------------------------------------------------------------------------------
\section{External Definitions}

\it \noindent
translation-unit: \\
\quad external-declaration \\
\quad translation-unit external-declaration \\


\noindent
external-declaration: \\
\quad declaration \\

%------------------------------------------------------------------------------
\rm 
\section{Declarations}
\it 

\noindent
declaration-list: \\
\quad declaration \\
\quad declaration-list declaration \\ 

%% renew
\noindent
declaration: \\
\quad inlined-declaration \\
\quad {\tt (}identifier type-expression initializer-list\opt {\tt )} \\
\quad {\tt (}{\tt (}identifier-list{\tt )} {\tt (fn} type-expression-list {\tt va-arg}\opt{\tt )} {\rm [}{\tt :attr} function-attribute{\rm ]}\opt register-declarator\opt block-item-list\opt {\tt )} \\ 
\quad {\tt (}struct-or-union-specifier struct-declaration-list\opt {\tt )} \\
\quad {\tt (}enum-specifier enumerator-list {\tt )} \\


\noindent
inlined-declaration-list: \\
\quad inlined-declaration \\
\quad inlined-declaration-list declaration \\ 

%% renew
\noindent
inlined-declaration: \\
\quad {\tt (}storage-class-specifier identifier type-expression initializer-list\opt {\tt )} \\
\quad {\tt (}storage-class-specifier {\tt (}identifier-list{\tt )} {\tt (fn} type-expression-list {\tt va-arg}\opt{\tt )} {\rm [}{\tt :attr} function-attribute{\rm ]}\opt register-declarator\opt block-item-list\opt {\tt )} \\ 
\quad {\tt (}def-or-decl struct-or-union-specifier struct-declaration-list\opt {\tt )} \\
\quad {\tt (def} enum-specifier enumerator-list {\tt )} \\
\quad {\tt (}compound-storage-class-specifier type-expression init-declarator-list {\tt )} \\
\quad {\tt (deftype} identifier type-expression {\tt )} \\
\quad {\tt (deftype} identifier struct-or-union struct-declaration-list\opt {\tt )} \\
\quad {\tt (deftype} identifier {\tt enum} enumerator-list {\tt )} \\

%% new
\noindent
def-or-decl: \\ \tt
\quad def \\
\quad decl \\ \it

\noindent
init-declarator-list: \\
\quad init-declarator \\
\quad init-declarator-list init-declarator \\ 

\noindent
init-declarator: \\
\quad identifier \\
\quad {\tt (}identifier initializer-list{\tt )} \\ 

%% renew
\noindent
type-expression: \\
\quad type-specifier \\
\quad {\tt (}type-qualifier-list type-expression {\tt )} \\
\quad {\tt (array} type-expression array-subscription-list\opt {\tt )} \\
\quad {\tt (ptr}  type-expression {\tt )} \\
\quad {\tt (fn} type-expression-list {\tt va-arg}\opt {\tt )} \\

\noindent
array-subscription-list: \\
\quad expression-list \\


\noindent
storage-class-specifier: {\rm one of} \\  \tt
\quad def decl extern extern-def extern-decl static static-def \\
\quad auto auto-def register register-def \\ \it


\noindent
compound-storage-class-specifier: {\rm one of} \\ \tt
\quad defs extern-defs static-defs auto-defs register-defs \\ \it


\noindent
function-attribute: \\ \tt
\quad inline \\ \it


\noindent
register-declarator: \\
\quad {\tt (register} identifier-list{\tt )} \\


\noindent
type-specifier: {\rm one of} \\ \tt
\quad void \\
\quad char signed-char unsigned-char \\
\quad short signed-short unsigned-short \\
\quad int signed-int unsigned-int \\
\quad long signed-long unsigned-long \\
\quad long-long signed-long-long unsigned-long-long \\
\quad float double long-double \\ \it
\quad struct-or-union-specifier \\
\quad enum-specifier \\
\quad typedef-name \\


\noindent
struct-or-union-specifier: \\
\quad {\tt (}struct-or-union identifier {\tt )} \\

\noindent
struct-or-union: \\ \tt
\quad struct \\
\quad union \\ \it

\noindent
struct-declaration-list: \\
\quad struct-declaration \\
\quad struct-declaration-list struct-declaration \\


\noindent
struct-declaration: \\
\quad declaration {\rm [}{\tt :bit} expresion{\rm ]}\opt \\


\noindent
enum-specifier: \\
\quad {\tt (enum} identifier {\tt )} \\

\noindent
enumerator-list: \\
\quad enumerator \\
\quad enumerator-list enumerator \\


\noindent
enumerator: \\
\quad enumeration-constant \\
\quad {\tt (}enumeration-constant expression {\tt )}\\

\noindent
enmuration-constant: \\
\quad identifier \\

\noindent
type-qualifier-list: \\
\quad type-qualifier \\
\quad type-qualifier-list type-qualifier \\

\noindent
type-qualifier: \\ \tt
\quad const \\
\quad restrict \\
\quad volatile \\ \it

\noindent
identifier-list: \\
\quad identifier \\
\quad identifier-list identifier \\

\noindent
typedef-name: \\
\quad identifier \\

\noindent
initializer: \\
\quad expression \\
\quad {\tt (}initializer-list {\tt )} \\

%% とりあえずrenew(designated initializer削除)
\noindent
initializer-list: \\
\quad initializer \\
\quad initlalizer-list initializer \\

%% renew＆とりあえず削除
%\noindent
%designator: \\
%\quad {\tt (part} designator\opt identifier-list {\tt )} \\
%\quad {\tt (aref} designator\opt expression-list {\tt )} \\

%------------------------------------------------------------------------------
\rm
\section{Statements}

\it

\noindent
statement: \\
\quad compound-statement \\
\quad expression-statement \\
\quad selection-statement \\
\quad iteration-statement \\
\quad jump-statement \\
\quad labeled-statement \\


\noindent
compound-statement: \\
\quad {\tt (}{\tt begin} block-item-list\opt {\tt )} \\
\quad {\tt (}{\tt let} {\tt (}declaration-list\opt {\tt )} block-item-list\opt {\tt )} \\

\noindent
block-item-list: \\
\quad block-item \\
\quad block-item-list block-item \\


\noindent
block-item: \\
\quad inlined-declaration \\
\quad statement \\

%% renew
\noindent
labeled-statement: \\
\quad {\tt (label} identifier statement {\tt )} \\
\quad {\tt (case} expression {\tt )} \\
\quad {\tt (default)} \\

\noindent
expression-statemt: \\
\quad expression \\
\quad {\tt ()} \\

\noindent
selection-statement: \\
\quad {\tt (if} expression statement statement\opt {\tt )} \\
\quad {\tt (switch} expression block-item-list\opt {\tt )} \\


\noindent
iteration-statement: \\
\quad {\tt (while} expression block-item-list\opt {\tt )} \\
\quad {\tt (do-while} expression block-item-list\opt {\tt )} \\
\quad {\tt (for} {\tt (}expression-list\opt expression expression {\tt )} block-item-list\opt {\tt )} \\
\quad {\tt (for} {\tt (}inlined-declaration-list\opt expression expression {\tt )} block-item-list\opt {\tt )} \\

\noindent
jump-statement: \\
\quad {\tt (goto} identifier {\tt )} \\
\quad {\tt continue} \\
\quad {\tt break} \\
\quad {\tt (return} expression\opt {\tt )}

%------------------------------------------------------------------------------
\rm
\section{Expressions}
\it

%% renew
\noindent
expression: \\
\quad identifier \\
\quad constant \\
\quad string-literal \\
\quad {\tt (}expression-list{\tt )} \\
\quad {\tt (aref} expression-list {\tt )} \\
\quad {\tt (part} expression identifier-list {\tt )} \\
\quad {\tt (fref} expression identifier-list {\tt )} \\
\quad {\tt (inc} expression {\tt )} \\
\quad {\tt (dec} expression {\tt )} \\
%% \quad {\tt (the} type-expression initializer-list {\tt )} \\
\quad {\tt (++} experssion {\tt )} \\
\quad {\tt (--} expression {\tt )} \\
\quad {\tt (}unary-operator expression {\tt )} \\
\quad {\tt (sizeof} expression {\tt )} \\
\quad {\tt (sizeof} type-expression {\tt )} \\
\quad {\tt (cast} type-expression expression {\tt )} \\
\quad {\tt (}operator expression-list {\tt )} \\
\quad {\tt (}comparator expression-list {\tt )} \\
\quad {\tt (if-exp} expression expression expression {\tt )} \\
\quad {\tt (}assignment-operator expression expression {\tt )} \\
\quad {\tt (exps} expression-list {\tt )} \\

\noindent
expression-list: \\
\quad expression \\
\quad expression-list expression \\

%% renew
\noindent
operator: {\rm one of} \\ \tt
\quad * / \% + - << >> \\
\quad bit-xor bit-and bit-or and or \\ \it

%% new
\noindent
comparator: {\rm one of} \\ \tt
\quad < > <= >= == != \\ \it

\noindent
assignment-operator: {\rm one of} \\ \tt
\quad = *= /= \%= += -= <<= >>= and= xor= or= \\ \it

\noindent
expression-list: \\
\quad expression \\
\quad expression-list expression \\


\noindent
unary-operator: {\rm one of} \\ \tt
\quad ptr mref bit-not not \\ \it

\begin{verbatim}
====== C-->SC 変換例 =========================================================
int f (int x) { return x; }
--> ((f x) (fn int int) (return x))

int x;
--> (x int)     
--> (def x int)  ;;inlined

int x,y=x+1;
--> (defs int x (y (+ x 1)))

extern int x;
--> (extern x int)

static int x;
--> (static x int)

int x=0;
--> (x int 0)
--> (def x int 0) ;;inlined

int f (int x){
  int a;
  int b=x+1;
  static c=0;
  a = b*2;
  return a + c++;
}
--> ((f x) (fn int int)
      (let ((a int) (b int (+ x 1)) (static c int 0))
        (= a (* b 2))
        (return (+ a (inc c)))))

int f(int);
--> (decl (f) (fn int int))

extern int f(int);
--> (extern-decl (f) (fn int int))

struct s;
--> (decl (struct s))

struct s{
  int x,y;
  double d;
}
--> ((struct s) (defs int x y) (d double))
--> (def (struct s) (defs int x y) (d double)) ;;inlined

typedef struct {
  int x, y;
  double d;
} xyd_t, *xyd_ptr_t;
--> (deftype xyd_t struct (defs int x y) (d double))
    (deftype xyd_ptr_d (ptr xyd_t))

union sb{
  int s;
  struct {
    unsigned b0:1;
    unsigned b1:1;
    unsigned b2:1;
  } b;
};
--> (deftype tagb struct (defs unsigned-int b0 b1 b2) :bit 1)
     (def (union sb) (s int) (b tagb))

enum { C0, C1 } qq1, qq2;
--> (deftype tagc enum C0 C1)
    (defs tagc qq1 qq2)

enum abc { A, B, C };
--> ((enum abc) A B C)
--> (def (enum abc) A B C)  ;;inlined



int a[10];
--> (a (array int 10))
--> (def a (array int 10))  ;;inlined 

int a[5][2];
--> (a (array int 5 2))
    or (a (array (array int 2) 5))

int a1[]={1,2,3};
--> (a1 (array int) 1 2 3)

int ar2[][3]={{0,1,2},{3,4,5}}
--> (ar2 (array (array int 3)) (0 1 2) (3 4 5))

int g(){return a[x][y];}
--> ((g) (fn int) (return (aref a x y)))
    or ((g) (fn int) (return (aref (aref a x) y)))

void *(*gg(void *(*ff) (int, int))) (int, int) {
  return ff;
}
--> ((gg ff) (fn (ptr (fn (ptr void) int int)) (ptr (fn (ptr void) int int)))
     (return ff))  

typedef void *(*gg_t(void *(*) (int, int))) (int, int) ;
--> (deftype gg_t (fn (ptr (fn (ptr void) int int))
      ((ptr (function (ptr void) (int int))))))

int f(register x){ return x; }
--> ((f x) (fn int int) (register x) (return x))

int f(char a, double b, ... );
--> (decl (f a b) (fn int char double va-arg))

inline int f(long double ld){return ld;}
--> ((f ld) (fn int long-double) attr: inline (return ld))
\end{verbatim}

\end{document}
