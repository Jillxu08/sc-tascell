以下の表の GC の S を wfs2 のにしたいので，
~lang/xcc/gc/bt11/ での ./run-2004 というスクリプトで
データを取って表を更新してください．

bt0 が BinTree, bt1 が Bin2list です


以下の表の GC の P を ibusuki にしたいので，
~lang/xcc/gc/bt12/ での ./run-2004 で データを取って表を更新してください．
(bt11 は yuza 用だったので...)


あと，~lang/xcc/cp/ チェックポイントがあるので，表に追加してください．
なお wfs2 には未コピーです．

 SUN:    ./run 36
 LINUX:  ./run-i386 36

とかでよいかと．

あと，load balancing も wfs2 に未コピーですが，
適当にコピーして Pentomino は
  
 /home/lab4/yasugi/lang/xcc/ltc/pen/0310 

で ./dosparc とかやれば動きます．一方，./doi386 は， yuza 用なので
ibusuki では再コンパイルしないと動きません．試みてもらえますか
上で bt11 で yuza 用だったのを bt12 は ibusuki 用にしています．
(あと，load balancing については，linux では

 ~/tmp/i386-linux2.4.20/n1/bin/gcc -pthread -O2 systhr.c -c -o /tmp/systhr-i386-lin.o

 のように，-pthread オプションが必要ではないかと思います．)

./dosparc も ./doi386 も最初の2行は Cilk でとても遅いので
注意してください．今回，Cilk との比較は，関連研究に書く可能性
があるので，一応，データがあるとうれしいです．

(ただし，ibusuki には，cilk を入れていないので，その準備まで
は大変ですね．)

また，load balancing については，

 /home/lab4/yasugi/lang/xcc/ltc/ltcfib/0310 

に fib がありますので，同様に．

それと，load balancing については， nqueen が

 /home/lab4/yasugi/lang/xcc/ltc/ltcfib/0404

に，sparc は作成済み(スクリプトは dosparc)であり，
i386 用のバイナリなどはまだ作りきっていないので試みて
ほしいです．

八杉

==================================================

\begin{table}
\centering
\caption{Performance Measurements.}
\label{t:pmpm}

\begin{tabular}{|c|c|r|r|r|r|}
\multicolumn{6}{r}{Elapsed Time in seconds} \\
\multicolumn{2}{l}{\ \ \  S:SPARC}&
\multicolumn{4}{r}{  (relative time to plain C)} \\
\cline{3-6}
\multicolumn{2}{l|}{\ \ \ P:Pentium}
                & \multicolumn{1}{c|}{C}
                         & GCC    & Closure & L-Closure  \\ \cline{3-6} \hline
BinTree    & S   & 0.256   & 0.340 & 0.318  & 0.270   \\ 
copying    &     & (1.00) & (1.32) & (1.24) & (1.05) \\ \cline{2-6}
  GC       & P   & 0.339   & 0.368 & 0.365  & 0.341   \\ 
           &     & (1.00) & (1.08) & (1.07) & (1.01) \\ \hline

Bin2List   & S   & 0.1224 & 0.1424 & 0.1251  & 0.1220   \\ 
copying    &     & (1.00) & (1.16) & (1.02) & (1.00) \\ \cline{2-6}
  GC       & P   & 0.0899   & 0.0926 & 0.0904  & 0.0910   \\ 
           &     & (1.00) & (1.03) & (1.01) & (1.01) \\ \hline

fib(36)   & S   & 0.80   & 3.47   & 1.29    & 0.96       \\ 
 Load      &     & (1.00) & (4.34) & (1.61)  & (1.20)     \\ \cline{2-6}
Balancing  & P   & 0.50   & 1.07   & 0.95    & 0.80       \\ 
          &     & (1.00) & (2.16) & (1.91)  & (1.62)     \\  \hline

Pentomino  & S   & 4.47   & 8.09   & 6.58   & 4.85   \\ 
  Load     &     & (1.00) & (1.81) & (1.47) & (1.09) \\ \cline{2-6}
Balancing  & P   & 3.68   & 4.36   & 4.28   & 3.90   \\ 
           &     & (1.00) & (1.19) & (1.16) & (1.06) \\ \hline


\end{tabular}
\end{table}

Without having the nested functions, the speed of C programs will not
change with our extended compiler. In this section, we employ several
programs with nested functions and compare them with the corresponding
plain C program. We measures the performance on 750MHz Ultra\-SPARC-III
and 1GHz Pentium-III.

Table~\ref{t:pmpm} summarizes the results of performance measurements,
where ``C'' means the plain C program, and 
``GCC'' means the use of the conventional nested functions using
trampolines.  In some programs, especially those allocates nested
functions frequently, the speed of the conventional nested functions
is less than half. In contrast, L-Closures exhibits good performance.
The relative times to the plain C are considerably near to 1.0.
