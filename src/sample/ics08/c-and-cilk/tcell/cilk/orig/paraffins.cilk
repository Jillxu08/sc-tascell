/* Paraffins problem, described in Arvind and Nikhil's book on
 * parallel programming.
 *
 * Author: tck
 */

#include "stdio.h"
#include "stdlib.h"
#include "string.h"
#include "cilk.h"
#include "cilk-lib.h"

int ncarbons;

int d[100][3][100][100];
int nradicals[100];
struct radical_s {
  int ncr[3];  // ncr[i]=number of carbons in ith subradical
  int ind[3];  // ind[i]=index of ith subradical in its array
};
struct radical_s *radicals[100];

int nbcps[100];
struct bcp_s {
  int ind[2];
};
struct bcp_s *bcps[100];

int d2[100][4][100][100];
int nccps[100];
struct ccp_s {
  int ncr[4];
  int ind[4];
};
struct ccp_s *ccps[100];

char *concat(char *a, char *b) {
  char *c = (char *) malloc((strlen(a)+strlen(b)+1)*sizeof(char));
  strcpy(c,a);
  strcat(c,b);
  return c;
}

int choose(int r, int n) {
  int i;
  int t=1;
  for (i=n; i>n-r; i--)
    t*=i;
  for (i=r; i>0; i--)
    t/=i;

  return t;
}




int count_radicals(int ncr, int k, int x, int tot) {
  int i;

  if (k==3)
    if (tot==ncr-1)
      return 1;
    else
      return 0;
  if (tot>=ncr || x==ncr)
    return 0;

  if (d[ncr][k][x][tot] != -1)
    return d[ncr][k][x][tot];

  d[ncr][k][x][tot]=0;
  for (i=0; i<=3-k; i++)
    d[ncr][k][x][tot]+=choose(i,nradicals[x]+i-1) * count_radicals(ncr, k+i, x+1, tot+x*i);
  return d[ncr][k][x][tot];
}


cilk void fill_radicals_helper(int ncr, int k, int x, int tot, struct radical_s rad, int position, int i, int j, int prevind);
cilk void fill_radicals(int ncr, int k, int x, int tot, struct radical_s rad, int position) {
  int i;

  if (k==3) {
    //printf("%d\n",position);
    radicals[ncr][position]=rad;
    return;
  }

  for (i=3-k; i>=0; i--) {
    if (count_radicals(ncr,k+i,x+1,tot+x*i)>0) {
      spawn fill_radicals_helper(ncr, k, x, tot, rad, position, i, 0, 0);
      position+=choose(i, nradicals[x]+i-1) * count_radicals(ncr, k+i, x+1, tot+x*i);
    }
  }

  sync;
}
cilk void fill_radicals_helper(int ncr, int k, int x, int tot, struct radical_s rad, int position, int i, int j, int prevind) {
  int ind;

  if (j==i) {
    spawn fill_radicals(ncr, k+i, x+1, tot+x*i, rad, position);
    sync;
    return;
  }

  for (ind=prevind; ind<nradicals[x]; ind++) {
    rad.ncr[k+j]=x;
    rad.ind[k+j]=ind;
    spawn fill_radicals_helper(ncr, k, x, tot, rad, position, i, j+1, ind);
    position+=choose(i-j-1, (nradicals[x]-ind)+(i-j-1)-1) * count_radicals(ncr, k+i, x+1, tot+x*i);
  }

  sync;
}


int count_bcps(int nc) {
  if (nc%2 != 0)
    return 0;
  else
    return choose(2, nradicals[nc/2]+1);
}

int count_ccps(int nc, int k, int x, int tot) {
  int i;

  if (k==4)
    if (tot==nc-1)
      return 1;
    else
      return 0;
  if (tot>=nc || x>=(nc+1)/2)
    return 0;


  if (d2[nc][k][x][tot] != -1)
    return d2[nc][k][x][tot];

  d2[nc][k][x][tot]=0;
  for (i=0; i<=4-k; i++)
    d2[nc][k][x][tot]+=choose(i, nradicals[x]+i-1) * count_ccps(nc, k+i, x+1, tot+x*i);
  return d2[nc][k][x][tot];
}

cilk void fill_bcps_helper(int nc, int k, struct bcp_s bcp, int position, int prevind);
cilk void fill_bcps(int nc) {
  if (nc%2 != 0)
    return;
  else {
    struct bcp_s bcp;
    spawn fill_bcps_helper(nc, 0, bcp, 0, 0);
    sync;
  }
}
cilk void fill_bcps_helper(int nc, int k, struct bcp_s bcp, int position, int prevind) {
  int ind;

  if (k==2) {
    //printf("%d\n",position);
    bcps[nc][position]=bcp;
    return;
  }

  for (ind=prevind; ind<nradicals[nc/2]; ind++) {
    bcp.ind[k]=ind;
    spawn fill_bcps_helper(nc, k+1, bcp, position, ind);
    position+=choose(2-k-1, (nradicals[nc/2]-ind)+(2-k-1)-1);
  }

  sync;
}

cilk void fill_ccps_helper(int nc, int k, int x, int tot, struct ccp_s ccp, int position, int i, int j, int prevind);
cilk void fill_ccps(int nc, int k, int x, int tot, struct ccp_s ccp, int position) {
  int i;

  if (k==4) {
    //printf("%d\n",position);
    ccps[nc][position]=ccp;
    return;
  }

  for (i=4-k; i>=0; i--) {
    if (count_ccps(nc,k+i,x+1,tot+x*i)>0) {
      spawn fill_ccps_helper(nc, k, x, tot, ccp, position, i, 0, 0);
      position+=choose(i, nradicals[x]+i-1) * count_ccps(nc, k+i, x+1, tot+x*i);
    }
  }

  sync;
}
cilk void fill_ccps_helper(int nc, int k, int x, int tot, struct ccp_s ccp, int position, int i, int j, int prevind) {
  int ind;

  if (j==i) {
    spawn fill_ccps(nc, k+i, x+1, tot+x*i, ccp, position);
    return;
  }

  for (ind=prevind; ind<nradicals[x]; ind++) {
    ccp.ncr[k+j]=x;
    ccp.ind[k+j]=ind;
    spawn fill_ccps_helper(nc, k, x, tot, ccp, position, i, j+1, ind);
    position+=choose(i-j-1, (nradicals[x]-ind)+(i-j-1)-1) * count_ccps(nc, k+i, x+1, tot+x*i);
  }

  sync;
}



char *radstr(int ncr, int ind) {
  if (ncr==0)
    return "H";
  else {
    char *s="C";
    int i;
    for (i=0; i<3; i++)
      s=concat(s, concat(concat(" (",radstr(radicals[ncr][ind].ncr[i], radicals[ncr][ind].ind[i])),")"));
    return s;
  }

}


cilk int main(int argc, char *argv[]) {
  int i,j,k,l;
  FILE *fp;


  if (argc!=2 && !(argc==3 && !strcmp(argv[2],"print"))) {
    printf("Usage: paraffins [number of carbon atoms]\n");
    printf("    or paraffins [number of carbon atoms] print\n");
    return 0;
  }
  
  ncarbons=atoi(argv[1]);
  printf("number of carbons =  %d\n",ncarbons);

  printf("\n");


  //counting time is negligible compared to enumeration, 
  //so counting in serial is ok, i think
  for (i=0; i<=(ncarbons/2); i++)
    for (j=0; j<3; j++)
      for (k=0; k<i; k++)
	for (l=0; l<i; l++)
	  d[i][j][k][l]=-1;
  nradicals[0]=1;
  for (i=1; i<=(ncarbons/2); i++) {
    nradicals[i]=count_radicals(i, 0, 0, 0);
    printf("number of radicals with %d carbons = %d\n",i,nradicals[i]);
  }
  printf("\n");
  for (i=1; i<=ncarbons; i++)
    for (j=0; j<4; j++)
      for (k=0; k<=i/2; k++)
	for (l=0; l<i; l++)
	  d2[i][j][k][l]=-1;
  for (i=1; i<=ncarbons; i++) {
    nbcps[i]=count_bcps(i);
    nccps[i]=count_ccps(i, 0, 0, 0);
    printf("number of paraffins with %d carbons = %d\n",i,nbcps[i]+nccps[i]);
  }
  //end of counting


  //enumerate in parallel
  for (i=1; i<=(ncarbons/2); i++) {
    struct radical_s rad;
    radicals[i]=(struct radical_s *)malloc(nradicals[i]*sizeof(struct radical_s));
    spawn fill_radicals(i, 0, 0, 0, rad, 0);
  }
  for (i=1; i<=ncarbons; i++) {
    struct ccp_s ccp;
    bcps[i]=(struct bcp_s *)malloc(nbcps[i]*sizeof(struct bcp_s));
    spawn fill_bcps(i);
    ccps[i]=(struct ccp_s *)malloc(nccps[i]*sizeof(struct ccp_s));
    spawn fill_ccps(i, 0, 0, 0, ccp, 0);
  }
  sync;
  //end of enumeration



  /*
  fp = fopen("t.t", "w");
  for (i=1; i<=ncarbons; i++) {
    fprintf(fp,"there are %d paraffins with %d carbons:\n",nbcps[i]+nccps[i], i);
      if (i%2==0)
	for (j=0; j<nbcps[i]; j++) {
	  fprintf(fp,"BCP\n");
	}
      for (j=0; j<nccps[i]; j++) {
	fprintf(fp,"CCP");
	for (k=0; k<4; k++)
	  fprintf(fp, " (%d,%d)",ccps[i][j].ncr[k],ccps[i][j].ind[k]);
	fprintf(fp,"\n");
      }
      fprintf(fp,"\n");
  }
  fclose(fp);
  */

  if (argc==3) {
    printf("outputting paraffin descriptions to file output.txt ...\n");
    fp = fopen("output.txt", "w");
    for (i=1; i<=ncarbons; i++) {
      fprintf(fp,"there are %d paraffins with %d carbons:\n",nbcps[i]+nccps[i], i);
      if (i%2==0)
	for (j=0; j<nbcps[i]; j++) {
	  fprintf(fp,"BCP");
	  for (k=0; k<2; k++)
	    fprintf(fp, " (%s)",radstr(i/2, bcps[i][j].ind[k]));
	  fprintf(fp,"\n");
	}
      for (j=0; j<nccps[i]; j++) {
	fprintf(fp,"CCP");
	for (k=0; k<4; k++)
	  fprintf(fp, " (%s)",radstr(ccps[i][j].ncr[k], ccps[i][j].ind[k]));
	fprintf(fp,"\n");
      }
      fprintf(fp,"\n");
    }
    fclose(fp);
    printf("done\n");
  }


  return 0;
}
