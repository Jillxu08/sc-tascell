/* Copyright (c) 2002 Massachusetts Institute of Technology
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
 */

static const char *ident __attribute__((__unused__))
     = "$HeadURL: https://bradley.csail.mit.edu/svn/repos/cilk/5.4.3/examples/nd/library/fib.cilk $ $LastChangedBy: bradley $ $Rev: 73 $ $Date: 2002-12-25 19:09:12 -0500 (Wed, 25 Dec 2002) $";

#include <cilk.h>
#include <cilk-lib.h>
#include <stdio.h>

/* Note: Comparison of serial to parallel times will not be favorable
 *       in a program like fib, unless you turn off CILK_CRITICAL_PATH
 *       measurements!
 */

/*
 * serial code
 */
int fib_serial(int n)
{
     if (n < 2)
	  return (n);
     else {
	  int x, y;
	  x = fib_serial(n - 1);
	  y = fib_serial(n - 2);
	  return (x + y);
     }
}

/*
 * Cilk code
 */
cilk int fib(int n)
{
     if (n < 2)
	  return (n);
     else {
	  int x, y;
	  x = spawn fib(n - 1);
	  y = spawn fib(n - 2);
	  sync;
	  return (x + y);
     }
}

/*
 * Wrapper function to translate arguments and perform Cilk timing.
 */
cilk int wrap(int *n)
{
  int r;
  Cilk_time cpstart, cpstop, workstart, workstop;

  cpstart = Cilk_user_critical_path;
  workstart = Cilk_user_work;

  r = spawn fib(*n);
  sync;

  cpstop = Cilk_user_critical_path;
  workstop = Cilk_user_work;

  printf("Critical path: %f sec\n", Cilk_time_to_sec(cpstop-cpstart));
  printf("Total work (accumulated): %f sec\n",
	 Cilk_time_to_sec(workstop-workstart));
  if (cpstop-cpstart>0)
    printf("Average parallelism: %f\n",
	   Cilk_time_to_sec(workstop-workstart)/
	   Cilk_time_to_sec(cpstop-cpstart));

  return r;
}

/*
 * initialization code
 */
int main(int argc, char *argv[])
{
  int i,n,input,count;
  Cilk_time wallstart, wallstop;
  
  Cilk_options options;
  if (Cilk_parse_command_line(&options, &argc, argv))
    exit(1);

  if (argc >= 2)
    input = atoi(argv[1]);
  else
    input = 35;
  if (argc >= 3)
    count = atoi(argv[2]);
  else
    count = 4;

  if (input <= 0 || count <= 0) {
    fprintf(stderr, "Usage: %s [fib-argument [count]]\n", argv[0]);
    exit(1);
  }

  Cilk_init(&options);
  
  printf("Running fib(%d) alternating %d times with and without Cilk\n",
	 input, count);

  for(i=0; i<count; i++)
    {
      n = 0;  /* Just to be sure */
      
      printf("Trial %d\n", i);
      
      printf("Parallel\n");
      wallstart = Cilk_get_wall_time();
      n = Cilk_run(wrap, &input);
      wallstop = Cilk_get_wall_time();
      printf("Wall-clock time: %f sec\n",
	     Cilk_wall_time_to_sec(wallstop-wallstart));
      printf("fib(%d) = %d\n", input, n);
      fflush(NULL);
      
      printf("Serial\n");
      wallstart = Cilk_get_wall_time();
      n = fib_serial(input);
      wallstop = Cilk_get_wall_time();
      printf("Wall-clock time: %f sec\n",
	     Cilk_wall_time_to_sec(wallstop-wallstart));
      printf("fib(%d) = %d\n", input, n);
      fflush(NULL);
    }
  
  Cilk_finish();
  return 0;
}
