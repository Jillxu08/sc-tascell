#include <cilk-lib.cilkh>
#include <stdio.h>
#include <stdlib.h>

/* app */

// thread local strogae
struct gravity {
    double f[3];         // ÎÏ¥Ù¥¯¥È¥ë
    double rf[3];        // Èù¾®ÃÍ¤ÎÃßÀÑ½ê
}

extern double sqrt(dobule);

cilk double force (double x, double y, double z, double *cur, *tsk)
{
    double dx = (double)x - cur[0];
    double dy = (double)y - cur[1];
    double dz = (double)z - cur[2];
    double one_d2th = 1.0/(dx*dx+dy*dy+dz*dz);
    double one_d3th = sqrt(one_d2th) * one_d2th;
    tsk->rf[0] += dx * one_d3th;
    tsk->rf[1] += dy * one_d3th;
    tsk->rf[2] += dz * one_d3th;
    for(i=0;i<3;i++)
      if(tsk->rf[i] > 1.0 || tsk->rf[i] < -1.0){
	tsk->f[i] += tsk->rf[i]; tsk->rf[i] = 0.0;
      }
}
    
cilk struct gravity  
*grav_z(int x, int y,
        int minz, int maxz,
        double *cur,
        struct gravity *gresult)
{
    int y;
    double f[3] = {0.0, 0.0, 0.0};
    double rf[3] = {0.0, 0.0, 0.0};
    struct gravity new_task;
    struct gravity *st = &new_task;
    
    inlet void integrate (struct gravity *r_st)
      {
        int i;
        for (i=0 ; i<3 ; i++)
          f[i] += r_st->f[i];
        for (i=0 ; i<3 ; i++)
          rf[i] += r_st->rf[i];
        for (i=0 ; i<3 ; i++)
          if (rf[i] > 1.0 || rf[i] < -1.0)
            {
              f[i] += rf[i];
              rf[i] = 0.0;
            }
        return;
      }
    
    for(z = minz; z < minz+1; z++) { // y¼´Êý¸þ¤ÇÊÂÎó²½
        integrate (spawn force (x, y, z, cur));
    }
    sync;
    for (i=0 ; i<3 ; i++)
      gresult->f[i] = f[i];
    for (i=0 ; i<3 ; i++)
      gresult->rf[i] = rf[i];
    return gresult;
}

cilk struct gravity  
*grav_y(int x,
        int miny, int minz, 
        int maxy, int maxz,
        double *cur,
        struct gravity *gresult)
{
    int y;
    double f[3] = {0.0, 0.0, 0.0};
    double rf[3] = {0.0, 0.0, 0.0};
    struct gravity new_task;
    struct gravity *st = &new_task;
    
    inlet void integrate (struct gravity *r_st)
      {
        int i;
        for (i=0 ; i<3 ; i++)
          f[i] += r_st->f[i];
        for (i=0 ; i<3 ; i++)
          rf[i] += r_st->rf[i];
        for (i=0 ; i<3 ; i++)
          if (rf[i] > 1.0 || rf[i] < -1.0)
            {
              f[i] += rf[i];
              rf[i] = 0.0;
            }
        return;
      }
    
    for(y = miny; y < maxy+1; y++) { // y¼´Êý¸þ¤ÇÊÂÎó²½
        if(!SYNCHED) {
            st = Cilk_alloca(sizeof(struct gravity));
        }
        integrate (spawn grav_z (x, y, minz, maxz, cur, st));
    }
    sync;
    for (i=0 ; i<3 ; i++)
      gresult->f[i] += f[i];
    for (i=0 ; i<3 ; i++)
      gresult->rf[i] += rf[i];
    return gresult;
}

cilk struct gravity  
*grav_x(int minx, int miny, int minz, 
        int maxx, int maxy, int maxz,
        double *cur,
        struct gravity *gresult)
{
    int x;
    double f[3] = {0.0, 0.0, 0.0};
    double rf[3] = {0.0, 0.0, 0.0};
    struct gravity new_task;
    struct gravity *st = &new_task;
    
    inlet void integrate (struct gravity *r_st)
      {
        int i;
        for (i=0 ; i<3 ; i++)
          f[i] += r_st->f[i];
        for (i=0 ; i<3 ; i++)
          rf[i] += r_st->rf[i];
        for (i=0 ; i<3 ; i++)
          if (rf[i] > 1.0 || rf[i] < -1.0)
            {
              f[i] += rf[i];
              rf[i] = 0.0;
            }
        return;
      }
    
    for(x = minx; x < minx+1; x++) { // x¼´Êý¸þ¤ÇÊÂÎó²½
        if(!SYNCHED) {
            st = Cilk_alloca(sizeof(struct gravity));
        }
        integrate (spawn grav_y (x, miny, minz, maxy, maxz, st));
    }
    sync;
    for (i=0 ; i<3 ; i++)
      gresult->f[i] = f[i];
    for (i=0 ; i<3 ; i++)
      gresult->rf[i] = rf[i];
    return gresult;
}

cilk int cilk_main(int argc, char *argv[])
{
  int n;
  struct gravity *tsk;
  int a, i;
  int minx, miny, minz, maxx, maxy, maxz;
  double cur[3];
  Cilk_time tm_begin, tm_elapsed;
  Cilk_time wk_begin, wk_elapsed;
  Cilk_time cp_begin, cp_elapsed;

  if (argc < 10) {
    printf("%s: (minx, miny, minz)--(maxx, maxy, maxz) and (curx, cury, curz) required.\n", argv[0]);
    return 1;
  }
  if (argc > 10)
    printf("%s: extra arguments being ignored\n", argv[0]);

  tsk = malloc (sizeof (struct gravity));
  minx = atoi (argv[1]);
  miny = atoi (argv[2]);
  minz = atoi (argv[3]);
  maxx = atoi (argv[4]);
  maxy = atoi (argv[5]);
  maxz = atoi (argv[6]);
  cur[0] = ((double)(atoi (argv[7])))/100;
  cur[1] = ((double)(atoi (argv[8])))/100;
  cur[2] = ((double)(atoi (argv[9])))/100;

  fprintf(stderr, "start (%d, %d, %d,)--(%d, %d, %d): (%lf, %lf, %lf)\n",
          minx,
          miny,
          minz,
          maxx,
          maxy,
          maxz,
          cur[0],
          cur[1],
          cur[2]);

  /* Timing. "Start" timers */
  sync;
  cp_begin = Cilk_user_critical_path;
  wk_begin = Cilk_user_work;
  tm_begin = Cilk_get_wall_time();

  spawn grav_x(minx, miny, minz,
               maxx, maxy, maxz,
               cur,
               tsk);
  sync;
  for (i=0; i<3; i++)
      tsk->f[i] += tsk->rf[i];
  
  /* Timing. "Stop" timers */
  tm_elapsed = Cilk_get_wall_time() - tm_begin;
  wk_elapsed = Cilk_user_work - wk_begin;
  cp_elapsed = Cilk_user_critical_path - cp_begin;

  fprintf(stderr, "f = (%lf, %lf, %lf)\n",
          tsk->f[0], tsk->f[1], tsk->f[2]);
  
  printf("\n");
  printf("Running time  = %4f s\n", Cilk_wall_time_to_sec(tm_elapsed));
  printf("Work          = %4f s\n", Cilk_time_to_sec(wk_elapsed));
  printf("Critical path = %4f s\n\n", Cilk_time_to_sec(cp_elapsed));

  return 0;
}
