#include <cilk-lib.cilkh>
#include <stdio.h>
#include <stdlib.h>
#include <math.h>

/* app */

// thread local strogae
struct gravity {
    double f[3];         // ÎÏ¥Ù¥¯¥È¥ë
    double rf[3];        // Èù¾®ÃÍ¤ÎÃßÀÑ½ê
};

struct gravity2 {
  double f[3];
};

cilk struct gravity2 force (int x, int y, int z, double *cur)
{
  double dx, dy, dz;
  double one_d2th, one_d3th;
  struct gravity2 ret;
#ifdef DEBUG
  fprintf (stderr, "%d %d %d\n", x, y, z);
#endif
  dx = (double)x - cur[0];
  dy = (double)y - cur[1];
  dz = (double)z - cur[2];
  one_d2th = 1.0/(dx*dx+dy*dy+dz*dz);
  one_d3th = sqrt(one_d2th) * one_d2th;
  ret.f[0] = dx * one_d3th;
  ret.f[1] = dy * one_d3th;
  ret.f[2] = dz * one_d3th;
#ifdef DEBUG
  fprintf (stderr, "%lf %lf %lf\n", ret.rf[0], ret.rf[1], ret.rf[2]);
#endif
  return ret;
}
    
cilk struct gravity  
grav_z(int x, int y,
       int minz, int maxz,
       double *cur)
{
    int z;
    struct gravity ret = {{0.0, 0.0, 0.0}, {0.0, 0.0, 0.0}};
    
    inlet void integrate (struct gravity2 result)
      {
        int i;
        for (i=0 ; i<3 ; i++)
          ret.rf[i] += result.f[i];
        for (i=0 ; i<3 ; i++)
          if (ret.rf[i] > 1.0 || ret.rf[i] < -1.0)
            {
              ret.f[i] += ret.rf[i];
              ret.rf[i] = 0.0;
            }
        return;
      }
    
    for(z = minz; z < maxz+1; z++) { // z¼´Êý¸þ¤ÇÊÂÎó²½
      integrate (spawn force (x, y, z, cur));
    }
    sync;
#ifdef DEBUG
    fprintf (stderr, "(x,y)=(%d, %d) --> %lf %lf %lf\n",
             x, y,
             ret.f[0] + ret.rf[0],
             ret.f[1] + ret.rf[1],
             ret.f[2] + ret.rf[2]);
#endif
    return ret;
}

cilk struct gravity  
grav_y(int x,
       int miny, int minz, 
       int maxy, int maxz,
       double *cur)
{
    int y;
    struct gravity ret = {{0.0, 0.0, 0.0}, {0.0, 0.0, 0.0}};
    
    inlet void integrate (struct gravity result)
      {
        int i;
        for (i=0 ; i<3 ; i++)
          ret.f[i] += result.f[i];
        for (i=0 ; i<3 ; i++)
          ret.rf[i] += result.rf[i];
        for (i=0 ; i<3 ; i++)
          if (ret.rf[i] > 1.0 || ret.rf[i] < -1.0)
            {
              ret.f[i] += ret.rf[i];
              ret.rf[i] = 0.0;
            }
        return;
      }
    
    for(y = miny; y < maxy+1; y++) { // y¼´Êý¸þ¤ÇÊÂÎó²½
      integrate (spawn grav_z (x, y, minz, maxz, cur));
    }
    sync;
#ifdef DEBUG
    fprintf (stderr, "(x)=(%d) --> %lf %lf %lf\n",
             x,
             ret.f[0] + ret.rf[0],
             ret.f[1] + ret.rf[1],
             ret.f[2] + ret.rf[2]);
#endif
    return ret;
}

cilk struct gravity  
grav_x(int minx, int miny, int minz, 
       int maxx, int maxy, int maxz,
       double *cur)
{
    int x;
    struct gravity ret = {{0.0, 0.0, 0.0}, {0.0, 0.0, 0.0}};
    
    inlet void integrate (struct gravity result)
      {
        int i;
        for (i=0 ; i<3 ; i++)
          ret.f[i] += result.f[i];
        for (i=0 ; i<3 ; i++)
          ret.rf[i] += result.rf[i];
        for (i=0 ; i<3 ; i++)
          if (ret.rf[i] > 1.0 || ret.rf[i] < -1.0)
            {
              ret.f[i] += ret.rf[i];
              ret.rf[i] = 0.0;
            }
        return;
      }
    
    for(x = minx; x < maxx+1; x++) { // x¼´Êý¸þ¤ÇÊÂÎó²½
        integrate (spawn grav_y (x, miny, minz, maxy, maxz, cur));
    }
    sync;
    return ret;
}

cilk int cilk_main(int argc, char *argv[])
{
  struct gravity tsk;
  int i;
  int minx, miny, minz, maxx, maxy, maxz;
  double cur[3];
  Cilk_time tm_begin, tm_elapsed;
  Cilk_time wk_begin, wk_elapsed;
  Cilk_time cp_begin, cp_elapsed;



  if (argc < 10) {
    printf("%s: (minx, miny, minz)--(maxx, maxy, maxz) and (curx, cury, curz) required.\n", argv[0]);
    return 1;
  }
  if (argc > 10)
    printf("%s: extra arguments being ignored\n", argv[0]);

  minx = atoi (argv[1]);
  miny = atoi (argv[2]);
  minz = atoi (argv[3]);
  maxx = atoi (argv[4]);
  maxy = atoi (argv[5]);
  maxz = atoi (argv[6]);
  cur[0] = ((double)(atoi (argv[7])))/100;
  cur[1] = ((double)(atoi (argv[8])))/100;
  cur[2] = ((double)(atoi (argv[9])))/100;

  fprintf(stderr, "start (%d, %d, %d,)--(%d, %d, %d): (%lf, %lf, %lf)\n",
          minx,
          miny,
          minz,
          maxx,
          maxy,
          maxz,
          cur[0],
          cur[1],
          cur[2]);

  /* Timing. "Start" timers */
  sync;
  cp_begin = Cilk_user_critical_path;
  wk_begin = Cilk_user_work;
  tm_begin = Cilk_get_wall_time();

  tsk = spawn grav_x(minx, miny, minz,
                     maxx, maxy, maxz,
                     cur);
  sync;
  for (i=0; i<3; i++)
      tsk.f[i] += tsk.rf[i];
  
  /* Timing. "Stop" timers */
  tm_elapsed = Cilk_get_wall_time() - tm_begin;
  wk_elapsed = Cilk_user_work - wk_begin;
  cp_elapsed = Cilk_user_critical_path - cp_begin;

  fprintf(stderr, "f = (%lf, %lf, %lf)\n",
          tsk.f[0], tsk.f[1], tsk.f[2]);
  
  printf("\n");
  printf("Running time  = %4f s\n", Cilk_wall_time_to_sec(tm_elapsed));
  printf("Work          = %4f s\n", Cilk_time_to_sec(wk_elapsed));
  printf("Critical path = %4f s\n\n", Cilk_time_to_sec(cp_elapsed));

  return 0;
}
