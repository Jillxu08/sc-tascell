;;; Copyright (c) 2009 Tasuku Hiraishi <tasuku@media.kyoto-u.ac.jp>
;;; All rights reserved.

;;; Redistribution and use in source and binary forms, with or without
;;; modification, are permitted provided that the following conditions
;;; are met:
;;; 1. Redistributions of source code must retain the above copyright
;;;    notice, this list of conditions and the following disclaimer.
;;; 2. Redistributions in binary form must reproduce the above copyright
;;;    notice, this list of conditions and the following disclaimer in the
;;;    documentation and/or other materials provided with the distribution.

;;; THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND
;;; ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
;;; IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
;;; ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR BE LIABLE
;;; FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
;;; DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
;;; OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
;;; HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
;;; LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
;;; OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
;;; SUCH DAMAGE.

;;; Spanning tree

;; task 0 0 0 3
;; <graph-type>
;; <algorithm>
;; <show-graph-p>
;; <show-tree-p>

(c-exp "#include<sys/time.h>")
(c-exp "#include\"xccmem.h\"")

;;; ワーカごとに処理したタスクの数をカウントして表示
(%defconstant COUNT-NTASK 1)

(%ifndef* NF-TYPE
  (%defconstant NF-TYPE GCC)) ; one of (GCC LW-SC CL-SC XCC XCCCL)
(%include "rule/tcell-setrule.sh")

(%include "clib.sh")
(%include "dprint.sh")

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(def (csym::elapsed-time tp) 
    (fn double (array (struct timeval) 2))
  (return (+ (- (fref (aref tp 1) tv-sec)
                (fref (aref tp 0) tv-sec))
             (* 0.000001
                (- (fref (aref tp 1) tv-usec)
                   (fref (aref tp 0) tv-usec))))))
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(%defmacro when (exp &body body)
  `(if ,exp (begin ,@body)))
(%defmacro unless (exp &body body)
  `(when (not ,exp) ,@body))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(%defconstant MAX-V (+ (* 8 1024 1024) 321))
(%defconstant MAX-E (+ (* 64 1024 1024) 321))
(%defconstant V-LIST-ALLOC-SIZE 600)
;;; (%defconstant V-LIST-ALLOC-SIZE 200)

;;;;;;;;;;
(def V-Length int)                      ; グラフの全頂点数

(def (struct vertex)
    (def degree int)                    ; 接続している枝の数
  (def first-e int)                     ; 枝のうちの1つ（残りはnext-eで辿る）
  (def parent int))                     ; spanning treeの親の頂点ID+1，未定の場合は0，rootは自分自身を指す

(def VV (array (struct vertex) MAX-V))

;;;;;;;;;;
(def E-Length int)                      ; グラフの全枝数

(def (struct edge)
  (def next-v int)                      ; 枝が指している頂点
  (def next-e int))                     ; 次の枝

(def EE (array (struct edge) MAX-E))

;;;;;;;;;;
;;; list of arrays of vertices
;;; （作業スタック）
(def V-List-Length int)                 ; スタックの長さ

(def (struct v-list-body)
  (def next (ptr (struct v-list-body)))   ; 次の要素
  (def i int)                             ; スタックポインタ（(== i V-LIST-ALLOC-SIZE)が底）
  (def v (array int V-LIST-ALLOC-SIZE)))  ; 頂点IDのリスト

(def V-List (ptr (struct v-list-body)))

;;; 並列版ではワーカごとにスタックを持つ
(def worker-data
    (%ifdef* COUNT-NTASK
      (def n-task int))
  (def V-List-Length int)
  (def V-List (ptr (struct v-list-body))))

(decl (csym::alloc-v-list next) (csym::fn (ptr (struct v-list-body)) (ptr (struct v-list-body))))

(def worker-init
    (%ifdef* COUNT-NTASK
      (= WDATA.n-task 0))
  (= WDATA.V-List (csym::alloc-v-list 0))
  (= WDATA.V-List-Length 1)
  )

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;; v-list-bodyを1個push
;;; lengthの値は別途処理する必要があるので注意
(def (csym::alloc-v-list next) (csym::fn (ptr (struct v-list-body)) (ptr (struct v-list-body)))
  (def a (ptr (struct v-list-body)))
  (= a (cast (ptr (struct v-list-body))
         (csym::malloc (sizeof (struct v-list-body)))))
  (= a->next next)
  (= a->i V-LIST-ALLOC-SIZE)
  (return a))

;;; v-list-bodyを1個pop
;;; lengthの値は別途処理する必要があるので注意
(def (csym::dealloc-v-list a) (csym::fn (ptr (struct v-list-body)) (ptr (struct v-list-body)))
  (def next (ptr (struct v-list-body)))
  (= next a->next)
  (csym::free a)
  (return next))

;;; v-list aの後ろにbを連結（破壊的）
;;; lengthの値は別途処理する必要があるので注意
(def (csym::nconc-v-list a b) (csym::fn (ptr (struct v-list-body)) (ptr (struct v-list-body)) (ptr (struct v-list-body)))
  (def cur (ptr (struct v-list-body)))
  (if a
      (begin
        (for ((= cur a) cur->next (= cur cur->next)))
        (= cur->next b)
        (return a))
    (return b)))

;;;;;;;;;;

;;; serial DF search with v_list
(def (csym::search-s2 fv) (csym::fn void int)
  (def my-v-list (ptr (struct v-list-body)))
  (def my-v-list-length int)            ; 作業中のv-list-body
  (def vi int)                          ; ローカルなスタックポインタ（(== vi V-LIST-ALLOC-SIZE)が底）
  (= (fref (aref VV fv) parent) (+ fv 1))
  (= my-v-list (csym::alloc-v-list 0))
  (= my-v-list-length 1)
  (= vi my-v-list->i)
  (= (aref my-v-list->v (-- vi)) fv)    ; スタックに最初の要素追加
  (while (< vi V-LIST-ALLOC-SIZE)
    (def v int (aref my-v-list->v (inc vi))) ; スタックから一要素取り出す
    (def i int)
    (def d int (fref (aref VV v) degree))
    (def e int (fref (aref VV v) first-e))
    (for ((= i 0) (< i d) (exps (inc i) (= e (fref (aref EE e) next-e))))
      (def nv int (fref (aref EE e) next-v))
      (when (== (fref (aref VV nv) parent) 0)
        (when (csym::cas-int (fref (aref VV nv) parent) 0 (+ v 1)) ; 枝の先の頂点の親を自分にセット．成功したら0
          (continue))                   ; すでにチェック済ならとばす
        (when (<= vi 0)                 ; 配列が一杯になったらv-list-bodyをpush
          (= my-v-list->i vi)           ; スタックポインタを構造体に反映
          (= my-v-list (csym::alloc-v-list my-v-list))
          (inc my-v-list-length)
          (= vi my-v-list->i))
        (= (aref my-v-list->v (-- vi)) nv))) ; 枝の先の頂点をスタックに追加
    (while (and (== vi V-LIST-ALLOC-SIZE) ; スタックが空になったらv-list-bodyをpop
                (> my-v-list-length 1))
      (= my-v-list (csym::dealloc-v-list my-v-list))
      (dec my-v-list-length)
      (= vi my-v-list->i)))
  (= my-v-list->i vi))                  ; スタックポインタを構造体に反映（一応）

;;;;;;;;;;;;;;;;;;;;

;;; recursive DF search with a bound "b" spilling into v_list
(def (csym::search1 v b) (csym::fn void int int)
  (def i int)
  (def d int (fref (aref VV v) degree))
  (def e int (fref (aref VV v) first-e))
  ;; (DEBUG-PRINT 1 "search1 v:%d b:%d d:%d~%" v b d)
  ;; うまくdo-manyにできるか？
  (for ((= i 0) (< i d) (exps (inc i) (= e (fref (aref EE e) next-e))))
    (def nv int (fref (aref EE e) next-v))
    ;; (DEBUG-PRINT 1 "nv: %d~%" nv)
    (when (== (fref (aref VV nv) parent) 0)
      (unless (csym::cas-int (fref (aref VV nv) parent) 0 (+ v 1)) ; 成功したら0
        (if (> b 0)
            (csym::search1 nv (- b 1))
          (begin
            (when (<= V-List->i 0)
              (= V-List (csym::alloc-v-list V-List))
              (inc V-List-Length))
            (= (aref V-List->v (-- V-List->i)) nv)))))))

;;; employing DF search1 for each vertex in v_list.
;;; repeat until the "next" v_list is empty.
(def (csym::search v) (csym::fn void int)
  (defs (ptr (struct v-list-body)) my-v-list mlist next)
  (defs int i j my-v-list-length mlist-length)
  (DEBUG-PRINT 1 "search v:%d~%" v)
  (= (fref (aref VV v) parent) (+ v 1))
  (= V-List (csym::alloc-v-list 0))
  (= V-List-Length 1)
  (csym::search1 v 30)
  (DEBUG-PRINT 1 "V-List-Length: %d~%" V-List-Length)
  (do-while (or (> V-List-Length 1)
                (< V-List->i V-LIST-ALLOC-SIZE))
    ;; V-Listをmy-v-listに移す
    (= my-v-list V-List) (= mlist my-v-list)
    (= my-v-list-length V-List-Length) (= mlist-length my-v-list-length)
    (= V-List (csym::alloc-v-list 0))
    (= V-List-Length 1)
    (for ((= i 0) (< i my-v-list-length) (exps (inc i) (= my-v-list my-v-list->next)))
      (for ((= j  my-v-list->i) (< j V-LIST-ALLOC-SIZE) (inc j))
        (csym::search1 (aref my-v-list->v j) 30)))
    (for ((= i 0) (< i mlist-length) (inc i))
      (= mlist (csym::dealloc-v-list mlist)))
    (DEBUG-PRINT 1 "V-List-Length: %d~%" V-List-Length)
    ))

;;;;;;;;;;
;;; Parallel version
(decl (search1-p v b k0 k1) (wfn void int int int int))
(decl (search-p-b my-v-list i0 i1) (wfn void (ptr (struct v-list-body)) int int))
(decl (search-p-c my-v-list j0 j1) (wfn void (ptr (struct v-list-body)) int int))

;;; parallel version of search1
(def (task t-search1)
  (def v int :in)
  (def b int :in)
  (def k0 int :in)
  (def k1 int :in)
  (def v-list (ptr (struct v-list-body)) :out)
  (def v-list-length int :out)
  )
;;
(def (task-body t-search1)
    (%ifdef* COUNT-NTASK
      (++ WDATA.n-task)
      (csym::fprintf stderr "Worker %d starts %d-th task (t-search1)~%" WORKER-ID WDATA.n-task))
  (search1-p this.v this.b this.k0 this.k1)
  (= this.v-list WDATA.V-List)
  (= this.v-list-length WDATA.V-List-Length)
  (= WDATA.V-List (csym::alloc-v-list 0))
  (= WDATA.V-List-Length 1)
  )
;;
(def (search1-p v b k0 k1) (wfn void int int int int)
  (def i int)
  (def e int (fref (aref VV v) first-e))
  (def nv int)
  ;; (DEBUG-PRINT 1 "[%2d] search1-p v:%d b:%d %d %d~%" WORKER-ID v b k0 k1)
  (for ((= i 0) (< i k0) (inc i))
    (= e (fref (aref EE e) next-e)))
  (do-many for i from k0 to k1
    (= nv (fref (aref EE e) next-v))
    ;; (DEBUG-PRINT 1 "nv: %d~%" nv)
    (when (== (fref (aref VV nv) parent) 0)
      ;; (DEBUG-PRINT 1 "try cas~%")
      (unless (csym::cas-int (fref (aref VV nv) parent) 0 (+ v 1)) ; 成功したら0
        ;; (DEBUG-PRINT 1 "cas succeeded~%")
        (if (> b 0)                     ; boundaryに達していなければ深さ優先
            (search1-p nv (- b 1) 0 (fref (aref VV nv) degree))
          (begin                        ; boundaryに達していればスタックに積んで幅優先
            (when (<= WDATA.V-List->i 0)
              (= WDATA.V-List (csym::alloc-v-list WDATA.V-List))
              (inc WDATA.V-List-Length))
            (= (aref WDATA.V-List->v (-- WDATA.V-List->i)) nv)))))
    (= e (fref (aref EE e) next-e))
    (t-search1
     (:put from k0-2 to k1-2
           (= this.v v)  (= this.b b)
           (= this.k0 k0-2) (= this.k1 k1-2))
     (:get (= WDATA.V-List (csym::nconc-v-list this.v-list WDATA.V-List))
           (+= WDATA.V-List-Length this.v-list-length)))
     ))

;;; parallel version of search
(def (search-p v) (wfn void int)
  (defs (ptr (struct v-list-body)) my-v-list mlist)
  (defs int i my-v-list-length mlist-length)
  (DEBUG-PRINT 1 "[%2d] search-p v:%d~%" WORKER-ID v)
  (= (fref (aref VV v) parent) (+ v 1))
  (search1-p v 30 0 (fref (aref VV v) degree))
  (DEBUG-PRINT 1 "V-List-Length: %d~%" WDATA.V-List-Length)
  (do-while (or (> WDATA.V-List-Length 1)
                (< WDATA.V-List->i V-LIST-ALLOC-SIZE))
    ;; WDATA.V-Listをmy-v-listに移す
    (= my-v-list WDATA.V-List) (= mlist my-v-list)
    (= my-v-list-length WDATA.V-List-Length) (= mlist-length my-v-list-length)
    (= WDATA.V-List (csym::alloc-v-list 0))
    (= WDATA.V-List-Length 1)
    ;; my-v-listを処理
    (search-p-b my-v-list 0 my-v-list-length)
    ;; 処理済みのmy-v-listを解放
    (for ((= i 0) (< i mlist-length) (inc i))
      (= mlist (csym::dealloc-v-list mlist)))
    (DEBUG-PRINT 1 "V-List-Length: %d~%" WDATA.V-List-Length)
    )
  (DEBUG-PRINT 1 "search-p finishing.~%")
  )
;;;
(def (task t-search-b)
  (def my-v-list (ptr (struct v-list-body)) :in)
  (def i0 int :in)
  (def i1 int :in)
  (def v-list (ptr (struct v-list-body)) :out)
  (def v-list-length int :out)
  )
;;
(def (task-body t-search-b)
    (%ifdef* COUNT-NTASK
      (++ WDATA.n-task)
      (csym::fprintf stderr "Worker %d starts %d-th task (t-search-b)~%" WORKER-ID WDATA.n-task))
  (search-p-b this.my-v-list this.i0 this.i1)
  (= this.v-list WDATA.V-List)
  (= this.v-list-length WDATA.V-List-Length)
  (= WDATA.V-List (csym::alloc-v-list 0))
  (= WDATA.V-List-Length 1)
  )
;;
(def (search-p-b my-v-list i0 i1) (wfn void (ptr (struct v-list-body)) int int)
  (def i int)
  (def my-v-list0 (ptr (struct v-list-body)))
  (DEBUG-PRINT 1 "[%2d] search-p-b %p %d %d~%" WORKER-ID my-v-list i0 i1)
  (for ((= i 0) (< i i0) (inc i))
    (= my-v-list my-v-list->next))
  (-= i1 i0) (= i0 0)
  (= my-v-list0 my-v-list)
  (do-many for i from i0 to i1
    (search-p-c my-v-list my-v-list->i V-LIST-ALLOC-SIZE)
    (= my-v-list my-v-list->next)
    (t-search-b                           ; my-v-list0の i0-2~i1-2 の範囲を渡す
     (:put from i0-2 to i1-2
           (= this.my-v-list my-v-list0)
           (= this.i0 i0-2) (= this.i1 i1-2))
     (:get (= WDATA.V-List (csym::nconc-v-list this.v-list WDATA.V-List))
           (+= WDATA.V-List-Length this.v-list-length)))
    ))
;;;
(def (task t-search-c)
  (def my-v-list (ptr (struct v-list-body)) :in)
  (def j0 int :in)
  (def j1 int :in)
  (def v-list (ptr (struct v-list-body)) :out)
  (def v-list-length int :out)
  )
;;
(def (task-body t-search-c)
    (%ifdef* COUNT-NTASK
      (++ WDATA.n-task)
      (csym::fprintf stderr "Worker %d starts %d-th task (t-search-c)~%" WORKER-ID WDATA.n-task))
  (search-p-c this.my-v-list this.j0 this.j1)
  (= this.v-list WDATA.V-List)
  (= this.v-list-length WDATA.V-List-Length)
  (= WDATA.V-List (csym::alloc-v-list 0))
  (= WDATA.V-List-Length 1)
  )
;;;
(def (search-p-c my-v-list j0 j1) (wfn void (ptr (struct v-list-body)) int int)
  (def j int)
  (DEBUG-PRINT 1 "[%2d] search-p-c %p %d %d~%" WORKER-ID my-v-list j0 j1)
  (do-many for j from j0 to j1
    (search1-p (aref my-v-list->v j) 30 0 (fref (aref VV (aref my-v-list->v j)) degree))
    (t-search-c
     (:put from j0-2 to j1-2
           (= this.my-v-list my-v-list)
           (= this.j0 j0-2) (= this.j1 j1-2))
     (:get (= WDATA.V-List (csym::nconc-v-list this.v-list WDATA.V-List))
           (+= WDATA.V-List-Length this.v-list-length)))
    ))
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

;;; for graph construction
;;; v1->v2の枝を作ってeの位置に格納．返り値は次の枝の格納場所
(def (csym::make-edge1 v1 v2 e) (csym::fn int int int int)
  (= (fref (aref EE e) next-v) v2)
  (= (fref (aref EE e) next-e) (fref (aref VV v1) first-e))
  (= (fref (aref VV v1) first-e) (inc e)) ; v1の枝リストにpush
  (inc (fref (aref VV v1) degree))
  (return e))

;;; v1->v2の枝があれば1，そうでなければ0を返す
(def (csym::check-dup1 v1 v2) (csym::fn int int int)
  (def i int)
  (def d int (fref (aref VV v1) degree))
  (def e int (fref (aref VV v1) first-e))
  (for ((= i 0) (< i d) (exps (inc i) (= e (fref (aref EE e) next-e))))
    (def nv int (fref (aref EE e) next-v))
    (when (== nv v2)
      (return 0)))
  (return 1))

;;; v1->v2の枝がなければ作る．返り値は次の枝の格納場所
(def (csym::check-make-edge1 v1 v2 e) (csym::fn int int int int)
  (when (csym::check-dup1 v1 v2)
    (= e (csym::make-edge1 v1 v2 e)))
  (return e))

;;; v1<->v2の両方向の枝を作る．返り値は次の枝の格納場所
(def (csym::make-edge v1 v2 e) (csym::fn int int int int)
  (= e (csym::make-edge1 v1 v2 e))
  (= e (csym::make-edge1 v2 v1 e))
  (return e))

;;; v1<->v2の両方向の枝を，既に枝がないかそれぞれ確認してから作る．
;;; 返り値は次の枝の格納場所
(def (csym::check-make-edge v1 v2 e) (csym::fn int int int int)
  (= e (csym::check-make-edge1 v1 v2 e))
  (= e (csym::check-make-edge1 v2 v1 e))
  (return e))

;;;;;;;;;;

;;; 2D-torus
(def (csym::make-2dt n) (csym::fn void int)
  (defs int ix iy e)
  (def next unsigned-long n)
  (fprintf stderr "%dx%d nodes 2D torus~%" n n)
  (for ((= ix 0) (< ix n) (inc ix))
    (for ((= iy 0) (< iy n) (inc iy))
      (def k int (+ (* ix n) iy))
      (= (fref (aref VV k) degree) 0)
      (= (fref (aref VV k) first-e) 0)
      (= (fref (aref VV k) parent) 0)))
  (= e 0)
  (for ((= ix 0) (< ix n) (inc ix))
    (for ((= iy 0) (< iy n) (inc iy))
      (def k int (+ (* ix n) iy))
      (def px int (- ix 1))
      (def py int (- iy 1))
      (def sx int (+ ix 1))
      (def sy int (+ iy 1))
      (when (< px 0) (+= px n))
      (when (< py 0) (+= py n))
      (when (>= sx n) (-= sx n))
      (when (>= sy n) (-= sy n))
      (%if* 1
        ;; employing pseudo randomness
        (begin
          (def v (array int 4))
          (defs int p q)
          (= (aref v 0) (+ (* ix n) py))
          (= (aref v 1) (+ (* px n) iy))
          (= (aref v 2) (+ (* ix n) sy))
          (= (aref v 3) (+ (* sx n) iy))
          (= next (+ (* next 1103515245) 12345))
          (for ((= q 4) (> q 0) (-- q))
            (= next (+ (* next 1103515245) 12345))
            (= p (/ (* q (% (/ next 65536) 32768)) 32768))
            (= e (csym::check-make-edge1 k (aref v p) e))
            (= (aref v p) (aref v (- q 1)))))
        %else
        ;; without pseudo randomness, some unfair preference exists.
        ;; for s2
        (begin
          (= e (csym::make-edge (+ (* ix n) iy) (+ (* ix n) sy) e))
          (= e (csym::make-edge (+ (* ix n) iy) (+ (* sx n) iy) e)))
        ;; for calldfs
        ;; (begin
        ;;   (= e (csym::make-edge (+ (* ix n) iy) (+ (* sx n) iy) e))
        ;;   (= e (csym::make-edge (+ (* ix n) iy) (+ (* ix n) sy) e)))
          )))
  (= V-Length (* n n))
  (= E-Length e))

;;; hyper-cube
(def (csym::make-ncube n) (csym::fn void int)
  (defs int i j (s (<< 1 n)) (e 0))
  (def next unsigned-long n)
  (fprintf stderr "%d-D hypercube~%" n n)
  (for ((= i 0) (< i s) (inc i))
    (= (fref (aref VV i) degree) 0)
    (= (fref (aref VV i) first-e) 0)
    (= (fref (aref VV i) parent) 0))
  (for ((= i 0) (< i s) (inc i))
    (%if* 1
      (defs int p q)
      (def v (ptr int) (cast (ptr int) (csym::malloc (* n (sizeof int)))))
      (for ((= j 0) (< j n) (inc j))
        (= (aref v j) (bit-xor i (<< 1 j))))
      (= next (+ (* next 1103515245) 12345))
      (for ((= q n) (> q 0) (-- q))
        (= next (+ (* next 1103515245) 12345))
        (= p (/ (* q (% (/ next 65536) 32768)) 32768))
        (= e (csym::make-edge1 i (aref v p) e))
        (= (aref v p) (aref v (- q 1))))
      (csym::free v)
      %else
      (for ((= j 0) (< j n) (inc j))
        (%if* 1
          (def b int (<< 1 j))
          %else
          (def b int (<< 1 (- n 1 j))))
        (= e (csym::make-edge1 1 (bit-xor i b) e))))
    )
  (= V-Length s)
  (= E-Length e))

;;; random or Greiner93
(def (csym::make-random n m) (csym::fn void int int)
  (defs int i j (e 0))
  (def next unsigned-long (+ n m))
  (csym::fprintf stderr "%d nodes random (%d edges per node)~%" n m)
  (for ((= i 0) (< i n) (inc i))
    (= (fref (aref VV i) degree) 0)
    (= (fref (aref VV i) first-e) 0)
    (= (fref (aref VV i) parent) 0))
  (for ((= i 0) (< i n) (inc i))
    (= next (+ (* next 1103515245) 12345))
    (for ((= j 0) (< j m) (inc j))
      (def v int)
      (= next (+ (* next 1103515245) 12345))
      (= v (/ (* n (% (/ next 65536) 32768)) 32768))
      (= e (csym::check-make-edge i v e))))
  (= V-Length n)
  (= E-Length e))

;;;;;;;;;;

;;; graph utils
;;; "頂点番号[親の頂点番号] (接続されている頂点番号のリスト)" を出力
(def (csym::show-graph) (csym::fn void)
  (defs int v e i)
  (for ((= v 0) (< v V-Length) (inc v))
    (csym::fprintf stderr "%9d[%d] (" v (- (fref (aref VV v) parent) 1))
    (begin
      (def d int (fref (aref VV v) degree))
      (def e int (fref (aref VV v) first-e))
      (when (> d 0)
        (csym::fprintf stderr "%d" (fref (aref EE e) next-v))
        (= e (fref (aref EE e) next-e))
        (for ((= i 1) (< i d) (exps (inc i) (= e (fref (aref EE e) next-e))))
          (csym::fprintf stderr ",%d" (fref (aref EE e) next-v)))))
    (csym::fprintf stderr ")~%")))

;;; 単純に頂点と枝の情報のリストを出力
(def (csym::show-graph2) (csym::fn void)
  (defs int v e i)
  (for ((= v 0) (< v V-Length) (inc v))
    (csym::fprintf stderr "%9d[%d] e: %d~%" v (fref (aref VV v) degree) (fref (aref VV v) first-e)))
  (for ((= e 0) (< e E-Length) (inc e))
    (csym::fprintf stderr "%9d => %d -> e: %d~%" e (fref (aref EE e) next-v) (fref (aref EE e) next-e))))

;;; parentの値が想定外のものになっていないかチェック
(def (csym::check-graph) (csym::fn void)
  (def v int)
  (for ((= v 0) (< v V-Length) (inc v))
    (when (or (< (- (fref (aref VV v) parent) 1) 0)
              (>= (- (fref (aref VV v) parent) 1) V-Length))
      (csym::fprintf stderr "!! %9d[%d]~%" v (- (fref (aref VV v) parent) 1)))))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(def (task spanning-start)
  (def graph int :in)                   ; 1: random, 2: 2D-torus, 3: hyper-cube
  (def algorithm int :in)               ; 1: sequential (search-s2), 2: sequential (search), 3: parallel (search-p)
  (def show-graph-p int :in)            ; 0: no, 1: show by show-graph, 2: show by show-graph2
  (def show-tree-p int :in)              ; 0: no, 1: show by show-graph, 2: show by show-graph2
  )

(def (task-body spanning-start)
  (def tp (array (struct timeval) 2))

  (%ifdef* COUNT-NTASK
    (++ WDATA.n-task)
    (csym::fprintf stderr "Worker %d starts %d-th task.~%" WORKER-ID WDATA.n-task))

  ;; constructing graph
  (csym::gettimeofday tp 0)
  (switch this.graph
    (case 1) (csym::make-random (* 2000 2000) 2) (break)
    (case 2) (csym::make-2dt 2000)               (break)
    (case 3) (csym::make-ncube 20)               (break)
    (default) (csym::make-random (* 2000 2000) 2) (break))
  (csym::gettimeofday (+ tp 1) 0)
  (csym::fprintf stderr "Graph constuction time: %lf~%" (csym::elapsed-time tp))
  (csym::fprintf stderr "v: %d e: %d~%" V-Length E-Length)

  (switch this.show-graph-p
    (case 1) (csym::show-graph)  (break)
    (case 2) (csym::show-graph2) (break)
    )

  (csym::gettimeofday tp 0)
  ;; making a spanning tree
  (switch this.algorithm
    (case 1) (csym::search-s2 0) (break)
    (case 2) (csym::search 0)    (break)
    (case 3) (search-p 0)        (break)
    (default) (csym::search-s2 0) (break))
  (csym::gettimeofday (+ tp 1) 0)
  (csym::fprintf stderr "time: %lf~%" (csym::elapsed-time tp))

  (switch this.show-tree-p
    (case 1) (csym::show-graph)  (break)
    (case 2) (csym::show-graph2) (break)
    )

  (csym::check-graph)
  )
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(def (task spanning)
    )

(def (task-body spanning)
    )

