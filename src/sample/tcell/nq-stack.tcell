;;; Copyright (c) 2008-2020 Tasuku Hiraishi <tasuku@media.kyoto-u.ac.jp>
;;; All rights reserved.

;;; Redistribution and use in source and binary forms, with or without
;;; modification, are permitted provided that the following conditions
;;; are met:
;;; 1. Redistributions of source code must retain the above copyright
;;;    notice, this list of conditions and the following disclaimer.
;;; 2. Redistributions in binary form must reproduce the above copyright
;;;    notice, this list of conditions and the following disclaimer in the
;;;    documentation and/or other materials provided with the distribution.

;;; THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND
;;; ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
;;; IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
;;; ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR BE LIABLE
;;; FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
;;; DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
;;; OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
;;; HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
;;; LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
;;; OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
;;; SUCH DAMAGE.

;;; Find all the solutions of the n-queen problem

;; task 0 0 0 0
;; <n>
;; -1

(c-exp "#include<sys/time.h>")

(%include "rule/tcell-setrule.sh")
(%include "clib.sh")
(%include "dprint.sh")
(%cinclude "sendrecv.h" (:macro))

;; Use "user defined spawned range"
(%defconstant USE-SPN-RANGE 0)
;; Use "Probability guard"
(%defconstant USE-PROBGUARD 0)

(def (csym::my-probability n k) (fn double int int)
  (if (>= k 2)
    (return (/ (cast double (- n (+ k 1))) (cast double (- n 2))))
    (return 1.0)))
  ; constant probability
  ; (if (>= k 2)
  ;   (return (/ 1.0 16.0))
  ;   (return 1.0)))
  ; threshold based probability
  ; (if (>= k 2)
  ;   (return 0.0)
  ;   (return 1.0)))

;;; thread local strogae
(def (task nqueens)
  (def r int :out)  ; （部分）解の数
  (def n int :in)   ;  問題サイズ
  (def k int :in)   ;  初期化->探索開始(-1) or 部分探索開始かのフラグ(>=0)
  (def i1 int)  ;  探索範囲 start
  (def i2 int)  ;  探索範囲 end
  (def a (array int 20)) ; 使用済み行の管理
  (def lb (array int 40)) ; 盤面情報1
  (def rb (array int 40)) ; 盤面情報2
  )

(def (task-sender nqueens)
  (def i int 0)
  (if (>= this.k 0)
      (begin
       (csym::send-int this.i1)
       (csym::send-int this.i2)
       (for ((= i 0) (< i this.n) (inc i))
            (csym::send-int (aref this.a i)))
       (for ((= i 0) (< i (- (* 2 this.n) 1)) (inc i))
            (csym::send-int (aref this.lb i)))
       (for ((= i 0) (< i (- (* 2 this.n) 1)) (inc i))
            (csym::send-int (aref this.rb i)))))
  )

(def (task-receiver nqueens)
  (def i int 0)
  (if (>= this.k 0)
      (begin
       (= this.i1 (csym::recv-int))
       (= this.i2 (csym::recv-int))
       (for ((= i 0) (< i this.n) (inc i))
            (= (aref this.a i) (csym::recv-int)))
       (for ((= i 0) (< i (- (* 2 this.n) 1)) (inc i))
            (= (aref this.lb i) (csym::recv-int)))
       (for ((= i 0) (< i (- (* 2 this.n) 1)) (inc i))
            (= (aref this.rb i) (csym::recv-int)))
  )))

(def (csym::print-int-array a n) (csym::fn void (ptr int) int)
  (def i int 0)
  (for ((= i 0) (< i n) (inc i))
    (csym::fprintf stderr "%d " (aref a i)))
  (csym::fprintf stderr "~%")
  )

;; frame for parallel loop (application independent?)
(def (struct p-frame)
  (def i0 int)    ; loop range [i0,i1). i0 is updated for each iteration as a loop variable
  (def i1 int))

;; frame for dynamic wind (application dependent)
(def (struct d-frame)
  (def lb-index int)
  (def rb-index int)
  (def i int)
  (def k int))

(def (union pd-frame)
  (def pf (struct p-frame))
  (def df (struct d-frame))) 

(def (struct frame)
  (def frm-t int) ; >=0: p-frame (the previous p-frame index) <0: d-frame
  (def frm (union pd-frame)))

(def (csym::print-stack stk stk-sz) (csym::fn void (ptr (struct frame)) int)
  (def i int 0)
  (for ((= i (- stk-sz 1)) (>= i 0) (dec i))
    (if (< (fref (aref stk i) frm-t) 0)
	(csym::fprintf stdout "%d::(D) lb-index=%d rb-index=%d i=%d k=%d~%" i
		       (fref (aref stk i) frm df lb-index)
		       (fref (aref stk i) frm df rb-index)
		       (fref (aref stk i) frm df i)
		       (fref (aref stk i) frm df k))
      (csym::fprintf stdout "%d::(P) prev-p-frame=%d i0=%d i1=%d~%" i
		     (fref (aref stk i) frm-t)
		     (fref (aref stk i) frm pf i0)
		     (fref (aref stk i) frm pf i1))))
  (csym::fprintf stdout "~%")
  )

(def (csym::nqueens-dprint comment stk stk-sz pf-top k n i0-cache i1-cache)
    (csym::fn void (ptr char) (ptr (struct frame)) int int int int int int)
  (csym::fprintf stdout "[%s]~%" comment)
  (csym::fprintf stdout "stk-sz, pf-top: %d %d~%" stk-sz pf-top)
  (csym::fprintf stdout "k,n: %d,%d~%" k n)
  (csym::fprintf stdout "i0-cache,i1-cache: %d,%d~%" i0-cache i1-cache)
  (csym::print-stack stk stk-sz)
  )
  

;; k: a[j] (0<k)までの行にはもう置いた
;; ix, iy:  探索範囲
(%defconstant STACK-SIZE-MAX 100)
(def (nqueens n k ix iy tsk)
    (wfn int int int int int (ptr (struct nqueens)))
  (def s int 0)
  ;; Initialize the stack
  (def stk (array (struct frame) STACK-SIZE-MAX))
  (def stk-sz int)
  (def i0-cache int) ; cache for the top p-frame
  (def i1-cache int) ; cache for the top p-frame
  (def pf-top int)   ; index of the top p-frame
  ;; set a p-frame to the base of the stack
  (= (fref (aref stk 0) frm-t) 0)
  (= i0-cache ix) ; (= (fref (aref stk 0) frm pf i0) ix)
  (= i1-cache iy) ; (= (fref (aref stk 0) frm pf i1) iy)
  (= pf-top 0)
  (= stk-sz 1)
  (do-two 
      (while stk-sz
	(def i int i0-cache)
	(def ai int (aref tsk->a i))
	(def lb-index int (+ n -1 (- ai) k))
	(def rb-index int (+ ai k))
	;; debug print
	#+debug
	(csym::nqueens-dprint "start" stk stk-sz pf-top k n i0-cache i1-cache)
	;; 駒が置けるかチェック
	(if (not (or (aref tsk->lb lb-index)
		     (aref tsk->rb rb-index)))
	    (begin
	      (if (== k (- n 1))
		  (inc s)
		(begin ;; dynamic-wind
		  ;; push a d-frame to the stack
		  (= (fref (aref stk stk-sz) frm-t) -1)
		  (= (fref (aref stk stk-sz) frm df lb-index) lb-index)
		  (= (fref (aref stk stk-sz) frm df rb-index) rb-index)
		  (= (fref (aref stk stk-sz) frm df i) i)
		  (= (fref (aref stk stk-sz) frm df k) k)
		  (inc stk-sz)
		  #+debug
		  (csym::nqueens-dprint "d-frame pushed" stk stk-sz pf-top k n i0-cache i1-cache)
		  ;; <before>
		  (= (aref tsk->lb lb-index) 1)
		  (= (aref tsk->rb rb-index) 1)
		  (swap (aref tsk->a i) (aref tsk->a k))
		  ;; <body>
		  ;; store values to the top p-frame
		  (= (fref (aref stk pf-top) frm pf i0) i0-cache)
		  (= (fref (aref stk pf-top) frm pf i1) i1-cache)
		  ;; push a p-frame to the stack, but delay the initialization of the frame
		  (= (fref (aref stk stk-sz) frm-t) pf-top)
		  (= i0-cache (+ k 1)) ; (= (fref (aref stk stk-sz) frm pf i0) (+ k 1))
		  (= i1-cache n)       ; (= (fref (aref stk stk-sz) frm pf i1) n)
		  (= pf-top stk-sz)
		  (inc stk-sz)
		  (inc k)
		  #+debug
		  (csym::nqueens-dprint "p-frame pushed" stk stk-sz pf-top k n i0-cache i1-cache)
		  ;; next piece
		  (continue)))))
	;; pop frame(s)
	(while stk-sz
	  (while (< (fref (aref stk (- stk-sz 1)) frm-t) 0)
	    ;; pop d-frame
	    (dec stk-sz)
	    (begin
	      ;; <after>
	      #+debug (csym::fprintf stdout "[d-frame popped]~%")
	      (def lb-index int (fref (aref stk stk-sz) frm df lb-index))
	      (def rb-index int (fref (aref stk stk-sz) frm df rb-index))
	      (def i int (fref (aref stk stk-sz) frm df i))
	      (def k int (fref (aref stk stk-sz) frm df k))
	      (= (aref tsk->lb lb-index) 0)
	      (= (aref tsk->rb rb-index) 0)
	      (swap (aref tsk->a i) (aref tsk->a k)))
	    )
	  ;; Update p-frame by incrementing i0
	  (inc i0-cache)    ; (inc (fref (aref stk (- stk-sz 1)) frm pf i0))
	  #+debug
	  (csym::fprintf stdout "[p-frame updated] i0-cache,i1-cache: %d %d~%" i0-cache i1-cache)
	  (if (== i0-cache  ; (fref (aref stk (- stk-sz 1)) frm pf i0)
		  i1-cache) ; (fref (aref stk (- stk-sz 1)) frm pf i1))
	      ;; Loop finished. Pop the p-frame
	      (begin
		(= pf-top (fref (aref stk (- stk-sz 1)) frm-t))
		(= i0-cache (fref (aref stk pf-top) frm pf i0))
		(= i1-cache (fref (aref stk pf-top) frm pf i1))
		#+debug
		(csym::fprintf stdout "[p-frame popped]  i0-cache,i1-cache: %d %d pf-top: %d~%"
			       i0-cache i1-cache pf-top)
		(dec stk-sz)
		(dec k))
	    ;; next iteration
	    (break)))
	)
      ()
    (handles nqueens
      (:put
	;; (= this (mref tsk))
	;; (= this.k k)
	;; (= this.i1 i1)
	;; (= this.i2 i2)
	)
      (:get (+= s this.r))))
  (return s))

(def (csym::elapsed-time tp) 
    (fn double (array (struct timeval) 2))
  (return (+ (- (fref (aref tp 1) tv-sec)
                (fref (aref tp 0) tv-sec))
             (* 0.000001
                (- (fref (aref tp 1) tv-usec)
                   (fref (aref tp 0) tv-usec))))))

(def (task-body nqueens)
  (def i int)
  (def n int this.n)
  (def k int this.k)
  (decl tp (array (struct timeval) 2))
  (if (> option.verbose 0) (csym::fprintf stderr "start %d %d %d %d~%" n k this.i1 this.i2))
  (%if* USE-PROBGUARD
    (= PROBABILITY (csym::my-probability n k)))
  (if (< k 0)
      (begin
	(for ((= i 0) (< i n) (inc i))
	  (= (aref this.a i) i))
	(for ((= i 0) (< i (- (* 2 n) 1)) (inc i))
	  (= (aref this.lb i) 0)
	  (= (aref this.rb i) 0))
	(csym::gettimeofday tp 0)
	(= this.r
	   (nqueens n 0 0 n (ptr this)))
	(csym::gettimeofday (+ tp 1) 0)
	(csym::fprintf stderr "time: %lf~%"  (csym::elapsed-time tp)))
    (= this.r
       (nqueens n k this.i1 this.i2 (ptr this))))
  (DEBUG-PRINT 1 "end %d %d %d %d~%" k n this.i1 this.i2)
  )
