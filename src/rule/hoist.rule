;;; Copyright (c) 2008 Tasuku Hiraishi <hiraisi@kuis.kyoto-u.ac.jp>
;;; All rights reserved.

;;; Redistribution and use in source and binary forms, with or without
;;; modification, are permitted provided that the following conditions
;;; are met:
;;; 1. Redistributions of source code must retain the above copyright
;;;    notice, this list of conditions and the following disclaimer.
;;; 2. Redistributions in binary form must reproduce the above copyright
;;;    notice, this list of conditions and the following disclaimer in the
;;;    documentation and/or other materials provided with the distribution.

;;; THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND
;;; ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
;;; IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
;;; ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR BE LIABLE
;;; FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
;;; DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
;;; OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
;;; HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
;;; LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
;;; OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
;;; SUCH DAMAGE.

;;; hoisting.rule: move all the declarations to the beginning of a function body.
;;; This transformation should be applied after rename.rule.

;;; to be rewritten as an extension of the sc0t-to-sc0t rule-set.

;;; !!! initializer が副作用を起こす場合は、正しく動作しない

(defpackage "HOIST"
  (:use "CL")
  (:export :remove-const :split-decl-and-body))

(in-package "HOIST")

(defun remove-const (x)
  (when (not (listp x)) (return-from remove-const x))
  (setq x (remove ~const x))
  (when (= 1 (length x))
    (return-from remove-const (remove-const (car x))))
  (mapcar #'remove-const x))     

;; declaration, block-item の返り値を宣言部とbody部に分ける
(defun split-decl-and-body (x)
  (list (apply #'append (mapcar #'first x))
        (remove nil (mapcar #'second x))))

(in-package "RULE")
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(defvar *top-level* t)

;; ((#?(,scs[storage-class-specifier] (,@id-list[identifier]) (lightweight ,@texp-list) ,@body)) ;lw

(define-ruleset hoist (sc2c)
  (initiator 'sc-program))

(defrule sc-program hoist
  ((#?(,@declaration-list) )
   (let ((*top-level* t))
     (apply #'append
	    (hoist:split-decl-and-body (mapcar #'declaration declaration-list)))))
  )

;;; 以下, declaration, block-item の返り値は、
;;; (<関数本体の先頭に出すS式のリスト>
;;;  <元の場所に残すS式>)

;;;;;; declaration ;;;;;;
(defrule declaration hoist
  ;;variable (without initializer)
  ((#?(,scs[storage-class-specifier] ,id[identifier] ,texp))
   (list ~(,x) nil) )
  ;;variable (with initializer)
  ((#?(,scs[storage-class-specifier] ,id[identifier] ,texp ,init))
   (let* ((new-texp (hoist:remove-const texp)))
     (cond
       (*top-level*
	(list (list x) nil))
       ;; string-literal, array
       ((or (stringp init)
	    (and (listp init)
		 (eq ~array (car init))))
	(let* ((init-id (generate-id (string+ (identifier id) "_init")))
	       (sizeof-arg (if (stringp init) init init-id)))
	  (list ~((,scs ,id ,new-texp ,init)
		  (,scs ,init-id (const ,new-texp) ,init))
		~(csym::memcpy ,id ,init-id (sizeof ,sizeof-arg)))))

       ;; struct
       ((and (listp init)
	     (eq ~struct (car init)))
	(let ((init-id (generate-id (string+ (identifier id) "_init"))))
	  (list ~((,scs ,id ,new-texp ,init)
		  (,scs ,init-id ,new-texp ,init))
		~(= ,id ,init-id))))

       ;; otherwise
       (t
	(list ~((,scs ,id ,new-texp ,init))
	      ~(= ,id ,init))))) )

  ;;function
  ((#?(,scs[storage-class-specifier] (,@id-list[identifier])
				     (,fn-tag[function-tag] ,@texp-list) ,@body))
   (let ((*top-level* nil))
     (multiple-value-bind (sepbody1 sepbody2)  ; 先頭の宣言が終わる前後で分割
	 (list-until-if #'(lambda (bi)
                            (not (and (consp bi)
                                      (declaration-tag? (first bi) :sc2c))))
                        body
			:key #'car)
       (let ((fb-sepbody2 (function-body sepbody2)))
	 (list ~((,scs (,@id-list) (,fn-tag ,@texp-list) 
		       ,@sepbody1 ,@(apply #'append fb-sepbody2)))
	       nil)))) )
  ;; other definitions
  ((#?(,dd[def-or-decl] (,soru[struct-or-union] ,id[identifier]) ,@sdeclist) ;str,uni
    #?(def (enum ,id[identifier]) ,@enum-list) ; enum
    #?(deftype ,id[identifier] struct ,@sdecllist) ; deftype (str)
    #?(deftype ,id[identifier] enum ,@enum-list) ; deftype (enum)
    #?(deftype ,id[identifier] ,texp)) ; deftype
   (list ~(,x) nil))
  (otherwise
   (list () x))
  )

;;;;;;; body +α ;;;;;;
; function-attribute & register-decl
(defrule function-body hoist
  ((#?(:attr ,atr   ,@body) )
   ~(:attr ,atr ,@(function-body body)) )
  ((#?((register ,@regarg)   ,@body) )
   ~((register ,@regarg) ,@(function-body body)) )
  ((#?(,@body))
   (hoist:split-decl-and-body (mapcar #'block-item body)) )
  )

;;;;;; statement ;;;;;;
(defrule block-item hoist
  ;;begin
  ((#?(begin ,@body))
   (let ((fb-body (function-body body)))
     (list (first fb-body)
	   ~(begin ,@(second fb-body)))) )
  ;;label
  ((#?(label ,id ,stat))
   (let ((hsb-stat (block-item stat)))
     (list (first hsb-stat)
	   ~(label ,id ,(second hsb-stat)))) )
  ;;case, default
  ((#?(case ,exp) #?(default))
   (list nil x))
  ;;if
  ((#?(if ,exp ,stat1 ,@stat2))
   (let ((stat1-ret (block-item stat1))
	 (stat2-ret (if stat2 (block-item (car stat2)) nil)))
     (if stat2
	 (list (append (first stat1-ret) (first stat2-ret))
	       ~(if ,exp ,(second stat1-ret) ,(second stat2-ret)))
	 (list (first stat1-ret)
	       ~(if ,exp ,(second stat1-ret))))))
  ;;switch
  ((#?(switch ,exp ,@body))
   (let ((fb-body (function-body body)))
     (list (first fb-body)
	   ~(switch ,exp ,@(second fb-body)))) )
  ;;do-while
  ((#?(do-while ,exp ,@body))
   (let ((fb-body (function-body body)))
     (list (first fb-body)
	   ~(do-while ,exp ,@(second fb-body)))))
  ;;goto, continue, break, return
  ((#?(goto ,id) #?(continue) #?(break) #?(return ,@exp) )
   (list nil x) )
  ((#?,exp[expression])
   (list nil x) )
  ;;declaration
  (otherwise
   (declaration x) )
  )
